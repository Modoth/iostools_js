<html>
  <meta charset="utf-8" />

  <script>
    class ResizeWatcher {
      dispose() {
        this.target_.removeEventListener("resize", this.onResize_);
      }

      constructor(target = window, delay = 0) {
        /** @type Window & typeof globalThis */
        this.target_ = target;
        this.onResize_ = this.onResize_.bind(this);
        this.target_.addEventListener("resize", this.onResize_);
        this.resizeThreshold_ = 10;
        this.callbacks_ = [];
        this.isWatching_ = false;
        this.checkThreshold_ = 200;
        this.delay_ = delay;
      }

      register(callback) {
        callback && this.callbacks_.push(callback);
        if (!this.isWatching_) {
          this.isWatching_ = true;
          this.lastCheckTime_ = 0;
          this.lastW_ = this.target_.innerWidth;
          this.lastH_ = this.target_.innerHeight;
        }
      }

      unregister(callback) {
        if (!callback) {
          return;
        }
        const idx = this.callbacks_.findIndex((c) => c === callback);
        if (idx < 0) {
          return;
        }
        this.callbacks_.splice(idx, 1);
        if (this.callbacks_.length === 0) {
          this.isWatching_ = false;
        }
      }

      onResize_(/** @type UIEvent */ ev) {
        if (!this.isWatching_) {
          return;
        }
        const now = Date.now();
        if (now - this.lastCheckTime_ < this.checkThreshold_) {
          return;
        }
        this.lastCheckTime_ = now;
        const raise = () => {
          const w = this.target_.innerWidth;
          const h = this.target_.innerHeight;

          if (
            Math.abs(this.lastW_ - w) < this.resizeThreshold_ &&
            Math.abs(this.lastH_ - h) < this.resizeThreshold_
          ) {
            return;
          }
          this.lastW_ = w;
          this.lastH_ = h;
          for (const callback of this.callbacks_) {
            callback(w, h);
          }
        };
        if (!this.delay_) {
          raise();
        } else {
          setTimeout(() => {
            raise();
          }, this.delay_);
        }
      }
    }

    class MediaConfigManager {
      constructor(propPrefix) {
        this.propPrefix = propPrefix;
        new ResizeWatcher(window, 50).register(() => {
          this.mediaDataCaches = undefined;
        });
      }
      manage(data) {
        if (!data) {
          return;
        }
        for (let p in data) {
          if (!p.startsWith(this.propPrefix)) {
            continue;
          }

          let prop = p.slice(this.propPrefix.length);
          if (!prop) {
            continue;
          }
          if (!Array.isArray(data[p])) {
            data[p] = [data[p]];
          }
          Object.defineProperty(data, prop, {
            get: () => {
              if (this.mediaDataCaches?.has(prop)) {
                return this.mediaDataCaches.get(prop);
              }
              for (let [value, query] of data[p]) {
                if (!query || window.matchMedia?.(query)?.matches) {
                  this.mediaDataCaches = this.mediaDataCaches || new Map();
                  this.mediaDataCaches.set(prop, value);
                  return value;
                }
              }
            },
          });
        }
      }
    }

    class ConfigManager {
      constructor(defaultKeyName = "__id") {
        this.baseKey = "__base";
        this.extendKey = "__extend";
        this.mergeKeyPrefix = "+";
        this.defaultKeyName = defaultKeyName;
      }

      getChildNames(obj) {
        if (!obj) {
          return undefined;
        }
        return Object.keys(obj).filter((k) => k !== this.baseKey);
      }

      getChildren(obj, keyName) {
        const names = this.getChildNames(obj);
        return names && names.map((name) => this.getChild(obj, name, keyName));
      }

      updateChildren(parent, keyName, ...names) {
        names.forEach((name) => this.updateChild(parent, name, keyName));
      }

      updateChild(parent, name, keyName) {
        if (!parent[name]) {
          return;
        }
        keyName = keyName || this.defaultKeyName;
        parent[name] = this.getUpdate(parent[name], keyName);
      }

      getUpdate(obj, keyName) {
        return Object.fromEntries(
          this.getChildren(obj, keyName).map((i) => [i[keyName], i])
        );
      }

      mergeObj(base, additional) {
        if (additional === null) {
          return null;
        }
        const m = {};

        const keys = new Map();
        const objs = [base, additional];
        for (let i = 0; i < objs.length; i++) {
          const obj = objs[i];
          if (!obj) {
            continue;
          }
          for (let kOriginal in obj) {
            let key = kOriginal;
            let merge = false;
            if (kOriginal.startsWith(this.mergeKeyPrefix)) {
              key = kOriginal.slice(this.mergeKeyPrefix.length);
              merge = true;
            }
            const value = keys.get(key) || { keys: [] };
            keys.set(key, value);
            value.merge = merge;
            value.keys[i] = kOriginal;
          }
        }
        for (let [
          key,
          {
            keys: [kBase, kAdditional],
            merge,
          },
        ] of keys) {
          kBase = kBase || key;
          kAdditional = kAdditional || key;
          if (merge) {
            m[key] = this.mergeObj(base?.[kBase], additional?.[kAdditional]);
          } else {
            m[key] =
              additional?.[kAdditional] !== undefined
                ? additional[kAdditional]
                : base?.[kBase];
          }
        }
        return m;
      }

      getChild(obj, childName, keyName) {
        if (!obj || !obj[childName]) {
          return;
        }
        keyName = keyName || this.defaultKeyName;
        const base = obj[childName][this.extendKey]
          ? this.getChild(obj, obj[childName][this.extendKey], keyName)
          : obj[this.baseKey];
        const child = obj[childName];
        child[keyName] = childName;
        if (!base) {
          return child;
        }
        return this.mergeObj(base, child);
      }
    }
    const ClockStatus = {
      Stop: 0,
      Runing: 1,
      Pause: 2,
    };

    class Clock {
      constructor(tps = 1, timeScale = 1) {
        this.now_ = -1;
        this.interval_ = 0;
        this.timeScale = 1;
        this.tps_ = Math.min(1000, tps);
      }

      get now() {
        return this.now_;
      }

      onTick_() {
        this.tick_++;
        const now = Date.now();
        this.now_ = now - this.start_;
        this.tickTime_ += ((now - this.lastTickTime_) * this.timeScale) / 1000;
        this.lastTickTime_ = now;
        let task = this.tasks_[0];
        while (task && task.raiseTick <= this.tick_) {
          task.resolve();
          this.tasks_.shift();
          task = this.tasks_[0];
        }
      }

      start() {
        this.tick_ = 0;
        this.now_ = 0;
        this.tickTime_ = 0;
        this.start_ = Date.now();
        this.tasks_ = [];
        this.resume();
      }

      pause() {
        clearInterval(this.interval_);
        this.status = ClockStatus.Stop;
      }

      startOrResume() {
        if (this.tasks_) {
          this.resume();
        } else {
          this.start();
        }
      }

      resume() {
        this.interval_ = setInterval(this.onTick_.bind(this), 1000 / this.tps_);
        this.lastTickTime_ = Date.now();
        this.status = ClockStatus.Runing;
      }

      stop() {
        this.pause();
        this.status = ClockStatus.Stop;
      }

      get tick() {
        return this.tick_;
      }

      get tickTime() {
        return this.tickTime_;
      }

      get tps() {
        return this.tps_;
      }

      wait(tick = 0) {
        return new Promise((resolve) => {
          const raiseTick = this.tick_ + tick;
          const newTask = { raiseTick, resolve };
          const beforeIdx = this.tasks_.findIndex(
            (t) => t.raiseTick > raiseTick
          );
          if (beforeIdx === -1) {
            this.tasks_.push(newTask);
          } else {
            this.tasks_.splice(beforeIdx - 1, 0, newTask);
          }
        });
      }
    }

    // javascript-astar 0.4.1
    // http://github.com/bgrins/javascript-astar
    // Freely distributable under the MIT License.
    // Implements the astar search algorithm in javascript using a Binary Heap.
    // Includes Binary Heap (with modifications) from Marijn Haverbeke.
    // http://eloquentjavascript.net/appendix2.html

    const { astarG, astar } = (function () {
      function pathTo(node) {
        var curr = node;
        var path = [];
        while (curr.parent) {
          path.unshift(curr);
          curr = curr.parent;
        }
        return path;
      }

      function getHeap() {
        return new BinaryHeap(function (node) {
          return node.f;
        });
      }

      var astar = {
        /**
        * Perform an A* Search on a graph given a start and end node.
        * @param {Graph} graph
        * @param {GridNode} start
        * @param {GridNode} end
        * @param {Object} [options]
        * @param {bool} [options.closest] Specifies whether to return the
                   path to the closest node if the target is unreachable.
        * @param {Function} [options.heuristic] Heuristic function (see
        *          astar.heuristics).
        */
        search: function (graph, start, end, options) {
          graph.cleanDirty();
          options = options || {};
          var heuristic = options.heuristic || astar.heuristics.manhattan;
          var closest = options.closest || false;

          var openHeap = getHeap();
          var closestNode = start; // set the start node to be the closest if required

          start.h = heuristic(start, end);
          graph.markDirty(start);

          openHeap.push(start);

          while (openHeap.size() > 0) {
            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
            var currentNode = openHeap.pop();

            // End case -- result has been found, return the traced path.
            if (currentNode === end) {
              return pathTo(currentNode);
            }

            // Normal case -- move currentNode from open to closed, process each of its neighbors.
            currentNode.closed = true;

            // Find all neighbors for the current node.
            var neighbors = graph.neighbors(currentNode);

            for (var i = 0, il = neighbors.length; i < il; ++i) {
              var neighbor = neighbors[i];

              if (neighbor.closed || neighbor.isWall()) {
                // Not a valid node to process, skip to next neighbor.
                continue;
              }

              // The g score is the shortest distance from start to current node.
              // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.
              var gScore = currentNode.g + neighbor.getCost(currentNode);
              var beenVisited = neighbor.visited;

              if (!beenVisited || gScore < neighbor.g) {
                // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
                neighbor.visited = true;
                neighbor.parent = currentNode;
                neighbor.h = neighbor.h || heuristic(neighbor, end);
                neighbor.g = gScore;
                neighbor.f = neighbor.g + neighbor.h;
                graph.markDirty(neighbor);
                if (closest) {
                  // If the neighbour is closer than the current closestNode or if it's equally close but has
                  // a cheaper path than the current closest node then it becomes the closest node
                  if (
                    neighbor.h < closestNode.h ||
                    (neighbor.h === closestNode.h && neighbor.g < closestNode.g)
                  ) {
                    closestNode = neighbor;
                  }
                }

                if (!beenVisited) {
                  // Pushing to heap will put it in proper place based on the 'f' value.
                  openHeap.push(neighbor);
                } else {
                  // Already seen the node, but since it has been rescored we need to reorder it in the heap
                  openHeap.rescoreElement(neighbor);
                }
              }
            }
          }

          if (closest) {
            return pathTo(closestNode);
          }

          // No result was found - empty array signifies failure to find path.
          return [];
        },
        // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
        heuristics: {
          manhattan: function (pos0, pos1) {
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            return d1 + d2;
          },
          diagonal: function (pos0, pos1) {
            var D = 1;
            var D2 = Math.sqrt(2);
            var d1 = Math.abs(pos1.x - pos0.x);
            var d2 = Math.abs(pos1.y - pos0.y);
            return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
          },
        },
        cleanNode: function (node) {
          node.f = 0;
          node.g = 0;
          node.h = 0;
          node.visited = false;
          node.closed = false;
          node.parent = null;
        },
      };

      /**
       * A graph memory structure
       * @param {Array} gridIn 2D array of input weights
       * @param {Object} [options]
       * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed
       */
      function Graph(gridIn, options) {
        options = options || {};
        this.nodes = [];
        this.diagonal = !!options.diagonal;
        this.grid = [];
        for (var x = 0; x < gridIn.length; x++) {
          this.grid[x] = [];

          for (var y = 0, row = gridIn[x]; y < row.length; y++) {
            var node = new GridNode(x, y, row[y]);
            this.grid[x][y] = node;
            this.nodes.push(node);
          }
        }
        this.init();
      }

      Graph.prototype.init = function () {
        this.dirtyNodes = [];
        for (var i = 0; i < this.nodes.length; i++) {
          astar.cleanNode(this.nodes[i]);
        }
      };

      Graph.prototype.cleanDirty = function () {
        for (var i = 0; i < this.dirtyNodes.length; i++) {
          astar.cleanNode(this.dirtyNodes[i]);
        }
        this.dirtyNodes = [];
      };

      Graph.prototype.markDirty = function (node) {
        this.dirtyNodes.push(node);
      };

      Graph.prototype.neighbors = function (node) {
        var ret = [];
        var x = node.x;
        var y = node.y;
        var grid = this.grid;

        // West
        if (grid[x - 1] && grid[x - 1][y]) {
          ret.push(grid[x - 1][y]);
        }

        // East
        if (grid[x + 1] && grid[x + 1][y]) {
          ret.push(grid[x + 1][y]);
        }

        // South
        if (grid[x] && grid[x][y - 1]) {
          ret.push(grid[x][y - 1]);
        }

        // North
        if (grid[x] && grid[x][y + 1]) {
          ret.push(grid[x][y + 1]);
        }

        if (this.diagonal) {
          // Southwest
          if (grid[x - 1] && grid[x - 1][y - 1]) {
            ret.push(grid[x - 1][y - 1]);
          }

          // Southeast
          if (grid[x + 1] && grid[x + 1][y - 1]) {
            ret.push(grid[x + 1][y - 1]);
          }

          // Northwest
          if (grid[x - 1] && grid[x - 1][y + 1]) {
            ret.push(grid[x - 1][y + 1]);
          }

          // Northeast
          if (grid[x + 1] && grid[x + 1][y + 1]) {
            ret.push(grid[x + 1][y + 1]);
          }
        }

        return ret;
      };

      Graph.prototype.toString = function () {
        var graphString = [];
        var nodes = this.grid;
        for (var x = 0; x < nodes.length; x++) {
          var rowDebug = [];
          var row = nodes[x];
          for (var y = 0; y < row.length; y++) {
            rowDebug.push(row[y].weight);
          }
          graphString.push(rowDebug.join(" "));
        }
        return graphString.join("\n");
      };

      function GridNode(x, y, weight) {
        this.x = x;
        this.y = y;
        this.weight = weight;
      }

      GridNode.prototype.toString = function () {
        return "[" + this.x + " " + this.y + "]";
      };

      GridNode.prototype.getCost = function (fromNeighbor) {
        // Take diagonal weight into consideration.
        if (
          fromNeighbor &&
          fromNeighbor.x != this.x &&
          fromNeighbor.y != this.y
        ) {
          return this.weight * 1.41421;
        }
        return this.weight;
      };

      GridNode.prototype.isWall = function () {
        return this.weight === 0;
      };

      function BinaryHeap(scoreFunction) {
        this.content = [];
        this.scoreFunction = scoreFunction;
      }

      BinaryHeap.prototype = {
        push: function (element) {
          // Add the new element to the end of the array.
          this.content.push(element);

          // Allow it to sink down.
          this.sinkDown(this.content.length - 1);
        },
        pop: function () {
          // Store the first element so we can return it later.
          var result = this.content[0];
          // Get the element at the end of the array.
          var end = this.content.pop();
          // If there are any elements left, put the end element at the
          // start, and let it bubble up.
          if (this.content.length > 0) {
            this.content[0] = end;
            this.bubbleUp(0);
          }
          return result;
        },
        remove: function (node) {
          var i = this.content.indexOf(node);

          // When it is found, the process seen in 'pop' is repeated
          // to fill up the hole.
          var end = this.content.pop();

          if (i !== this.content.length - 1) {
            this.content[i] = end;

            if (this.scoreFunction(end) < this.scoreFunction(node)) {
              this.sinkDown(i);
            } else {
              this.bubbleUp(i);
            }
          }
        },
        size: function () {
          return this.content.length;
        },
        rescoreElement: function (node) {
          this.sinkDown(this.content.indexOf(node));
        },
        sinkDown: function (n) {
          // Fetch the element that has to be sunk.
          var element = this.content[n];

          // When at 0, an element can not sink any further.
          while (n > 0) {
            // Compute the parent element's index, and fetch it.
            var parentN = ((n + 1) >> 1) - 1;
            var parent = this.content[parentN];
            // Swap the elements if the parent is greater.
            if (this.scoreFunction(element) < this.scoreFunction(parent)) {
              this.content[parentN] = element;
              this.content[n] = parent;
              // Update 'n' to continue at the new position.
              n = parentN;
            }
            // Found a parent that is less, no need to sink any further.
            else {
              break;
            }
          }
        },
        bubbleUp: function (n) {
          // Look up the target element and its score.
          var length = this.content.length;
          var element = this.content[n];
          var elemScore = this.scoreFunction(element);

          while (true) {
            // Compute the indices of the child elements.
            var child2N = (n + 1) << 1;
            var child1N = child2N - 1;
            // This is used to store the new position of the element, if any.
            var swap = null;
            var child1Score;
            // If the first child exists (is inside the array)...
            if (child1N < length) {
              // Look it up and compute its score.
              var child1 = this.content[child1N];
              child1Score = this.scoreFunction(child1);

              // If the score is less than our element's, we need to swap.
              if (child1Score < elemScore) {
                swap = child1N;
              }
            }

            // Do the same checks for the other child.
            if (child2N < length) {
              var child2 = this.content[child2N];
              var child2Score = this.scoreFunction(child2);
              if (child2Score < (swap === null ? elemScore : child1Score)) {
                swap = child2N;
              }
            }

            // If the element needs to be moved, swap it, and continue.
            if (swap !== null) {
              this.content[n] = this.content[swap];
              this.content[swap] = element;
              n = swap;
            }
            // Otherwise, we are done.
            else {
              break;
            }
          }
        },
      };

      return {
        astar: astar,
        astarG: Graph,
      };
    })();

    const Api = {
      appService: window.os.app,
      localStorage: window.os.localStorage,
    };

    const cloneObject = (obj) => {
      if (Array.isArray(obj)) {
        return obj.map((e) => cloneObject(e));
      }
      if (obj && typeof obj === "object") {
        let res = {};
        for (let p in obj) {
          res[p] = cloneObject(obj[p]);
        }
        return res;
      }
      return obj;
    };

    let LanguagesInstance = {};

    class UnitConfigManager {
      getGetter(exp) {
        return () => {
          if (typeof exp === "string") {
            const listSplit = "|";
            if (exp.indexOf(listSplit) >= 0) {
              const tokens = exp.split(listSplit).map((s) => s);
              return this.getGetter(Math.floor(Math.random() * tokens.length));
            }
            const randSplit = "~";
            if (exp.indexOf(randSplit) >= 0) {
              let [ave, diff] = exp.split(randSplit).map((t) => Number(t));
              ave = ave || 0;
              diff = diff || 0;
              if (!diff) {
                return ave;
              }
              return ave + (Math.random() - 0.5) * 2 * diff;
            }
            return exp;
          }
          if (Array.isArray(exp)) {
            return exp.map((e) => this.getGetter(e)());
          }
          if (exp && typeof exp === "object") {
            const obj = {};
            for (let key in exp) {
              obj[key] = this.getGetter(exp[key])();
            }
            return obj;
          }
          return exp;
        };
      }
    }

    class App {
      constructor() {
        /** @type { Object.<string,HTMLElement> } */
        this.components;
        registerProperties(
          this,
          "title",
          "stories",
          "storyName",
          "state",
          "session",
          "sessionName",
          "engine",
          "selectedUnit",
          "selectedUnitStrategies",
          "selectedUnitAttackRange",
          "selectedPosition",
          "attacker",
          "theme",
          "themeStr",
          "languages",
          "attackerManager",
          "defenderManager",
          "finished",
          "selectTerrainFor"
        );
        this.clearSelectedUnit = this.clearSelectedUnit.bind(this);
        this.onFinished = this.onFinished.bind(this);
      }

      selectTerrain(pos) {
        if (this.selectTerrainFor) {
          if (this.selectTerrainFor(pos)) {
            this.selectTerrainFor = undefined;
          }
          return;
        }
        this.selectedPosition = pos;
        const selectedUnit =
          GameEngine.Instance.gameObjects.find(
            (o) =>
              !o.disposed &&
              o.Transform?.position &&
              o.Transform.position.x === pos.x &&
              o.Transform.position.y === pos.y
          ) || (pos.group === "wall" ? this.defenderManager : undefined);
        this.selectUnit(selectedUnit);
      }

      clearSelectedUnit() {
        this.selectedUnit = undefined;
        this.selectedPosition = undefined;
      }

      selectUnit(unit) {
        this.selectedUnitAttackRange = undefined;
        if (this.selectedUnit) {
          this.selectedUnit.off("disposed", this.clearSelectedUnit);
        }
        this.selectedUnit = unit;
        if (this.selectedUnit) {
          this.selectedUnit.on("disposed", this.clearSelectedUnit);
        }
        this.selectedUnitStrategies = this.selectedUnit?.Defender?.strategies;
        this.selectedUnitAttackRange =
          (this.selectedUnit?.Defender?.attack?.range || 0) +
          (this.selectedUnit?.Transform?.scale || 0) / 2;
      }

      async loadState() {
        try {
          return JSON.parse(await Api.localStorage.getItem("state")) || {};
        } catch {
          return {};
        }
      }

      async saveState(state) {
        await Api.localStorage.setItem("state", JSON.stringify(state));
      }

      async start() {
        /** @type { { toast:(msg:string, timeout:number = 1000)=>Promise<any> } } */
        this.modal_ = this.components.modal.model;
        /** @type { { toast:(msg:string, timeout:number = 1000)=>Promise<any> } } */
        window.modal_ = this.modal_;
        this.configManager = new ConfigManager("displayName");
        this.fps = this.data.config?.FPS || 90;
        this.guiFps = this.data.config?.GUI_FPS || 60;
        delayDispatcher.setDelay(1000 / this.guiFps);
        this.stories = this.configManager
          .getChildNames(this.data.stories)
          .map((name) => {
            const story = this.data.stories[name];
            story.sessions = this.configManager.mergeObj(
              story.sessions,
              story.sessionMaps
            );
            return {
              name,
              sessions: this.configManager.getChildNames(story.sessions),
            };
          });
        const state = await this.loadState();
        let storyName, sessionName;
        if (state.storyName && this.data.stories[state.storyName]) {
          storyName = state.storyName;
          if (this.data.stories[state.storyName]?.sessions[state.sessionName]) {
            sessionName = state.sessionName;
          } else {
            sessionName = this.stories.find((s) => s.name === storyName)
              .sessions[0];
          }
        } else {
          storyName = this.stories[0].name;
          sessionName = this.stories[0]?.sessions[0];
        }
        await this.loadSession(storyName, sessionName);
      }

      async selectStory() {
        const story = await this.modal_.select(
          this.languages.select,
          this.stories,
          Math.max(
            0,
            this.stories.findIndex((s) => s.name === this.storyName)
          ),
          { requilred: false, itemName: "name" }
        );
        if (!story || story.name === this.storyName) {
          return;
        }
        await this.finishSession();
        // await this.modal_.toast(this.languages.jumpTo + story.name)
        await this.loadStory(story);
      }

      async selectSession() {
        const story = this.stories.find((s) => s, name === this.storyName);
        const sessionName = await this.modal_.select(
          this.languages.select,
          story.sessions,
          Math.max(
            0,
            story.sessions.findIndex((s) => s === this.sessionName)
          )
        );
        if (!sessionName || sessionName === this.sessionName) {
          return;
        }
        // await this.finishSession()
        // await this.modal_.toast(this.languages.jumpTo + sessionName)
        await this.reloadWindow(this.storyName, sessionName);
      }

      async restartSession() {
        await this.reloadWindow(this.storyName, this.sessionName);
      }

      async shutdown() {
        await Api.appService.close();
      }

      async loadNextStory() {
        const storyIdx = this.stories.findIndex(
          (s) => s.name === this.storyName
        );
        let story = this.stories[storyIdx + 1];
        if (!story) {
          await this.modal_.toast(this.languages.allRestart);
          story = this.stories[0];
        }
        await this.loadStory(story);
      }

      async loadStory(story) {
        await this.reloadWindow(story.name, story.sessions[0]);
      }

      async loadNextSession() {
        const story = this.stories.find((s) => s.name === this.storyName);
        const sessionIdx = story.sessions.findIndex(
          (s) => s === this.sessionName
        );
        const sessionName = story.sessions[sessionIdx + 1];
        if (sessionName) {
          await this.reloadWindow(this.storyName, sessionName);
          return;
        }
        this.loadNextStory();
      }

      async loadSession(storyName, sessionName) {
        this.finished = undefined;
        this.selectedPosition = undefined;
        this.selectedUnit = undefined;
        this.storyName = storyName;
        this.sessionName = sessionName;
        this.state = { ...this.state, storyName, sessionName };
        await this.saveState(this.state);
        const sessionData = this.getSessionData(storyName, sessionName);
        this.engine = GameEngine.create(this.fps);
        this.calculator = Calculator.create();
        Object.defineProperty(this.engine, "objectsCanvases", {
          get: () => [
            this.components.objectsCanvas0,
            this.components.objectsCanvas1,
          ],
        });
        this.loadSessionData(sessionData);
        this.session = {};
        await Promise.all([
          GameEngine.Instance.start(),
          // GameEngine.Instance.pause()
        ]);
      }

      getSessionData(storyName, sessionName) {
        const stories = cloneObject(this.data.stories);
        const storyData = this.configManager.getChild(stories, storyName);
        const sessionData = this.configManager.getChild(
          storyData.sessions,
          sessionName
        );
        for (let p of [
          "config",
          "attackers",
          "defenders",
          "bullets",
          "filters",
          "buffers",
        ]) {
          sessionData[p] = this.configManager.mergeObj(
            storyData[p],
            sessionData[p]
          );
        }
        new MediaConfigManager("@media-").manage(sessionData.config);

        //theme
        this.configManager.updateChild(sessionData.config, "themes");
        sessionData.config.theme =
          sessionData.config.themes[sessionData.config.theme];

        this.configManager.updateChildren(
          sessionData,
          undefined,
          "attackers",
          "defenders",
          "bullets",
          "filters",
          "buffers",
          "defenderTypes"
        );

        sessionData.attackerWaves.forEach((w) => {
          w.attackerGroups = w.attackerGroups.map((gs) => {
            gs = this.configManager.getUpdate(gs);
            gs = Object.fromEntries(
              Object.values(gs).map((g) => [
                g.displayName,
                this.configManager.mergeObj(
                  sessionData.attackers[g.displayName],
                  g
                ),
              ])
            );
            return gs;
          });
        });

        sessionData.defenderTypes = Object.fromEntries(
          Object.values(sessionData.defenderTypes).map((t) => [
            t.displayName,
            this.configManager.mergeObj(
              sessionData.defenders[t.displayName],
              t
            ),
          ])
        );
        const updateDefenderType = (type) => {
          let p = "attacks";
          if (type[p]) {
            this.configManager.updateChild(type, p);
            Object.values(type[p]).forEach((attack) => {
              this.configManager.updateChild(attack, "bullet");
              attack.bullet = Object.fromEntries(
                Object.values(attack.bullet).map((b) => [
                  b.displayName,
                  this.configManager.mergeObj(
                    sessionData.bullets[b.displayName],
                    b
                  ),
                ])
              );
              if (attack.filter) {
                this.configManager.updateChild(attack, "filter");
                attack.filter = Object.fromEntries(
                  Object.values(attack.filter).map((b) => [
                    b.displayName,
                    this.configManager.mergeObj(
                      sessionData.filters[b.displayName],
                      b
                    ),
                  ])
                );
              }
              if (attack.buffer) {
                this.configManager.updateChild(attack, "buffer");
                attack.buffer = Object.fromEntries(
                  Object.values(attack.buffer).map((b) => [
                    b.displayName,
                    this.configManager.mergeObj(
                      sessionData.buffers[b.displayName],
                      b
                    ),
                  ])
                );
              }
            });
          }
          p = "upgrades";
          if (type[p]) {
            this.configManager.updateChild(type, p);
            type[p] = Object.fromEntries(
              Object.values(type[p]).map((u) => [
                u.displayName,
                updateDefenderType(
                  this.configManager.mergeObj(
                    sessionData.defenders[u.displayName],
                    u
                  )
                ),
              ])
            );
          }
          return type;
        };
        Object.values(sessionData.defenderTypes).forEach(updateDefenderType);
        sessionData.initDefenders = sessionData.initDefenders || [];
        for (let init of sessionData.initDefenders) {
          this.configManager.updateChild(init, "defender");
          init.defender = Object.fromEntries(
            Object.values(init.defender).map((t) => [
              t.displayName,
              this.configManager.mergeObj(
                sessionData.defenders[t.displayName],
                t
              ),
            ])
          );
          Object.values(init.defender).forEach(updateDefenderType);
        }
        return sessionData;
      }

      loadSessionData(sessionData) {
        this.languages = sessionData.config.languages;
        LanguagesInstance = this.languages;
        this.theme = sessionData.config.theme;
        let themeStr = `
:host{
${Object.entries(this.theme)
  .filter(([_, value]) => value)
  .map(([key, value]) => `\t--${key}:${value};\n`)
  .join("")}
}`;
        this.width = sessionData.width;
        this.height = sessionData.height;
        GameEngine.Instance.worldWidth = this.width;
        GameEngine.Instance.worldHeight = this.height;
        const terrains = Array.from({ length: sessionData.height }, (_y, y) =>
          Array.from({ length: sessionData.width }, (_x, x) => {
            let t = new Terrain();
            t.group = "empty";
            t.x = x;
            t.y = y;
            return t;
          })
        );
        const updateTerrains = (data, update) => {
          let dy = Math.max(
            0,
            Math.floor((sessionData.height - data.length) / 2)
          );
          let dx = Math.max(
            0,
            Math.floor((sessionData.width - data[0].length) / 2)
          );
          for (
            let y = 0;
            y < Math.min(data.length, sessionData.height - dy);
            y++
          ) {
            for (
              let x = 0;
              x < Math.min(data[0].length, sessionData.width - dx);
              x++
            ) {
              update(terrains[y + dy][x + dx], data[y][x], x, y);
            }
          }
        };
        const typeClasses = new Set();
        updateTerrains(sessionData.terrains, (t, d) => {
          t.type = d;
          if (!typeClasses.has(d)) {
            typeClasses.add(d);
            themeStr += `
.type-${d}{
  background: var(--${d}-bg);
  color: var(--${d}-fg);
}
`;
          }
        });
        updateTerrains(sessionData.walls, (t, d) => {
          switch (d) {
            case "1":
              t.group = "floor";
              break;
            case "2":
              t.group = "wall";
              break;
            default:
              break;
          }
        });
        this.engine.terrains = terrains;
        this.themeStr = themeStr;
        this.startPositions = sessionData.starts.map(
          ({ x, y }) => terrains[y][x]
        );
        this.startPositions.forEach((p, i) => (p.startPosition = i + 1));
        this.endPositions = sessionData.ends.map(({ x, y }) => terrains[y][x]);
        this.endPositions.forEach((p, i) => (p.endPosition = i + 1));
        this.attacker = sessionData.config.attacker;
        this.defenderManager = new GameObject(
          new DefenderManager(this, sessionData),
          new Sprite(sessionData.config.defenderName)
        );
        this.attackerManager = new GameObject(
          new AttackerManager(this, sessionData),
          new Sprite(sessionData.config.attackerName)
        );
        GameEngine.Instance.addGameObjects([
          this.defenderManager,
          this.attackerManager,
        ]);
      }

      async finishSession() {
        GameEngine.Instance.stop();
        return;
        this.defenderManager = undefined;
        this.attackerManager = undefined;
        this.engine = undefined;
        this.clearSelectedUnit();
      }

      async onFinished(finished) {
        if (this.finished) {
          return;
        }
        this.finished = finished;
        await this.finishSession();
        await this.modal_.toast(
          this.languages[this.finished > 0 ? "success" : "failed"]
        );
        if (this.finished > 0) {
          await this.loadNextSession();
        } else {
          await this.reloadSession();
        }
      }

      async reloadSession() {
        await this.modal_.toast(this.languages.restart, 2000);
        await this.reloadWindow(this.storyName, this.sessionName);
      }

      async reloadWindow(storyName, sessionName) {
        await this.saveState({ ...this.state, storyName, sessionName });
        window.location.reload();
      }
    }

    class Terrain {
      constructor() {
        registerProperties(
          this,
          "type",
          "group",
          "startPosition",
          "endPosition"
        );
      }
    }

    class Point {
      constructor(x, y) {
        registerProperties(this, "x", "y");
        Object.assign(this, { x, y });
      }

      dist(from) {
        return Math.hypot(this.x - from.x, this.y - from.y);
      }
    }

    class Transform {
      constructor(x, y, speed = 0, scale = 1) {
        registerProperties(
          this,
          "position",
          "target",
          "speed",
          "scale",
          "inCollision",
          "outCollision",
          "withinCollision",
          "inTarget"
        );
        const position =
          x === undefined || y === undefined ? undefined : new Point(x, y);
        this.fromTarget = 0;
        Object.assign(this, { position, speed, scale });
      }

      setPosition(pos) {
        this.position = pos;
        this.calculateFromTarget();
      }

      setTarget(target) {
        this.target = target;
        this.calculateFromTarget();
      }

      calculateFromTarget() {
        if (
          !this.target ||
          !this.position ||
          (this.target.x === this.position.x &&
            this.target.y === this.position.y)
        ) {
          this.fromTarget = 0;
          this.inTarget = true;
          return;
        }
        this.inTarget = undefined;
        this.fromTarget = this.target.dist(this.position);
      }

      updateHard(time) {
        // console.log(tick)
        if (!this.speed || !this.target) {
          return;
        }
        this.calculateFromTarget();
        if (this.fromTarget < Number.EPSILON) {
          this.setPosition(this.target);
          this.setTarget();
          return;
        }
        const lastMoveTime = this.lastMoveTime;
        this.lastMoveTime = time;
        if (!lastMoveTime) {
          return;
        }
        const dt = Math.max(0, time - lastMoveTime);
        const dx =
          (dt * this.speed * (this.target.x - this.position.x)) /
          this.fromTarget;
        const dy =
          (dt * this.speed * (this.target.y - this.position.y)) /
          this.fromTarget;
        const s = Math.hypot(dx, dy);
        if (this.fromTarget - s < Number.EPSILON) {
          this.setPosition(this.target);
          this.setTarget();
        } else {
          this.setPosition(
            new Point(this.position.x + dx, this.position.y + dy)
          );
        }
      }
    }

    class Sprite {
      constructor(
        displayName = "",
        avatar = "",
        color = "",
        zIndex = 0,
        layer = 0
      ) {
        registerProperties(
          this,
          "displayName",
          "avatar",
          "color",
          "zIndex",
          "layer"
        );
        Object.assign(this, { displayName, avatar, color, zIndex, layer });
      }
    }

    class GameObject {
      constructor(...components) {
        registerProperties(this, Transform.name, Sprite.name, "disposed");
        this.components = new Map([...components].map((c) => [c.name, c]));
        components.forEach((c) => this.add(c));
        this.children = new Set();
      }

      dispose() {
        this.children.forEach((c) => c.dispose());
        this.children.clear();
        this.components.clear();
        this.disposed = true;
      }

      addChild(obj) {
        const removeChild = () => {
          this.children.delete(obj);
          obj.off("disposed", removeChild);
        };
        this.children.add(obj);
        obj.parent = this;
        obj.on("disposed", removeChild);
      }

      getComponentsNames(component) {
        if (component.name) {
          return [component.name];
        }
        const names = [];
        component = Object.getPrototypeOf(component);
        while (component) {
          if (!component.constructor || component.constructor == Object) {
            break;
          }
          names.push(component.constructor.name);
          component = Object.getPrototypeOf(component);
        }
        return names;
      }

      add(component) {
        this.getComponentsNames(component).forEach((name) => {
          this.components.set(name, component);
          if (this.on) {
            registerProperties(this, name);
          }
          this[name] = component;
        });
        component.gameObject = this;
      }

      remove(componentName) {
        let component = this[componentName];
        if (!component) {
          return;
        }
        component.gameObject = undefined;
        this[component.name] = undefined;
        this.components.delete(componentName);
      }

      updateHard(t) {
        if (this.disposed) {
          return;
        }
        for (let [_, c] of this.components) {
          c?.updateHard?.(t);
        }
        this.children.forEach((c) => c.updateHard(t));
      }

      update(t) {
        if (this.disposed) {
          return;
        }
        for (let [_, c] of this.components) {
          c?.update?.(t);
        }
        this.children.forEach((c) => c.update(t));
      }
    }

    class Skill {
      constructor(displayName, subName, resources, info) {
        resources = createItemsModel(resources);
        registerProperties(
          this,
          "displayName",
          "subName",
          "resources",
          "cooldown",
          "remainCooldown",
          "danger",
          "last",
          "remainLast",
          "released",
          "releasedTime",
          "lastReleasedTime",
          "releaseEvent",
          "finishEvent",
          "cooldownEvent",
          "disabled"
        );
        Object.assign(this, info, { displayName, subName, resources });
      }

      updateCooldown(time) {
        if (this.remainCooldown === undefined) {
          return;
        }
        if (this.cooldown) {
          this.remainCooldown = Math.max(
            0,
            this.lastReleasedTime + this.cooldown - time
          );
          if (this.remainCooldown) {
            return;
          }
        }
        this.remainCooldown = undefined;
        this.cooldownEvent = {};
      }

      updateLast(time) {
        if (!this.released) {
          return;
        }
        if (this.releasedTime === undefined) {
          this.releasedTime = time;
          this.lastReleasedTime = time;
          this.remainCooldown = this.cooldown || 0;
          this.releaseEvent = {};
        }
        if (this.last) {
          this.remainLast = Math.max(0, this.last + this.releasedTime - time);
          if (this.remainLast) {
            return;
          }
        }
        this.remainLast = undefined;
        this.released = undefined;
        this.releasedTime = undefined;
        this.finishEvent = {};
      }

      update(time) {
        if (!this.unit) {
          return;
        }
        this.updateLast(time);
        this.updateCooldown(time);
      }

      release() {
        if (!this.unit || this.remainCooldown) {
          return;
        }
        const neededResources = (this.resources || []).filter(
          (i) => i.prop !== "time"
        );
        const unitsResources = (this.unit.manager || this.unit).resources || {};
        const moreResourceNames = [];
        for (const item of neededResources) {
          if (!item.value) {
            continue;
          }
          if (!(unitsResources[item.prop]?.value >= item.value)) {
            moreResourceNames.push(item.prop);
          }
        }
        if (moreResourceNames.length) {
          window.modal_.toast(
            `${moreResourceNames
              .map((name) => LanguagesInstance[name])
              .join("、")}${LanguagesInstance["notEnough"]}`
          );
          return;
        }
        for (const item of neededResources) {
          if (!item.value) {
            continue;
          }
          unitsResources[item.prop].value -= item.value;
        }
        this.released = true;
      }
    }

    class Skillable {
      constructor() {
        registerProperties(this, "skills");
        this.skills = [];
      }

      learnSkills(skills) {
        skills.forEach((s) => (s.unit = this));
        this.skills = Array.from(
          new Map(
            [...this.skills, ...skills].map((s) => [s.displayName, s])
          ).values()
        );
      }

      abandantSkills(skills) {
        const skillNames = new Set(skills.map((s) => s.displayName));
        this.skills = this.skills.filter((s) => !skillNames.has(s.displayName));
      }

      updateHard(time) {
        super.updateHard?.(time);
        for (const skill of this.skills) {
          skill.updateHard?.(time);
        }
      }

      update(time) {
        super.update?.(time);
        for (const skill of this.skills) {
          skill.update?.(time);
        }
      }
    }

    class Unit extends Skillable {
      constructor() {
        super();
        registerProperties(this, "life", "maxLife", "resources");
      }
    }

    class ActualUnit extends Unit {
      constructor(info, initPos) {
        super();
        Object.assign(this, info);
        registerProperties(this);
        this.maxLife = this.maxLife === undefined ? this.life : this.maxLife;
        this.Transform = new Transform(
          initPos?.x || 0,
          initPos?.y || 0,
          this.speed,
          this.scale
        );
        this.Sprite = new Sprite(this.displayName, this.avatar);
      }

      get gameObject() {
        return this._gameObject;
      }

      set gameObject(p) {
        if (this._gameObject) {
          throw "";
        }
        this._gameObject = p;
        this.getComponents().forEach((c) => p.add(c));
      }

      getComponents() {
        return [this.Transform, this.Sprite];
      }

      async update(t) {
        super.update(t);
        this.gameObject.Transform.speed = this.speed;
        if (!this.gameObject.children.size) {
          return;
        }
        /**@type {Buffer[]} */
        const buffers = Array.from(this.gameObject.children)
          .filter((c) => c.Buffer)
          .map((c) => c.Buffer);
        if (!buffers.length) {
          return;
        }
        let speed = this.speed;
        for (let buffer of buffers) {
          if (buffer.speed !== undefined) {
            speed *= buffer.speed || 0;
          }
        }
        this.gameObject.Transform.speed = speed;
      }
    }

    class Attacker extends ActualUnit {
      constructor(info, movingPath) {
        let { x, y } = movingPath[0];
        x += info.dx;
        y += info.dy;
        super(info, { x, y });
        this.movingPath = [...movingPath];
        this.targets = [...this.movingPath];
        this.updateTargetsLength();
        this.targets.shift();
      }

      updateTargetsLength() {
        let current = this.gameObject?.Transform?.target || this.targets[0];
        let targetsLength = 0;
        for (let i = 0; i < this.targets.length; i++) {
          let next = this.targets[i];
          targetsLength =
            targetsLength +
            (Math.abs(next.x - current.x) + Math.abs(next.y - current.y));
          current = next;
        }
        this.targetsLength = targetsLength;
      }

      get fromTarget() {
        return this.targetsLength + this.gameObject.Transform.fromTarget;
      }

      update(t) {
        super.update?.(t);
        const inTarget = !this.gameObject.Transform.fromTarget;
        if (!inTarget || !this.targets.length) {
          return;
        }
        const { x, y } = this.targets.shift();
        this.gameObject.Transform.setTarget(
          new Point(x + this.dx, y + this.dy)
        );
        this.updateTargetsLength();
      }
    }

    class Bullet {
      constructor(info, source, target, targetPosition) {
        registerProperties(this);
        Object.assign(this, info, { source, target, targetPosition });
      }

      async update(time) {
        this.gameObject.Transform.setTarget(
          this.targetPosition || this.target.Transform.position
        );
      }
    }

    class Defender extends ActualUnit {
      constructor(manager, info, initPos, strategies) {
        super(info, initPos);
        registerProperties(this, "strategies", "targetPosition");
        Object.assign(this, info);
        this.Sprite.layer = 1;
        /**@type {Unit} */
        this.manager = manager;
        this.attack = Object.values(info.attacks || {})[0];
        this.bullet = Object.values(this.attack.bullet)[0];
        this.filter = Object.values(this.attack.filter || [])[0];
        this.buffer = Object.values(this.attack.buffer || [])[0];
        this.splash = this.attack.splash;
        this.strategies = this.mergeStrategies(
          strategies,
          createItemsModel(info.strategies)
        );
        const rangeAttack = this.splash?.rangeAttack;
        const rangeAttackOnly = this.splash?.rangeAttack < 0;
        if (rangeAttackOnly) {
          for (let s of this.strategies) {
            if (s === this.strategies.terrain) {
              s.disabled = undefined;
            } else {
              s.value = undefined;
              s.disabled = true;
            }
          }
        } else if (!rangeAttack) {
          for (let s of this.strategies) {
            if (s === this.strategies.terrain) {
              s.value = undefined;
              s.disabled = true;
            } else {
              s.disabled = undefined;
            }
          }
        }
        if (rangeAttack) {
          if (this.strategies.terrain) {
            this.strategies.terrain.disabled = undefined;
            if (this.strategies.terrain.value) {
              const { x, y } = this.strategies.terrain.value;
              this.targetPosition = new Point(x, y);
            }
          }
        }
        this.updateGetOrder();
      }

      setTargetTerrain(terrain) {
        if (terrain.group !== "floor") {
          return;
        }
        const dist = this.Transform.position.dist(terrain);
        if (dist > this.attack.range) {
          return;
        }
        this.targetPosition = new Point(terrain.x, terrain.y);
        if (this.strategies.terrain.value) {
          this.strategies.terrain.value = this.targetPosition;
        } else {
          this.setStrategy(this.strategies.terrain, this.targetPosition);
        }
        return true;
      }

      mergeStrategies(s1, s2) {
        if (!s1) {
          return s2;
        }
        let s = s1.find((s) => s.value);
        s2.forEach((s) => (s.value = undefined));
        if (s2[s.prop]) {
          s2[s.prop].value = s.value;
        } else {
          s2[s.prop] = s;
        }
        return s2;
      }

      setStrategy(strategy, value) {
        this.strategies.forEach((s) => (s.value = undefined));
        strategy.value = value;
        this.updateGetOrder();
        if (!this.strategies.terrain?.value) {
          this.targetPosition = undefined;
        }
      }

      getOrderFunction() {
        if (this.strategies.life.value) {
          return ([obj]) => obj.Unit.life * this.strategies.life.value;
        }
        if (this.strategies.speed.value) {
          return ([obj]) => obj.Transform.speed * this.strategies.speed.value;
        }
        if (this.strategies.distance.value) {
          return ([obj, tmp]) => {
            if (tmp.distance === undefined) {
              tmp.distance = this.distanceFrom(obj);
            }
            return tmp.distance * this.strategies.distance.value;
          };
        }
        if (this.strategies.fromTarget.value) {
          return ([obj, tmp]) => {
            return obj.Attacker.fromTarget * this.strategies.fromTarget.value;
          };
        }
        return ([obj]) => 0;
      }

      updateGetOrder() {
        this.getOrder = this.getOrderFunction();
      }

      distanceFrom(i) {
        return i.Transform.position.dist(this.gameObject.Transform.position);
      }

      findTargets() {
        return GameEngine.Instance.gameObjects
          .filter((g) => !g.disposed && g.Attacker)
          .map((i) => [i, { distance: this.distanceFrom(i) }])
          .filter(([_, { distance }]) => distance <= this.attack.range)
          .sort((i, j) => this.getOrder(j) - this.getOrder(i));
      }

      attackTerrain() {
        if (!this.targetPosition) {
          return;
        }
        this.attackTargetOrPosition(undefined, this.targetPosition);
      }

      attackTargets() {
        const targets = this.findTargets()
          .slice(0, this.attack.multiTarget || 1)
          .map((i) => i[0]);
        targets.forEach((target) => this.attackTargetOrPosition(target));
      }

      attackTargetOrPosition(target, targetPosition) {
        const bullet = new Bullet(
          this.bullet,
          this.gameObject,
          target,
          targetPosition
        );
        const { x, y } = this.Transform.position;
        const bulletObj = new GameObject(
          bullet,
          new Transform(x, y, this.bullet.speed, this.bullet.scale),
          new Sprite(
            this.bullet.displayName,
            this.bullet.avatar,
            this.bullet.color,
            -1,
            1
          )
        );
        const onBulletArrive = () => {
          bulletObj.dispose();
          const attackEnemy = (enemy, splashAttack = false, ratio = 1) => {
            /**@type {Attacker} */
            const attacker = enemy.Attacker;
            if (!attacker) {
              return;
            }
            attacker.life -= Calculator.Instance.damage(this, attacker, ratio);
            if (!(attacker.life >= 0)) {
              enemy.dispose();
              for (let r of this.manager.resources || []) {
                r.value += Calculator.Instance.resource(
                  r.prop,
                  this.manager,
                  attacker
                );
              }
              return;
            }
            if (this.filter) {
              let filterObj = Array.from(enemy.children).find(
                (c) => c.Filter?.displayName === this.filter.displayName
              );
              if (!filterObj) {
                filterObj = new GameObject(
                  new Filter(this.filter),
                  new Transform(0, 0, 0, this.filter.scale || 1),
                  new Sprite(
                    this.filter.displayName,
                    this.filter.avatar,
                    this.filter.color
                  )
                );
                filterObj.Filter.last *= ratio;
                enemy.addChild(filterObj);
              } else {
                filterObj.Filter.last = this.filter.last * ratio;
              }
            }
            if (this.buffer) {
              let bufferObj = undefined; // Array.from(enemy.children).find(c => c.Buffer?.displayName === this.buffer.displayName)
              if (!bufferObj) {
                bufferObj = new GameObject(new Buffer(this.buffer));
                bufferObj.Buffer.last *= ratio;
                enemy.addChild(bufferObj);
              } else {
                bufferObj.Buffer.last = this.buffer.last * ratio;
              }
            }
          };
          if (this.splash && this.splash.ratio) {
            const { x, y } = bulletObj.Transform.position;
            const attackedUnits = new Set();
            if (target) {
              attackedUnits.add(target);
            }
            const getColor = (color, o) => {
              if (!color) {
                return;
              }
              if (color.length === 7) {
                return color + Math.floor(0xff * o).toString(16);
              }
              if (color.length === 9) {
                return (
                  color.slice(0, 7) +
                  Math.floor(Number.parseInt(color.slice(7), 16) * o).toString(
                    16
                  )
                );
              }
              return color;
            };
            const splashObj = new GameObject(
              new Transform(x, y, 0, this.splash.range),
              new Sprite(
                "",
                this.splash.avatar || "●",
                this.splash.color ||
                  getColor(this.filter?.color, 0.25) ||
                  "#ff000040"
              ),
              new Countdown({ last: this.splash.last || 0.01 })
            );
            const attack = (unit) => {
              if (attackedUnits.has(unit)) {
                return;
              }
              attackedUnits.add(unit);
              attackEnemy(unit, true, this.splash.ratio);
            };
            splashObj.Transform.on("inCollision", attack);
            GameEngine.Instance.addGameObjects([splashObj]);
          }
          if (target) {
            attackEnemy(target);
          }
        };
        if (target) {
          bulletObj.Transform.targetCollision = target;
          bulletObj.Transform.on("withinCollision", (withinCollision) => {
            if (withinCollision) {
              onBulletArrive();
            }
          });
          target.on("disposed", (disposed) => {
            if (disposed) {
              bulletObj.dispose();
            }
          });
        } else {
          bulletObj.Transform.setTarget(targetPosition);
          bulletObj.Transform.on("inTarget", (inTarget) => {
            if (inTarget) {
              onBulletArrive();
            }
          });
        }
        GameEngine.Instance.addGameObjects([bulletObj]);
      }

      update(time) {
        super.update?.(time);
        if (!this.attack) {
          return;
        }
        if (this.lastAttackTime) {
          let remain = this.lastAttackTime + (this.attack.cooldown || 0) - time;
          if (remain > 0) {
            return;
          }
        }
        this.lastAttackTime = time;
        if (this.strategies.terrain?.value) {
          this.attackTerrain();
        } else {
          this.attackTargets();
        }
      }
    }

    class Countdown {
      constructor(info) {
        registerProperties(this, "last");
        Object.assign(this, info);
      }

      update(t) {
        if (this.lastUpdateTime === undefined) {
          this.lastUpdateTime = t;
        }
        this.last -= t - this.lastUpdateTime;
        this.lastUpdateTime = t;
        if (this.last < 0) {
          this.gameObject.dispose();
        }
      }
    }

    class Filter extends Countdown {
      constructor(info) {
        super(info);
      }
    }

    class Buffer extends Countdown {
      constructor(info) {
        super(info);
      }
    }

    class AttackerManager {
      constructor({ startPositions, endPositions, onFinished }, sessionData) {
        registerProperties(
          this,
          "attackerWaves",
          "currentWave",
          "nextWave",
          "currentTime",
          "remainTime",
          "jumpTime",
          "displayName"
        );
        this.onFinished = onFinished;
        this.configManager = new UnitConfigManager();
        this.movingPaths = Array.from(
          { length: startPositions.length },
          (_, i) =>
            this.calculateAttackerMovingPath(
              GameEngine.Instance.terrains,
              startPositions[i],
              endPositions[i]
            )
        );
        /**@type {any[]}*/
        this.attackerWaves = sessionData.attackerWaves.map((w) => ({
          delay: w.delay,
          info: w,
          factory: this.createAttackerWaveFactory(w, sessionData.attackers),
        }));
        for (let i = 1; i < this.attackerWaves.length; i++) {
          this.attackerWaves[i].delay =
            this.attackerWaves[i - 1].delay + this.attackerWaves[i].info.delay;
        }
        this.aliveUnits = new Set();
        this.currentTime = 0;
        this.jumpTime = 0;
        this.remainTime = 0;
      }

      changeNextWave() {
        this.nextWave = this.attackerWaves.shift();
      }

      jumpToNextWave() {
        if (!this.nextWave) {
          return;
        }
        this.jumpTime += this.remainTime;
      }

      createAttackerWaveFactory(winfo) {
        const gfacs = [];
        for (let group of winfo.attackerGroups) {
          const teem = Object.values(group);
          const tfacs = [];
          gfacs.push(tfacs);
          for (let info of teem) {
            tfacs.push(this.createAttackerGroupFactory(info));
          }
        }
        return () => gfacs.map((tfacs) => tfacs.map((fac) => fac()).flat());
      }

      createAttackerGroupFactory(ginfo) {
        const getCount = this.configManager.getGetter(ginfo.count);
        const getters = Object.keys(ginfo)
          .filter((k) => k !== "count")
          .map((k) => [k, this.configManager.getGetter(ginfo[k])]);
        return () => {
          return Array.from({ length: Math.floor(getCount()) }, () =>
            Object.fromEntries(getters.map(([key, getter]) => [key, getter()]))
          );
        };
      }

      calculateAttackerMovingPath(terrains, source, target) {
        const graph = new astarG(
          terrains.map((col) => col.map((c) => (c.group === "floor" ? 1 : 0)))
        );
        const start = graph.grid[source.y][source.x];
        const end = graph.grid[target.y][target.x];
        const points = astar
          .search(graph, start, end)
          .map((r) => ({ x: r.y, y: r.x }));
        points.unshift({ x: source.x, y: source.y });
        const edges = [points[0]];
        let lastX = points[0].x;
        let lastY = points[0].y;
        let xd = undefined;
        let yd = undefined;
        for (let i = 1; i < points.length; i++) {
          edges[edges.length - 1] = points[i - 1];
          const { x, y } = points[i];
          const [dx, dy] = [x - lastX, y - lastY];
          lastX = x;
          lastY = y;
          if (dx === 0 && yd) {
            continue;
          }
          if (dy === 0 && xd) {
            continue;
          }
          if (dx === 0 && dy === 0) {
            continue;
          }
          edges.push(null);
          yd = dx === 0;
          xd = dy === 0;
        }
        edges[edges.length - 1] = points[points.length - 1];
        return edges;
      }

      update(time) {
        this.currentTime = time;
        if (!this.nextWave) {
          this.changeNextWave();
          if (!this.nextWave) {
            return;
          }
        }
        this.remainTime =
          this.nextWave.delay - this.currentTime - this.jumpTime;
        if (this.remainTime > 0) {
          return;
        }
        this.currentWave = this.nextWave;
        this.changeNextWave();
        const teems = this.currentWave.factory();
        const newUnits = teems
          .map((teem, teemId) =>
            teem.map(
              (i) =>
                new GameObject(
                  new Attacker(
                    {
                      ...i,
                      dx: (Math.random() - 0.5) / 2,
                      dy: (Math.random() - 0.5) / 2,
                    },
                    this.movingPaths[teemId]
                  )
                )
            )
          )
          .flat();
        newUnits.forEach((u) => {
          this.aliveUnits.add(u);
          const removeU = () => {
            this.aliveUnits.delete(u);
            u.on("disposed", removeU);
            if (!this.nextWave && !this.aliveUnits.size) {
              this.onFinished(1);
            }
          };
          u.on("disposed", removeU);
        });
        GameEngine.Instance.addGameObjects(newUnits);
      }
    }

    const createItemsModel = (itemObj) => {
      const model = [];
      for (let p in itemObj) {
        const item = {};
        registerProperties(item, "value", "disabled");
        item.prop = p;
        item.value = itemObj[p];
        model.push(item);
        model[p] = item;
      }
      return model;
    };

    class DefenderManager extends Unit {
      constructor({ onFinished }, sessionData) {
        super();
        registerProperties(this, "defeners", "defenderTypes");
        this.configManager = new UnitConfigManager();
        this.maxLife = sessionData.config.life;
        this.life = this.maxLife;
        this.resources = createItemsModel(sessionData.config.initResources);
        this.money = sessionData.config.initMoney;
        this.recycleRatio =
          sessionData.config.recycleRatio !== undefined
            ? sessionData.config.recycleRatio
            : 0;
        this.updateRatio =
          sessionData.config.updateRatio !== undefined
            ? sessionData.config.updateRatio
            : 1;
        const targets = sessionData.ends.map(
          ({ x, y }) =>
            new GameObject(new Transform(x, y), {
              name: "Target",
            })
        );
        targets.forEach((target) => {
          target.Transform.on("inCollision", (unit) => {
            let attacker = unit.Attacker;
            if (!attacker) {
              return;
            }
            if (attacker.bombDamage) {
              this.life -= attacker.bombDamage;
              if (this.life <= 0) {
                onFinished(-1);
              }
            }
            if (attacker.diedMoney) {
              this.money += attacker.diedMoney;
            }
            unit.dispose();
          });
        });
        GameEngine.Instance.addGameObjects(targets);
        for (let { x, y, defender } of sessionData.initDefenders) {
          this.createDefender(Object.values(defender)[0], undefined, { x, y });
        }
        const skills = Object.values(sessionData.defenderTypes).map((t) =>
          this.skillFromType(t)
        );
        this.learnSkills(skills);
      }

      skillFromType(type, from) {
        const reduceResouces = (resource, fromResource) => {
          if (!fromResource) {
            return resource;
          }
          const r = {};
          for (let p of new Set([
            ...Object.keys(resource),
            ...Object.keys(fromResource),
          ])) {
            r[p] =
              Math.max(0, (resource[p] || 0) - (fromResource[p] || 0)) *
              this.updateRatio;
          }
          return r;
        };
        const skill = new Skill(
          type.avatar || type.displayName,
          LanguagesInstance[from ? "upgrade" : "build"],
          reduceResouces(type.buildResources, from?.buildResources),
          {
            cooldown: type.buildResources["time"],
          }
        );
        skill.on("releaseEvent", () => {
          skill.tmp = {
            position: from?.Transform.position || app.selectedPosition,
          };
        });
        skill.on("cooldownEvent", () => {
          const position = skill.tmp.position;
          skill.tmp = undefined;
          this.createDefender(type, from, position);
        });
        return skill;
      }

      createDefender(type, from, position) {
        type = this.configManager.getGetter(type)();
        const defender = new Defender(
          this,
          type,
          position,
          from?.gameObject.Defender.strategies
        );
        const skills = [];
        if (type.upgrades) {
          skills.push(
            ...Object.values(type.upgrades).map((t) =>
              this.skillFromType(t, defender)
            )
          );
        }
        const getRecycleResources = (resource) => {
          if (!resource || !this.recycleRatio) {
            return;
          }
          return Object.fromEntries(
            Object.entries(resource)
              .filter(([prop]) => prop !== "time")
              .map(([prop, value]) => [prop, -value * this.recycleRatio])
          );
        };
        const recycleSkill = new Skill(
          LanguagesInstance.recycle,
          undefined,
          getRecycleResources(type.buildResources),
          {
            danger: true,
          }
        );
        recycleSkill.on("releaseEvent", () => {
          defender.gameObject.dispose();
          if (app.selectedUnit === defender.gameObject) {
            app.clearSelectedUnit();
          }
        });
        skills.push(recycleSkill);
        skills.forEach((skill) => {
          skill.on("releaseEvent", () => {
            skills
              .filter((s) => s !== skill)
              .forEach((skill) => (skill.disabled = true));
          });
        });
        defender.learnSkills(skills);
        GameEngine.Instance.addGameObjects([new GameObject(defender)]);
        if (
          app.selectedPosition &&
          position.x === app.selectedPosition.x &&
          position.y === app.selectedPosition.y
        ) {
          app.selectUnit(defender.gameObject);
        }
        if (from) {
          from.gameObject.dispose();
        }
      }
    }

    class GameEngine {
      constructor(fps) {
        registerProperties(
          this,
          "started",
          "paused",
          "time",
          "gameObjects",
          "terrains"
        );
        this.clock = new Clock(fps);
        this.gameObjects = [];
        GameEngine.Instance = this;
      }

      addGameObjects(objs) {
        this.gameObjects = [
          ...this.gameObjects.filter((g) => !g.disposed),
          ...objs,
        ];
        objs.forEach((obj) => {
          const handlers = [];
          const offAll = () => {
            handlers.forEach(([o, p, h]) => o.off(p, h));
          };
          handlers.push([obj, "disposed", offAll]);

          const onMove = () => {
            if (!obj.Transform?.scale || !obj.Transform.position) {
              return;
            }
            const withinCollision = (s, t) =>
              t.Transform?.position &&
              s.Transform?.position &&
              t.Transform.position.dist(s.Transform.position) <
                ((s.Transform.scale || 0) + (t.Transform.scale || 0)) / 2;
            if (obj.Transform.targetCollision?.Transform) {
              obj.Transform.withinCollision = withinCollision(
                obj,
                obj.Transform.targetCollision
              );
            }
            let targets = this.gameObjects.filter((g) => g.Transform?.scale);
            if (
              !obj.Transform.hasOn("inCollision") &&
              !obj.Transform.hasOn("outCollision")
            ) {
              targets = targets.filter(
                (g) =>
                  g.Transform.hasOn("inCollision") ||
                  g.Transform.hasOn("outCollision")
              );
            }
            if (!targets.length) {
              return;
            }
            let outCollisions = new Set(
              targets.filter((t) => !withinCollision(obj, t))
            );
            targets = targets.filter((t) => !outCollisions.has(t));
            outCollisions = (obj.collisions || []).filter((t) =>
              outCollisions.has(t)
            );
            obj.collisions = targets;
            targets.forEach((t) => {
              t.Transform.inCollision = obj;
              obj.Transform.inCollision = t;
              t.collisions = [...(t.collisions || []), obj];
            });
            outCollisions.forEach((t) => {
              t.Transform.collisions = (t.Transform.collisions || []).filter(
                (s) => s !== obj
              );
              t.Transform.outCollision = obj;
              obj.Transform.outCollision = t;
            });
          };
          if (obj[Transform.name]) {
            handlers.push([obj[Transform.name], "position", onMove]);
          }

          handlers.forEach(([o, p, h]) => o.on(p, h));
        });
      }

      async start() {
        if (this.started) {
          return this.started;
        }
        this.time = 0;
        this.started = new Promise((resolve) => {
          this.resolveStarted = resolve;
        });
        await this.gameLoop();
        this.started = undefined;
        const resolve = this.resolveStarted;
        this.resolveStarted = undefined;
        resolve();
      }

      async stop() {
        if (!this.started) {
          return;
        }
        let started = this.started;
        this.started = undefined;
        return started;
      }
      pause() {
        if (!this.started) {
          return;
        }
        if (this.paused) {
          return;
        }
        this.paused = true;
        this.clock.pause();
      }

      resume() {
        if (!this.started) {
          return;
        }
        if (!this.paused) {
          return;
        }
        this.paused = false;
        this.clock.resume();
      }

      drawObjects() {
        /**@type {HTMLCanvasElement} */
        const canvases = this.objectsCanvases;

        const contexts = canvases.map((canvas) => {
          canvas.width = Number.parseFloat(
            window.getComputedStyle(canvas)["width"]
          );
          canvas.height = Number.parseFloat(
            window.getComputedStyle(canvas)["height"]
          );
          const context = canvas.getContext("2d");
          context.clearRect(0, 0, canvas.width, canvas.height);
          context.textAlign = "center";
          context.textBaseline = "middle";
          return context;
        });
        const objects = this.gameObjects
          .filter(
            (object) =>
              !object.disposed &&
              object.Transform &&
              object.Transform.position &&
              object.Sprite?.avatar
          )
          .sort((i, j) => i.Sprite.zIndex - j.Sprite.zIndex);
        const cellWidth = canvases[0].width / this.worldWidth;
        const cellHeight = canvases[0].width / this.worldHeight;
        const cellSize = Math.min(cellWidth, cellHeight);

        const drawObject = (obj, dx = 0, dy = 0, dscale = 1, layer = 0) => {
          for (let c of obj.children) {
            if (c.Transform && c.Sprite) {
              drawObject(
                c,
                obj.Transform.position.x,
                obj.Transform.position.y,
                obj.Transform.scale,
                obj.Sprite.layer || layer
              );
            }
          }
          const context = contexts[obj.Sprite.layer || layer];
          let { x, y } = obj.Transform.position;
          let scale = obj.Transform.scale;
          x += dx;
          y += dy;
          scale *= dscale;
          let avatar = obj.Sprite.avatar;
          x = (x + 0.5) * cellWidth;
          y = (y + 0.5) * cellHeight;
          let size = 0.8 * cellSize * scale;
          let fontSize = 32;
          context.font = `${fontSize.toFixed(0)}px Arial`;
          const metrics = context.measureText(avatar);
          fontSize *= size / metrics.width;
          context.fillStyle = obj.Sprite.color || "";
          context.font = `${fontSize.toFixed(0)}px Arial`;
          context.fillText(avatar, x, y);
        };
        for (const obj of objects) {
          drawObject(obj);
        }
      }

      async updateHard() {
        this.time = this.clock.tickTime;
        for (let obj of this.gameObjects) {
          if (obj.disposed) {
            continue;
          }
          obj?.updateHard(this.time);
        }
      }

      async update() {
        let time = this.clock.tickTime;
        for (let obj of this.gameObjects) {
          if (obj.disposed) {
            continue;
          }
          obj?.update(time);
        }
      }

      async loopHard() {
        while (true) {
          if (!this.started || this.finished) {
            break;
          }
          await this.clock.wait(1);
          await this.updateHard();
          if (this.objectsCanvases.length) {
            this.drawObjects();
          }
        }
      }

      async loopEasy() {
        const tick = 10;
        while (true) {
          if (!this.started || this.finished) {
            break;
          }
          await this.clock.wait(tick);
          if (this.loopingEasy) {
            continue;
          }
          this.loopingEasy = true;
          this.update().then(() => {
            this.loopingEasy = undefined;
          });
        }
      }

      async gameLoop() {
        this.clock.start();
        await Promise.all([this.loopHard(), this.loopEasy()]);
        this.clock.stop();
      }
    }

    /**@type {GameEngine} */
    GameEngine.Instance = undefined;
    GameEngine.create = (...args) => {
      GameEngine.Instance = new GameEngine(...args);
      return GameEngine.Instance;
    };

    class Calculator {
      damage(source, target, ratio = 1) {
        return (source.attack.damage || 0) * ratio;
      }

      resource(type, source, target) {
        return target.diedResources?.[type] || 0;
      }
    }

    /**@type {Calculator} */
    Calculator.Instance = undefined;
    Calculator.create = (...args) => {
      Calculator.Instance = new Calculator(...args);
      return Calculator.Instance;
    };
  </script>
  <template id="app-main" view-model="App">
    <div class="app">
      <style if.="session" inner-html$.="themeStr"></style>
      <img class="bg" if.="theme?.bgImg" src.="theme.bgImg" />
      <div class="menu top">
        <div if.="defenderManager && attackerManager" class="status">
          <div>
            <span class="prop">生命值</span>
            <!-- <progress class="value" max.="defenderManager.maxLife"
            value.="defenderManager.life"></progress> -->
            <span
              class="value"
              inner-text$.="defenderManager.DefenderManager.life.toFixed(0)"
            ></span>
          </div>
          <div for.="resource of defenderManager.DefenderManager.resources">
            <span class="prop" inner-text$.="languages[resource.prop]"></span>
            <span class="value" inner-text$.="resource.value.toFixed(0)"></span>
          </div>
          <div if.="attackerManager.AttackerManager.nextWave">
            <span class="prop">下一波</span>
            <span class="value">
              <span
                inner-text$.="attackerManager.AttackerManager.remainTime.toFixed(0)"
              ></span>
              <span
                class="button"
                onclick.="attackerManager.AttackerManager.jumpToNextWave()"
                >▶️</span
              >
            </span>
          </div>
        </div>
        <div if.="session && engine" class="info">
          <div
            class="name-end"
            inner-text$.="storyName||''"
            onclick.="selectStory()"
          ></div>
          <div class="button" onclick.="restartSession()">🔄</div>
          <div class="button" if.="engine.paused" onclick.="engine.resume()">
            ▶️
          </div>
          <div class="button" if.="!engine.paused" onclick.="engine.pause()">
            ⏸
          </div>
          <div class="button" onclick.="shutdown()">⏹</div>
          <div
            class="name-start"
            inner-text$.="sessionName||''"
            onclick.="selectSession()"
          ></div>
        </div>
      </div>
      <div class="panel">
        <div class="session" if.="session">
          <div class="layer floor-layer">
            <div for.="col of engine.terrains">
              <div
                for.="t of col"
                class="terrain-wraper"
                onclick.="selectTerrain(t)"
              >
                <div if.="t.group!=='floor'" class="empty"></div>
                <div if.="t.group==='floor'" class="terrain floor">
                  <div class.="'type type-'+t.type"></div>
                  <div class="entrance start" if.="t.startPosition">○</div>
                  <div class="entrance end" if.="t.endPosition">◎</div>
                </div>
              </div>
            </div>
          </div>
          <div class="layer object-layer" if.="engine">
            <canvas class="object objectsCanvas" id="objectsCanvas0"></canvas>
          </div>
          <div class="layer wall-layer">
            <div for.="col of engine.terrains">
              <div
                for.="t of col"
                class="terrain-wraper"
                onclick.="selectTerrain(t)"
              >
                <div if.="t.group!=='wall'" class="empty"></div>
                <div if.="t.group==='wall'" class="terrain wall">
                  <div class="wall"></div>
                  <div class.="'type type-'+t.type"></div>
                  <!-- <span inner-text$.="t.type"></span> -->
                </div>
              </div>
            </div>
          </div>
          <div class="layer object-layer" if.="engine">
            <!-- <div for.="object of engine.gameObjects"
            if.="!object.disposed && object.Transform && object.Transform.position && !object.Transform.speed" class="object"
            onclick.="selectUnit(object)" style-left$.="100*object.Transform.position.x/engine.worldWidth+'%'"
            style-top$.="100*object.Transform.position.y/engine.worldHeight+'%'" style-width$.="100/engine.worldWidth+'%'"
            style-height$.="100/engine.worldHeight+'%'">
            <div if.="object.Sprite" class="avatar" style---scale$.="object.Transform.scale">
              <span inner-text$.="object.Sprite.avatar"></span>
            </div>
          </div> -->
            <div
              if.="selectedPosition"
              class="object selected-position"
              style-left$.="100*selectedPosition.x/engine.worldWidth+'%'"
              style-top$.="100*selectedPosition.y/engine.worldHeight+'%'"
              style-width$.="100/engine.worldWidth+'%'"
              style-height$.="100/engine.worldHeight+'%'"
            >
              <div
                if.="selectedUnitAttackRange"
                class="attack-range"
                style---scale$.="selectedUnitAttackRange*2"
              ></div>
            </div>
            <div
              if.="selectedUnit?.Defender?.targetPosition"
              class="object selected-position target-position"
              style-left$.="100*selectedUnit.Defender.targetPosition.x/engine.worldWidth+'%'"
              style-top$.="100*selectedUnit.Defender.targetPosition.y/engine.worldHeight+'%'"
              style-width$.="100/engine.worldWidth+'%'"
              style-height$.="100/engine.worldHeight+'%'"
            ></div>
            <canvas class="object objectsCanvas" id="objectsCanvas1"></canvas>
          </div>
        </div>
      </div>
      <div class="menu bottom">
        <div if.="selectedUnit">
          <div class="unit-info">
            <div class="unit-title">
              <span
                if.="selectedUnit.Sprite.avatar"
                class="avatar"
                inner-text$.="selectedUnit.Sprite.avatar"
              ></span>
              <span
                if.="!selectedUnit.Sprite.avatar"
                inner-text$.="selectedUnit.Sprite.displayName"
              ></span>
            </div>
            <div class="unit-detail">
              <div if.="selectedUnit.Skillable" class="unit-skills">
                <div
                  for.="skill of selectedUnit.Skillable.skills"
                  class-hidden.="skill.disabled"
                  class-danger.="skill.danger"
                  class="unit-skill status-indicator-wraper"
                  onclick.="skill.release()"
                >
                  <div class="status-indicator">
                    <div
                      if.="skill.last"
                      style---total$.="skill.last || 0"
                      style---current$.="skill.remainLast || 0"
                      class="top-indicator"
                    >
                      <div></div>
                      <div></div>
                    </div>
                    <div
                      style---total$.="skill.cooldown || 1"
                      style---current$.="skill.remainCooldown || 0"
                      class="middle-indicator"
                    >
                      <div></div>
                      <div></div>
                    </div>
                    <div
                      if.="skill.last"
                      style---total$.="skill.last || 0"
                      style---current$.="skill.remainLast || 0"
                      class="top-indicator"
                    >
                      <div></div>
                      <div></div>
                    </div>
                  </div>
                  <span if.="skill.subName" inner-text$.="skill.subName"></span>
                  <span inner-text$.="skill.displayName" class="value"></span>
                  <span for.="resource of skill.resources" if.="resource.value"
                    ><span
                      class="prop"
                      inner-text$.="languages[resource.prop]"
                    ></span>
                    <span class="value">
                      <span if.="resource.value&lt;0">+</span>
                      <span
                        inner-text$.="Math.abs(resource.value).toFixed(0)"
                      ></span>
                    </span>
                  </span>
                </div>
              </div>
              <div if.="selectedUnit?.Defender" class="unit-strategies">
                <div for.="strategy of selectedUnit.Defender.strategies">
                  <div
                    if.="!strategy.disabled&&strategy.prop!=='terrain'"
                    class="unit-strategy"
                  >
                    <span
                      class="prop"
                      inner-text$.="languages[strategy.prop]"
                    ></span>
                    <span
                      onclick.="selectedUnit.Defender.setStrategy(strategy,-1)"
                      class="prop button"
                      class-highlight.="strategy.value===-1"
                      inner-text$.="languages[strategy.prop+'-1']"
                    ></span>
                    <span
                      onclick.="selectedUnit.Defender.setStrategy(strategy,1)"
                      class="prop button"
                      class-highlight.="strategy.value===1"
                      inner-text$.="languages[strategy.prop+'+1']"
                    ></span>
                  </div>
                  <div
                    if.="!strategy.disabled&&strategy.prop==='terrain'"
                    class="unit-strategy"
                    onclick.="selectTerrainFor=(t)=>selectedUnit.Defender.setTargetTerrain(t)"
                  >
                    <span
                      class="prop button"
                      class-highlight.="strategy.value"
                      inner-text$.="languages[strategy.prop]"
                    ></span>
                    <span
                      class="prop button"
                      class-highlight.="selectTerrainFor"
                    >
                      <span
                        if.="!selectedUnit.Defender.targetPosition"
                        inner-text$.="languages.select"
                      ></span>
                      <span
                        if.="selectedUnit.Defender.targetPosition"
                        inner-text$.="selectedUnit.Defender.targetPosition.x+','+selectedUnit.Defender.targetPosition.y"
                      ></span>
                    </span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <modal-panel id="modal"></modal-panel>
    <style>
      :host {
        display: block;
      }

      .app {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      .app > * {
        min-width: 10px;
        min-height: 10px;
      }

      .bg {
        object-fit: cover;
        filter: blur(10px);
        opacity: 0.8;
        width: 100%;
        height: 100%;
        position: absolute;
        pointer-events: none;
        z-index: -1;
      }

      .menu {
        /* background: red; */
        flex: 1;
      }

      .menu.top {
        /* margin-top: 60px; */
      }

      .menu.bottom {
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
      }

      .menu.bottom > div {
        background: #fffa;
        padding-bottom: 20px;
      }

      .unit-info {
      }

      .status {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        background: #fffa;
        padding: 50px 0 10px 0;
      }

      .status > * {
        display: flex;
        align-items: center;
        margin: 5px 10px;
        opacity: 0.6;
        font-size: small;
      }

      .status .prop {
        margin: 0 10px;
        font-weight: bold;
      }

      .status .value {
        flex: 1;
        background: #0002;
        padding: 2px 10px;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .status .button {
        margin: 0 10px;
      }

      .info {
        font-weight: bold;
        justify-content: center;
        display: flex;
        align-items: center;
        opacity: 0.6;
        margin: 10px 0 0 0;
      }

      .info .name-end {
        flex: 1;
        text-align: end;
      }

      .info .name-start {
        flex: 1;
        text-align: start;
      }

      .info .button {
        font-size: 2em;
        margin: 0 5px;
      }

      .panel {
        /* background: green; */
        height: 100vw;
        position: relative;
        transform: scale(0.9);
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 3px 3px 3px black, -1px -1px 1px #0004;
      }

      .layer {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
        position: absolute;
        pointer-events: none;
      }

      .bg,
      .layer.floor-layer {
        background: var(--fbg);
        background-color: var(--fbgColor);
        background-size: var(--fbgSize);
      }

      .layer.wall-layer {
        filter: drop-shadow(3px 3px 3px black) drop-shadow(-1px -1px 1px #0004);
      }

      .layer > * {
        display: flex;
        flex-direction: row;
        flex: 1;
      }

      .layer > * > * {
        flex: 1;
      }

      .object {
        position: absolute;
        /* left: var(--left);
      top: var(--top);
      width: var(--width);
      height: var(--height); */
        font-size: min(3vh, 1.7vw);
        pointer-events: all;
      }

      .objectsCanvas {
        width: 100%;
        height: 100%;
        pointer-events: none;
        filter: drop-shadow(1px 1px 2px black);
      }

      .object > .avatar {
        display: flex;
        width: 100%;
        height: 100%;
        justify-content: center;
        align-items: center;
        transform: scale(var(--scale));
        font-size: 4.8em;
        filter: drop-shadow(1px 1px 2px black);
      }

      .selected-position {
        border: 2px solid;
        color: var(--bg);
        box-sizing: border-box;
        pointer-events: none;
        opacity: 0.5;
      }

      .target-position {
        border-radius: 25%;
      }

      .attack-range {
        background: var(--3-bg);
        border-radius: 50%;
        transform: scale(var(--scale));
        opacity: 0.25;
        pointer-events: none;
      }

      .terrain-wraper {
        position: relative;
        overflow: hidden;
      }

      .terrain {
        pointer-events: all;
      }

      .terrain > * {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      .terrain > .wall {
        background: linear-gradient(
              135deg,
              var(--wall-bg2) 25%,
              transparent 25%
            ) -4px 0/ 8px 8px,
          linear-gradient(225deg, var(--wall-bg1) 25%, transparent 25%) -4px 0/
            8px 8px,
          linear-gradient(315deg, var(--wall-bg2) 25%, transparent 25%) 0px 0/ 8px
            8px,
          linear-gradient(45deg, var(--wall-bg1) 25%, var(--wall-bg4) 25%) 0px 0/
            8px 8px;
        /* opacity: 0.6; */
      }

      .terrain.floor > .type {
        opacity: 0.5;
      }

      .entrance {
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.25em;
        top: 10%;
        left: 10%;
        width: 80%;
        height: 80%;
        border-radius: 25%;
        color: transparent;
      }

      .start {
        box-shadow: 1px 1px 3px #000 inset;
      }

      .end {
        box-shadow: 1px 1px 3px #000;
      }

      .terrain.wall > .type {
        opacity: 0.5;
      }

      .empty {
        opacity: 0;
        pointer-events: none;
      }

      .unit-info {
        display: flex;
        opacity: 0.8;
      }

      .unit-title {
        margin: 10px;
        height: 4em;
        width: 4em;
        /* background: var(--fg);
      color: var(--bg); */
        background: #0002;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        opacity: 0.8;
        text-align: center;
        padding: 5px;
        box-sizing: border-box;
        font-size: small;
      }

      .unit-title .avatar {
        font-size: 3em;
      }

      .unit-detail {
        display: flex;
        flex: 1;
        flex-direction: column;
        margin: 10px 10px 10px 0;
      }

      .unit-strategies {
        flex: 1;
        display: flex;
        flex-wrap: wrap;
      }

      .unit-strategy {
        background: var(--4-bg);
        color: var(--4-fg);
        padding: 2px 10px;
        border-radius: 5px;
        font-size: small;
        margin: 2px;
      }

      .unit-strategy .prop {
      }

      .unit-strategy .value {
      }

      .unit-strategy .button {
        opacity: 0.5;
      }

      .unit-strategy .button.highlight {
        opacity: unset;
        background: var(--4-fg);
        color: var(--4-bg);
      }

      .unit-skills {
        flex: 1;
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-start;
        align-items: flex-start;
      }

      .unit-skill {
        color: var(--1-fg);
        padding: 2px 5px;
        border-radius: 5px;
        font-size: small;
        margin: 2px;
      }

      .unit-skill .prop {
      }

      .unit-skill .value {
        background: var(--1-fg);
        color: var(--1-bg);
        padding: 0 2px;
        margin: 0 2px;
        border-radius: 5px;
      }

      .status-indicator-wraper {
        position: relative;
        overflow: hidden;
      }

      .status-indicator {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        z-index: -1;
        flex-direction: column;
      }

      .status-indicator > * {
        flex: 1;
        width: 100%;
        display: flex;
      }

      .status-indicator > .middle-indicator {
        flex: 8;
      }

      .status-indicator > * > * {
        height: 100%;
        transition: flex 0.1s linear;
      }

      .top-indicator > *:nth-child(1) {
        background: var(--bg1);
        flex: var(--current);
      }

      .top-indicator > *:nth-child(2) {
        background: var(--bg2);
        opacity: 0.3;
        flex: calc(var(--total) - var(--current));
      }

      .middle-indicator > *:nth-child(1) {
        background: var(--bg1);
        flex: calc(var(--total) - var(--current));
      }

      .middle-indicator > *:nth-child(2) {
        background: var(--bg2);
        opacity: 0.3;
        flex: var(--current);
      }

      .top-indicator {
        --bg1: var(--3-bg);
        --bg2: #000;
      }

      .middle-indicator {
        --bg1: var(--1-bg);
        --bg2: var(--1-bg);
      }

      .danger .middle-indicator {
        --bg1: var(--3-bg);
        --bg2: var(--3-bg);
      }

      .danger.unit-skill .value {
        background: var(--3-fg);
        color: var(--3-bg);
      }

      @media (orientation: landscape) {
        .app {
          flex-direction: row-reverse;
        }

        .panel {
          width: 100vh;
          height: unset;
        }
      }

      .hidden {
        display: none !important;
      }
    </style>
  </template>
  <script>
    window.appData = window.appData || {
      stories: {
        __base: {
          "+config": {
            themes: {
              __base: {
                "0-bg": "gold",
                "0-fg": "black",
                "1-bg": "green",
                "1-fg": "white",
                "2-bg": "blue",
                "2-fg": "white",
                "3-bg": "red",
                "3-fg": "white",
                "4-bg": "brown",
                "4-fg": "white",
                "wall-bg1": "#f19f41",
                "wall-bg2": "#f19f4155",
                "wall-bg3": "#f19f4177",
                "wall-bg4": "#cf7e22",
                fg: "black",
                bg: "white",
                fbg:
                  "repeating-radial-gradient(circle at 0.5em 0.05em, transparent, transparent 0.2em, #EDE8D5 0.21em, #EDE8D5 0.3em, transparent 0.31em), repeating-radial-gradient(circle at 0.5em 0.95em, transparent, transparent 0.2em, #EDE8D5 0.21em, #EDE8D5 0.3em, transparent 0.31em)",
                fbgColor: "#fff",
                fbgSize: "1em 1em",
                bgImg:
                  "data:image/png;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHCBUVFRgVFRUYGRgaGBgaGRgcGhocGBgYGhgZGhgYGBgcIS4lHB4rIRgYJjgmKzAxNTU1GiQ7QDs0Py40NTEBDAwMEA8QHxISHjQrJSs0NDQ0NjQ0NDQ1NDQ0NDQ0NDQ0NDQ0NDQ2NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NP/AABEIAKgBKwMBIgACEQEDEQH/xAAcAAABBQEBAQAAAAAAAAAAAAAFAAIDBAYBBwj/xAA6EAACAQIFAgQFAgUDAwUAAAABAhEAAwQFEiExQVEGImFxEzKBkaEUsUJSwdHwB+HxYpKyFRYjQ3L/xAAZAQADAQEBAAAAAAAAAAAAAAABAgMABAX/xAAqEQADAAIBAwQBBAIDAAAAAAAAAQIDESEEEjETIkFRkQUUYaFxgSMy8P/aAAwDAQACEQMRAD8A8oApwrgp6iaiwCFavwx4RbGIzh9JHEjY/WingvJMLiLbW7zrrJ8o4YV6X4fyBMKmhCSCZ3qdUNM7PMPEHgJ7FoOhLt/EB/SjPg/wdCa8QisGEgEeYe9enphtXSrAwApkqaDqUzK5fkNiwxa2gUnmiIwxPSjAwImrK2FFPMP5C2jPnAN2qvcwbDpWluuBxVZjNP2pAMy9qoHt1p/0itzXHyhTxTJMVmWt4UuwVRua0Vnw1b0+YkmiWCy9E3A371cpu5g0jKX/AAmS3lfy+vNE8qyBLJ1fM3c9PairXIqJ71Z2/GzdqLBNQNdqFrlNRCaAdEpvmomusanSx3rrWK2zGd8ToGw76o23B9aweW5U999CD3PQV6bm2VfHtlJg8j39areF8obDhtcS1dOPL2Q9eSNx3V/AFt+AfL5rnm9BtQvGeCryyVIb969LZ6ru9CeoteWZ4pZ4vew7IxVhBHIpmmvSPEPh4X/Omz/hqw+Ny17Rh1I/au3Hmml/JCocsH6aWmp9NLTVdk9EGmlpqfTTlsk8Cts2itppaau/pH7Go2tEcit3G0VtNLTU+mlprbNorMlQulX9NRvboMKBNxKg+HRS5bqr8OosdBGx/p38R9SXR8I7g8mq2UeCsQuNVGQlFeS5HlK1sf8AT3AW086YkupGyE8fSvRFiK8N/wCTvS2YbG+AUbEpiLT/AAwCCyjrHatyiAUjXJpVSQ2idWArjXKhLU3XT+qgdozFY3REhiDqJgTpVVJLEDeJ0jb+YVDhM3t3iyoxJXTq8rCNUxuRE7Haqyul7EXLborC3bT5gGGq4zltj2FtPzSPhjDa2uAFWfTqCkBfKIACxA+nU0KrLvc6a+nx/YUp+dhT4ZNPGG9aG4bJrVtmZGuDUFBAdgp0zBgdd6vWwF4LfV2b/wAiaeaeuV/exWl8DhYM+lWSQKiW6Kje5NU7kDRKb1Ne5VYvXNY70Nh0OZqjM07WO9dV1FEw61amriJFVP1yCo2zEd6OhQgXFc+IKGjFg8GmPiR3rGCTXAKr3b9U/j9Zpnx1PUUxiybtNFyoNY700v60TBBSKhxmCt3RDqCKqrfHennEetFbXgD0yW1lGGAgW1+1Acf4RVmJttAPQ9KM/qfWnpifWnm7nlMSpl8GIbIXR9LD69DRez4bbyvbdFhiGV0Lo4AKmYYEENuIPQz6HcTjFVWdwIUEz7UNyjMy+HRiwJbWxMR8zseJ9aZ5Xk9oFHZ7iVbAUAOEJjcopUE9SAWMD0odmOWI4lRvVy7dmuW7sdapO5EppmUuZU4/hqu+DYcitrdxA9KqvpPaqrIyblGQNkjpUbJWmxVtI6UGuW96pNbFc6BVy3Vb4VFrtuq/w6VhRhMoxTo6xda3v8wnavojwy04ZCbnxNvn715n/pv4fsYuy4vJOlvK3Fer5XlyYe2LdsQq8V4FcnfKLcVyK7NcNJ2lBpFU8zxYtW2c9OB3boP6+wNXaxXjLMZDKD5Uke7dT9OPv3quKO6kieS+2dlTwBi2uYnFFmJJW1yZ4Z/71uyTXlv+mOKjFOh/+y23/crqR+C/2r1I1bqY7cnH0hcL3Iwk0xiakNMNSSZQjLHvUbMe9SsKjYUyQCJie9QtNTsKZFUSFZBpNW7Ng8sTXUApzvVEKP8AhrUV/CqRTdfrSN71qiFYNfCuDsTUT4R+pNFGcd6jd/WmTEaBTWnAiTFVirDqaMO4qlcImqSxWUzccfxGk+JciNRqdwKhKUy0LyQi4w6mnfqX704pTClPwAX6lu9OGNccGmaKWitwDbKuc45zaYMTEcd+w+8VFk19vgWwDwsfYkf0qrnzjQV9QKmyCDZAH8LMD7zq/ZhXHhtVmp/Hj8Ho58bnpYXz5YQ+O/el8Vu9PFurtnKLriQhrsbS8nnJNg43G70viN3q7fy24vzKarFKyafgzTRCxJqPRVhyAVBO7GB6mCY+wNCcRmAQ30JhgNSevlCmPYrP1pbyzPkyl0OzVylp3HIBiku4BHBAI9iJqr4hxQewrIRpeDH8W4MD6SKZleZWBaQO+lgII36EgH6iD9al63/I1v4Q/Zwj0jwnka4OwLQOo8k9zRyo0O1WbKda85TtnZvSIq5NWiBUdxRRePQO4FZ1duJZZrKM7xsq6dcdSoYgFgOBI+vB8ozrMCylAHB4hlAIjkGGr1+/d07df2ryXxriUGJVFB1lRqI2G/yg7bkheR3HakjM5tTI/pKp3QK8J4z9PjLDuQAX0kkiNLgox9hqn6V7iaxfgTDWlsB3RS7uSrlVOlV8oAJ3HmDH61syatkyeo/5XAkz2eDhphrpppNKpNs41RmnmmGnSA2RtTTTzTDTpCtkZNMZjUjVGRTpCtkZJqMk1MwphFOkIyJpppmpSKYVpkAhYUwrVgrTStOgMgK1wWyeBRXLcvNwyflFaG3hlUQFFJWRS9BmdmHa2RyKYUrc3rakQQPtQXM8PbtIzhC8T5dWngE8we1b10lth9JvwZ/TS01HmGaW9KvaHlK7q06gwjUo9p5qTJM1s3L622RoY6VaRzG2pegPv2orPLRvSpfBlM08zFPMIImeZ9ug570U8M4dtLiNiwjvMQ30+X80Z8f4FdKBJXQ6sRBhgysIn1089INEvDWW67Fpw28tqHYh22+0Vy4XM09fydOa7ueX5C+WZKiAMwlvwKLyBUF3FIhCs6qxiASATJgR7nahwzZWxNzD8FLaOD3JLax9AU95PajVdz5ZNTrwFSQeayvicW0dBwzqxUfzaY1AesEGPQ9qPfE3j/No/vXl3ibO7mJuq1tGmwx0uoJBIdiDI2Epp2PJ1dK3e4aaA57loq57jSwKqIa26sD1jaIPvP4oBjnZnYkkkDcnuefyat4m87OHG7EHVA8oaePv/SqAbaDyTJP0/wB6g6qq7mFJStCu3iUVdUgSY7Cf3mfxUek05V5FdiiY+hEskH0q3NR6tqp4nHqkTvJOw5ET/Wm9sLkblltmqni8VpBAPm27bb+vpQe5j2LFiSJ6A7e1IOI2/P8AWuW+odLUlJlb5BHiLOXw7pA1h1cEFiII0wwMHudv7VlfFGFsyH0D4jaCW1PzCiSs6ZgdqtZ3k143JUl0O6sWkqCdwdRkgd6zuNUhypIgEwY9/wDehhmW00+fkvXCDGA8SPbtqiosIoEk8xuxPuZNeg5XmBKItzysVXboGMSs+hNef+GcEhBuOA2loQRtPOpu8SIH+0ak3wRvVaamvac7fwasmmk0GwGagDS5JMgBvQ9zRR7oHJq0UqWybHmmE01LoPFImqpCtiNMNdJrhNMkBsaaYacTTTTpCtjDUbOJCzuQSB6CJ/cVds4NmGowF6k7ADqaz36T4odgzcXPguSQQFbVIHO+/sFqWXMsaHx43QVIrmmr+V4QXUS5q2ZQY7HhlPqDI+lT4h8PYZdZgncbE8dTA2p3llLexex70U1y1yJiqzYZ5jSZo5hM2tXSyo0lI1bEczBE8jympGuigsu1tBcDsvtaUAIg9affxCJuzAULv5yF+Uah13ie0GgWYZsW3Y7jgAcewryup/UscbUcv+i04m/IcxWcopIEkyRtEe8zxQrG5pbuW2S4WUsI8vfuD+4Pcjesrjc5UTvWYx/iMzpQ79T0rljquqyVta19aKdsyaTHWrXypJKkgHjUIB47f2NXfC2JsWbjXrpErCoN51POpvQAAif+qvOLueXCZJHtVjC+IDsrgFdgTzA6nvXoYclpaoWmmeteIMytX0jWF087hhv8p2G5+b7VSwmfLYsC3aLNBaSqEEyZkk8DeNt9qC5dmlqyHDpq1RsAG69QdvXnpXbPiRFDDQqEjdlnfneI6bbetO202NqdIkx+KxF1NTTAkb6tYBYsDq6xqj/iqVrPXTGpfcmSCH0CNSlQIgzyVX36RzRfMbqG2AzMmoEqCDLdTqkbem8Vmr1iX1cCBuN9xxRilS2gOVsMp4md7zjQzIXcW4nUr3CFAJ6Bt9u525py5fct2AFXR5mZwZ1EkKNUNxssR6CghBkOfKwYMCp5ZTKn0Owow2cFpRwzTyyyemw5jk9Kz2tMy0uARiE0IWA+nfpP5oIFo9jGDbCftH3mqC4SedqLtCUtlFUk1P8ADq2mFUd6k+GBU3QNHqOJzQkFVkb/ADT0B6UOe716nmqwu7VG9yoVu3ug714J2em66rh6dqo9mgbH5mrKrFm0opGlQZ1REFyVkeboI46157iH1Ox7n+tbPxO6qWZdK3NJGqF1Mu0yJmON/X3rBgksoA8pZdR2EJDSfXcLx60/Szxs6Mr1wbbLrWi2qnnk+5P9oH0qc3KbdaoC9V7d8nI6LPxKuYXMY8r8Rsev1oSXppeip0DZqtdTrix1G9ZjDZiySDuI29D0+lEsLf1IpJ34PuKtPHgDYWN6nrv/ABUL+IR1rv6k1dNCmgsBNp3qth88QtpZFVfOQ8jSUU+U79SOn17wLW5qgA7nbtuaamVoQA+lojyD5Q0Dk9do6CuLq+oWFrk6MEKk9/6CGdYkuALSm4ul1dP/AK3DKdO8iYYKTBmJHWhz4p0HysBogICC6kzIAB3gkRxx0oioAEDYDgDgUAx+SlmLfFbkkA/wz2INeb+5eWvdpI6FPauCfB+JVw6N/wDE+p7jvE+UyV33+SRPlEiV9ag8WMbws3bZ2uqBpJhtgWB3MARIMbdZM1BessqFNQcjgsJ6zvv7/ihFk3bLG4hCvGkkAHkzImQDtHH713Y8ipaZz0tPZzKce9q6jLq+YKyAwXEwVIO3369q9FxuJCqdzJ7GD9+lBrGOV7aMwQk6WaAI1wJaD/FI9xFVcfjQFJJpeqyrDial7b4WvjZsadPkr43MNHvHNZPNc4UGCxB5A/bpVDP80YsArRyTFZ/EXWcy3PFed0/SJJVRSr+BXr7MSSx39aiAinLUiCvRXBLY1VrjJ1p7L61GGrGC2Q4i0jt8Z3VCuxVdQDTPmUb9xt3r0fKsssoFuhg+pQyNAgAgEMvO/rXkTNKmK9Vw+bW3sq9tvLpAEiIgAEEdI/4qWdU1qWx4a+RmbYpAZdNRnYTv9KFtmaQNNpZkTI26T/WosVig4J0wxMTvx1jtVPTT48Wp0xap7D2AvW7qtNtFII4A4Pr96l0KgIUf571nrblSGHIqzcxrFpHEbg8TQrC98PgZXxyXLyCqxQVGmLYbHzD/AH71PqH9fpTKXIu0yLcHjb806KVx4EjeqnxG/mopbBs0iZikkTHr0pmOxREKOs7947VncBi1ddmWQPMJ6zBj0mrbOdt5pPT8L4QdhvLrxZTJkg/iKtM/5rOW7rKZBjb8U79YVhnaEkEn0kTvT8oynbJPFeKf4rqfkkKglTOx1kgbghtI39Y5NDMlsKzywBgE7777AbfWrvia6jvqChXPzR1niTA1bDkVDkzASYY+XYAdJG7fXTvVMXtjkpl53oOlqrs1JsQAqlmUF3CKC0Eu06RB4mKjxOtSZUbGDBmPT3jpTLJO9HN2USaqazVX+OPzTg87DkmAPWYFXWhNMf8AEqxh2ZTrnSF7z9o61C4ReSC2+3InpxTVS68nePrx224FSvJ9fkeY+wumZowJ3Ef5tQ3F4x3UgrAnYnYxvtHX3rlrLbvQMATEwR+amu5M45Mn3H9am8yb5Y6jXwGPDqHS1xiSTspP8vWB03/ajAI6VkMMb1kgKW0yTo2gkiN4+lW72Y3wZUIRvtv9Jrgy4aum9rktFpLRobtyKo370VSs5hrAJEHqPX361TxWM88E7EbehHf7/iljp2npjVa0T37k1SczzUNzFLsZkBoPPY8d6TXRB3EifxxXXMdpFvZ23c0NtwQTHTaP71m87zO+u7QFZiq77yoBM+nmA+h9KKvcZggnfcyOe1UrtpHEOob3AMf5AqjxKl7gd2vBkL98ltR61zWKJX8gefI4I/6tiPtz1p93wy+kvbdWAIUKdmbYkkdOnWORR7NI29gvWBUDXN6etgnrU9rChd2NFSMpbKxc9afr2invhLjHUEeCYU6TB7b079FdkroeYmNJ4rNCvyNLgCK0uVBhZQEEbE88hiWBjpzVfLclCw1zdiN0IBCme87/AO5oqiRsOBxRU6AM012pIrqIWOwJPYbn7UTEYHpXAsiiNjLbjH5dPvyPpz+KL4TJkSGbc8/8Dgfn6VOssorGGq+DNG2w2Ijad+x4p+lQu4ljwZOw4q/irg+JcOkdhO/BCyO8wfvQ+Jo7b8iVPbWkNZui7DrvuaTWwP4j9h/emYm+iTqYCOQNz7R3oFez9tR0qoE7bUnfv/qZL7IMLivgvqQalIgg7SJG49aNYXOLbuFJ0KR877AN2bsI68bVKnhlyoOke0kkDuYn8SauZZ4RW6NTSIYgrp324AZo3+lc76vHK22U9KggmXl1f4TI5SNTAgqpKhgH3Hljrxz2NYPE4p3Mu0noOg5+UV6B/wC0LSqxVXBKGUD6Q206WiQd/cVjMdlLo58jKBsNXp699unati6vHben/wC/I/a5Xgs38UXABMwIHHEQCD7VLkfiI4O6xK60Z2R+S6org+STuYnY87b7UAS1cQmNQ523I+1XBh1uCSCrlmY78FjJAEcV1uoqWmT5fjyaD/UPEi5+ne26vZYXNIWIDqyB2Jnc+aPSDzNaXD2tVm18U630JqbglioJ+v715jdwbrAmQJieBPO3AmBPsK0+VeIXRAl0F9OweQG0gAANPJ/6p/vUKSUpJ+DNthLF2FViAe2/v3qzlmUvcllA2PzE7A+nc0JfN0Yljq5O2xP4NGMq8WokI4bQFCrCjoeSJ32/YU95Wo1L5FmU3yaHCZJbTnzNtudookDA/wA/J6n1oSPEVkqWUswERA3Pfynf8VRu+JEZ10AxuDq8vJUyPsRXnt1T9z/svrS4Qcu3qoXbkmqWPxlwoGsoHMbgMhgke++/Xf2rO4bMMar6Xs611Cdm1qCd4PXaeaeHG/K/ItTX0aO8/WoGbeOsTVPF4u8GATD3GU8t5Z4/lmfvU+Ewd99LFYgFYbyk+sdthzV/VxStul+SfZT+DruBEnuP8+xoRib2s+nT270Su5NiGMlR/wBwqbDeHXnzsAOy7k+m+w/NN+76eFt2v9cm9O3xoBMTAB45+9cDHffnmtKMiUsdWqAIBB3JhY5UCOeJ9+0GdZbeuaSjhVVQFthfKoA4mTJ9aVfqOBvWxvQrW2AATz/grkVewmW3gCrxuJmNxBGzdJ9jU/8A6ZcTzAKxG4WYJP12q37zD9on6dfQONvzaeuw+v8AzUuOVXBR1BUqFYRsI50/jf0oZir2JVifglYMyRMbnmGgbzTcPdxDnQVVGJkMQ/BjoFI+pPWt68NbCsdeED8fhcPbU6C2uTAmTIMkR0EEbnsKpqQRv/nSjOLylUYq7M9wwS4IKbztsT1jnfbgVBcyW4FLArA95O249DuNj3rLPD8nROKkh2S4jSjh2AAfykkAQZMb8bD96I4fEI86HBiCe4kSJBrJvYYjg+h3/FPw957ZlZHykgbTpMwdpA/vVe457l7NhFILUOFzC24BnSf5WgH+x+lTfq7f86f9w/Jo9y+xNMRFSYTZ1/8A0P3FQX8UgZVLryQxBkJv6bN7gmjOGOEA1/qEdgYKmEIbmRJ8wHQiQaS7SXI0S9mhVeP8/wA5qHEXQikzvsAO5gVRuZupTWjAid1WWcAT5mgEDYbfShOM8TWFDBbTsTI1NOteIO4gdfXjcVxypVcv8HoVlWvaNxInk8MQPaOT9aHYzGog5iNhAlmO+yn070LxufXW1BTpQxI543gzI+npQe9dZjqZix7kzVbTyPnhHHtL/JeW2GVr10ws+VRyxn5RPSNqpXcexJjSB0GkbCm3rzNsYCiYUCAJ9Kj2708yTbNff8coq/8AxqdU9eK0ng/xC2KDalC6evevGwaK5VnNyyRoYhZkgda5s/6dFY2oXP2x4z0q3Xg92YVXu2wRBEjtWQ/99ooQsmzDczuKNZPnqYlSyyIMQa8Ouly4l3NcHWskU9JjcVllsz5F3Mnyjf8AFBMVkiEyJH7Vo8ViUUgMwBPE9arXBVsWXJPO2JSRlrmTsIAaduT327fWqrZWwMRv2BE+u1atkpvwq611dfIvaZtMmc9PyKddyl0+YbdxWnt26sKgqddXX0PMSAcDkTOuqQJ4qa1kN0kiBAMSTE8bj70cDxThiPWoPPb3odTKKFrw2f4nA4OwmiSZfoEC4/M9OevTrXVvU74lRd0/LG4+CW2I61Ohqmr1Mj1GkFFkGu1GGpfGUdRU9MYeRXGSonxaDrUTZitFTXwgPRK1oVG1oVB/6j6UmzAdqopoV6JlSNuPapIWqhxq9q5+oU9abVMXeiwwQGYE9/8AOagvAEzEyI33H2O31phvL3rqkHimW0bYHx2RWnghQkSfKAJnvtWex+RumojdR9THtW6K1DcSujF1Nz87EqEzzf8AS7/Lv7d6sDLH/kbp0PUSK3JsCZgbcdx7fmpktCuiuuf0KsKZgUyt2YKqkk7/AIn9qO5b4YYmX8u/vPtB/wAitSiCrC7Vz5OuulpcFJwyvJHhsCiJoCjTG479571ZfCo/zorRxqAMe00lenq9cLqm97K8A7EZFYYk6InnSYHvA4+lCsb4WwxUwp1RAYmY7bdq0zvQ/EvVcWbInw3+RKmfo88x3hplmADHEHf80IOVt/I/2Neg4s0LNevi6q9cnLULZ5mDTgaYDTga9pnKSaqKZVndzDz8MgTzQkGnA1OpmlqltGTa5QZxfiC7cdXbfQZArQ5X4ma40uVRAN+81hquZbaRnh20r+9Qy9Pjc+PA83Wz1C1jUcSrAiuPilHFZG1m9i2ulSTHHrT8Jn6POry9q8x9JS20nousiNI2LPTauri2nmqyIWXUODUbGp9s+Cncwl+uFc/WL3oYQTTQDW9OTdzDVvFA8GrCXqDW7B5mriNFSqJ+DKmEkuVOlyhavUiXqlWMoqLbs5OxqtcRhzT1v1y/j0QSzAD1oKaXCRu5ESoTXGWOtNv51YQBiy+YxI5PaptCt5p5p+2ly1pG7l8EaLNPZCKkRFFdeDS75Nsrt6mKlTDEiZrznxBjbi3HQMwQtIB/pRbwnm1920N5kA5PSu6ujqcfemiCzJ1rRsUwpnc1cQAUNxmYi2pYgmOwoA/jJBA0sTMGYmuWcGTIvah3cz5NkTUbmquHxetA3EiYrr3aj6bT0P3EhanI9UnvjvTWxarywH1p/TbB3hVXp3xKE2MxR50uDHO9UsV4jtI+gneNz0FZdPdPSQXkSXk0XxKX6oBgu8mf4Wjbu0QOO9ZTB+J1cOxWAn3NB8w8Yvqm18sbgirR0NumtCPNK5PQ3xa/zDfjfmqWLxQUEkwK8ofOLpbUWMgzzUtzPLzqyFhvPP8A4j1rqn9Laa5J/uEzVZr4gtqQAdU9R0oPc8SJJ2NZW4rCZB2qOa9GOjiVpkXlpnBTgaVKusmPBpwpUqUw4UqVKgYVdFKlWMbTJc+t6FRvLAAk1orQRwGEEHrXaVeR1eKY5R1Yqb8koQDpUbW17UqVcKLM5IpKwpUqYUQMD79up4qN7sb/AHpUqZeQUBLnihFcqRIHUVns5zpr/lIhQdqVKvYx9PjnVJcnJVvQK+IdtztxWgybxK1pSry3au0qtlxRa5Qs00+Azk/iM3mKFY9aO/GpUq8jqcURfCOmKbXIKzHAWmb4jqWgcVS/Ui3pWzADdI3ApUqfH7pSYr8nMyxI06WukSOBzNAbWW6gXDGZ2nrSpV0R7I4E8vk0mX4x0QKxkip7uYmO1KlUHjlveiiYOvZoi8tQnOsWXUFZjvvFKlXTjxTOmidU+QRZxLrOliJ5prljuZ96VKuvS2TGhyODTDXaVMYjJpBoM0qVFGOviXPWB2HFQUqVMY//2Q==",
              },
              light: {},
              dark: {
                "wall-bg1": "#683f10",
                "wall-bg2": "#683f1055",
                "wall-bg3": "#683f1077",
                "wall-bg4": "#351e03",
                fg: "#f5f5f5",
                bg: "#333",
                fbg:
                  "radial-gradient(rgba(255, 255, 255, 0.05) 20%, transparent) 0 0/20px 20px, radial-gradient(#FFCA08 6%, transparent 8%) 0 0/20px 20px, radial-gradient(#FFCA08 6%, transparent 8%) 10px 10px/20px 20px, linear-gradient(45deg, transparent 48%, #000000 49% 51%, transparent 52%) 0 0/20px 20px, linear-gradient(-45deg, transparent 48%, #000000 49% 51%, transparent 52%) 0 0/20px 20px",
                fbgColor: "#262626",
                fbgSize: null,
                bgImg:
                  "data:image/png;base64,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",
              },
            },
            theme: "light",
            "+languages": {
              money: "金币",
              time: "时间",
              life: "生命",
              "life-1": "最小",
              "life+1": "最大",
              distance: "距离",
              "distance-1": "最近",
              "distance+1": "最远",
              speed: "速度",
              "speed-1": "最慢",
              "speed+1": "最快",
              fromTarget: "终点",
              "fromTarget-1": "最近",
              "fromTarget+1": "最远",
              terrain: "地点",
              build: "建造",
              upgrade: "升级",
              notEnough: "不足",
              restart: "重新开始",
              select: "选择",
              allRestart: "全部已完成，重新开始",
              jumpTo: "跳到",
              recycle: "回收",
              success: "成功",
              failed: "失败",
            },
            recycleRatio: 0.5,
            updateRatio: 0.8,
          },
          "+attackers": {
            "紫麟蛛(lv1)": {
              bombDamage: 1,
              speed: "2~1",
              avatar: "👾",
              life: 50,
              scale: "0.5~0.25",
              diedResources: {
                money: "2~2",
              },
            },
            "铁血战士(lv2)": {
              bombDamage: 2,
              speed: "2~1",
              avatar: "👽",
              life: 100,
              scale: "0.5~0.25",
              diedResources: {
                money: "4~2",
              },
            },
          },
          "+defenders": {
            __base: {
              strategies: {
                distance: 0,
                fromTarget: -1,
                speed: 0,
                life: 0,
                terrain: 0,
              },
            },
            lv1: {
              scale: 1,
              "+buildResources": {
                money: 10,
              },
              "+attacks": {
                "+普攻": {
                  cooldown: 0.25,
                  range: 3,
                  damage: 2,
                  bullet: {
                    箭矢: {},
                  },
                  filter: {
                    普攻: {},
                  },
                },
              },
            },
            lv2: {
              __extend: "lv1",
              "+buildResources": {
                money: 30,
                time: 5,
              },
              "+attacks": {
                "+普攻": {
                  cooldown: 0.15,
                  range: 5,
                  damage: 3,
                },
              },
            },
            lv3: {
              __extend: "lv1",
              "+buildResources": {
                money: 50,
                time: 10,
              },
              "+attacks": {
                "+普攻": {
                  cooldown: 0.1,
                  range: 7,
                  damage: 5,
                },
              },
            },
            "丛林猎手(lv1)": {
              __extend: "lv1",
              avatar: "🌲",
              "+upgrades": {
                "寒冰猎手(lv2)": {},
                "睿智猎手(lv2)": {},
                "狂暴猎手(lv2)": {},
                "圣诞猎手(lv3)": {},
              },
            },
            "睿智猎手(lv2)": {
              __extend: "lv2",
              avatar: "🌵",
              "+attacks": {
                "+普攻": {
                  cooldown: 1,
                  damage: 20,
                  splash: {
                    range: 1,
                    ratio: 1,
                    rangeAttack: -1,
                  },
                  bullet: {
                    炸弹: {},
                  },
                },
              },
            },
            "寒冰猎手(lv2)": {
              __extend: "lv2",
              avatar: "🌴",
              "+attacks": {
                "+普攻": {
                  splash: {
                    range: 1,
                    ratio: 0.25,
                    rangeAttack: 1,
                  },
                  bullet: {
                    冰箭: {},
                  },
                  filter: {
                    冰冻减速: {},
                  },
                  buffer: {
                    减速: {},
                  },
                },
              },
              "+upgrades": null,
            },
            "狂暴猎手(lv2)": {
              __extend: "lv2",
              avatar: "🌳",
              "+attacks": {
                "+普攻": {
                  cooldown: 0.05,
                  multiTarget: 3,
                },
              },
            },
            "圣诞猎手(lv3)": {
              __extend: "lv3",
              avatar: "🎄",
              "+attacks": {
                "+普攻": {
                  splash: {
                    range: 2,
                    ratio: 0.5,
                  },
                  bullet: {
                    炸弹: {},
                  },
                },
              },
            },
          },
          "+bullets": {
            箭矢: {
              avatar: "🎾",
              scale: 0.15,
              speed: 10,
              rangeTarget: false,
            },
            冰箭: {
              __extend: "箭矢",
              avatar: "❄️",
            },
            炸弹: {
              __extend: "箭矢",
              scale: 0.2,
              avatar: "🎱",
            },
          },
          "+filters": {
            普攻: {
              color: "#ff0000c0",
              avatar: "◎",
              scale: 1.5,
              last: 0.5,
            },
            冰冻减速: {
              __extend: "普攻",
              color: "#0000ffc0",
              avatar: "❄︎",
              last: 2,
            },
          },
          "+buffers": {
            减速: {
              speed: 0.9,
              last: 1,
            },
          },
        },
        守卫雅典娜: {
          "+config": {
            defenderName: "雅典娜",
            attackerName: "路西法",
            attacker: false,
            life: 1,
            "+initResources": {
              money: 100,
            },
          },
          sessions: {
            __base: {
              attackerWaves: [
                {
                  delay: 30,
                  attackerGroups: [
                    {
                      "紫麟蛛(lv1)": {
                        count: 5,
                      },
                    },
                    {
                      "紫麟蛛(lv1)": {
                        count: 5,
                      },
                    },
                  ],
                },
                {
                  delay: 60,
                  attackerGroups: [
                    {
                      "铁血战士(lv2)": {
                        count: 10,
                      },
                    },
                  ],
                },
                {
                  delay: 60,
                  attackerGroups: [
                    {
                      "铁血战士(lv2)": {
                        count: 10,
                      },
                      "紫麟蛛(lv1)": {
                        scale: "0.6~0.2",
                        count: 10,
                      },
                    },
                  ],
                },
                {
                  delay: 60,
                  attackerGroups: [
                    {
                      "铁血战士(lv2)": {
                        count: 20,
                      },
                    },
                  ],
                },
              ],
              defenderTypes: {
                "丛林猎手(lv1)": {},
              },
              initDefenders: [],
            },
          },
          sessionMaps: {
            村口: {
              width: 11,
              height: 11,
              walls: [
                "22221112222",
                "21111111112",
                "21121212112",
                "21212121212",
                "21111111112",
                "21122122112",
                "22221112222",
                "11122122111",
                "11111111111",
                "11111111111",
                "11111111111",
              ],
              terrains: [
                "44444444444",
                "44444444444",
                "44343434344",
                "44434343444",
                "44444444444",
                "44444444444",
                "44444444444",
                "11144444111",
                "14444444441",
                "14222422241",
                "14242424241",
              ],
              starts: [
                {
                  x: 9,
                  y: 10,
                },
                {
                  x: 1,
                  y: 10,
                },
              ],
              ends: [
                {
                  x: 6,
                  y: 0,
                },
                {
                  x: 4,
                  y: 0,
                },
              ],
            },
            "SessionNo.2": {
              width: 11,
              height: 11,
              walls: [
                "22222222222",
                "21111111112",
                "21111111112",
                "21111111112",
                "21111111112",
                "21111111112",
                "21111111112",
                "21111111112",
                "21111111112",
                "21111111112",
                "22222222222",
              ],
              terrains: [
                "44444444444",
                "40000000004",
                "40000000004",
                "40000000004",
                "40000000004",
                "40000000004",
                "40000000004",
                "40000000004",
                "40000000004",
                "40000000004",
                "44444444444",
              ],
              starts: [],
              ends: [],
            },
            "SessionNo.3": {
              width: 11,
              height: 11,
              walls: [
                "22222222222",
                "21111111112",
                "21111111112",
                "21111111112",
                "21111111112",
                "21111111112",
                "21111111112",
                "21111111112",
                "21111111112",
                "21111111112",
                "22222222222",
              ],
              terrains: [
                "44444444444",
                "40000000004",
                "40000000004",
                "40000000004",
                "40000000004",
                "40000000004",
                "40000000004",
                "40000000004",
                "40000000004",
                "40000000004",
                "44444444444",
              ],
              starts: [],
              ends: [],
            },
          },
        },
      },
    };
  </script>

  <meta
    name="viewport"
    content="width=device-width, maximum-scale=1.0,user-scalable=no, initial-scale=1"
  />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="transparent" />
  <script>
    const {
      registerElement,
      registerProperties,
      evalInContext,
      delayDispatcher,
    } = (() => {
      const evalInContext = (exp, context) => {
        return function () {
          with (this) {
            try {
              return eval(`(${exp})`);
            } catch (e) {
              console.log(exp);
              console.log(e);
              return;
            }
          }
        }.call(context);
      };

      const removeItem = (item) => {
        const clearItem = (/**@type {HTMLElement}*/ item) => {
          for (let c of item.childNodes) {
            clearItem(c);
          }
          let onRemoves = item.onRemoves;
          item.onRemoves = undefined;
          if (onRemoves?.length) {
            onRemoves.forEach((onRemove) => onRemove());
          }
        };
        clearItem(item);
        item.remove();
      };

      const onprop = (parent, /**@type {String} */ exp, context, listener) => {
        const tokens = exp.split(/\.|\?\.|\[|\]/);
        if (!tokens[1]) {
          if (context.tmpCtxName === tokens[0]) {
          } else {
            context.on && context.on(tokens[0], listener, true, parent);
            parent.onRemoves = [
              ...(parent.onRemoves || []),
              () => {
                context.off(tokens[0], listener, true);
              },
            ];
          }
          return;
        }
        if (context.tmpCtxName === tokens[0]) {
          context = context[context.tmpCtxName];
          tokens.shift();
        }
        const clearBind = (current) => {
          while (current) {
            if (current.off) {
              current.off();
            }
            const next = current.next;
            current.next = undefined;
            current = next;
          }
        };
        const register = (tokens, handler, context, offChain) => {
          const prop = tokens[0];
          if (!prop || !context) {
            return;
          }
          offChain.next = {};
          const registerNext = () => {
            register(tokens.slice(1), handler, context[prop], offChain.next);
          };
          if (context.on && context.on instanceof Function) {
            const listener = (...args) => {
              clearBind(offChain.next);
              offChain.next = {};
              registerNext();
              handler(...args);
            };
            context.on(prop, listener, true, parent);
            offChain.off = () => {
              context.off(prop, listener, true);
            };
          }
          registerNext();
        };
        const offChain = {};
        register(tokens, listener, context, offChain);
        parent.onRemoves = [
          ...(parent.onRemoves || []),
          () => {
            clearBind(offChain);
          },
        ];
      };

      const bindingForInstruction = (/**@type HTMLElement */ element) => {
        let forExp = element.getAttribute("for.");
        const match = forExp.match(
          /^\s*(((let|const|of)\s+)?(\w+)\s+(of|in)\s+)?\s*(.+)\s*$/
        );
        if (!match || !match[6]) {
          throw new Error("Invalid for Expression");
        }
        const collectionName = match[6];
        const of_in = match[5] || "of";
        let varName = match[4];
        let forHead;
        if (varName) {
          forHead = `for(const ${varName} ${of_in} ${collectionName})`;
        } else {
          varName = "$$i";
          forHead = `for(const ${varName} of ${collectionName})`;
        }
        const comment = document.createComment(element.outerHTML);
        const parent = element.parentElement;
        parent.insertBefore(comment, element);
        element.remove();
        /**@type Map<any, HTMLElement> */
        let items = new Map();
        /**@type Map<any, HTMLElement> */
        let newItems = new Map();
        let idx = 0;
        let allRemoved = false;
        const update = () => {
          (function ($$forEach) {
            newItems = new Map();
            idx = 0;
            allRemoved = false;
            with (this) {
              eval(`
          let collection
          try{
            collection = this.${collectionName}
          }
          catch{
            //ignore
          }
          if (collection) {
            ${forHead}{
              $$forEach(${varName})
              }
          }`);
            }
            for (const [_, { item }] of items) {
              removeItem(item);
            }
            items = newItems;
          }.call(element.context, ($$i) => {
            /**@type HTMLElement */
            let item;
            if (items.has($$i)) {
              const pair = items.get($$i);
              item = pair.item;
              if (!allRemoved && idx !== pair.idx) {
                console.log("removed");
                for (const [_, { item }] of items) {
                  removeItem(item);
                }
                allRemoved = true;
              }
              items.delete($$i);
            } else {
              item = element.cloneNode(true);
              item.removeAttribute("id");
              item.removeAttribute("for.");
              if (item.updateModel) {
                item.model = $$i;
              } else {
                item.modelBeforeInit = $$i;
              }
              const context = Object.create(element.context);
              context[varName] = $$i;
              context.tmpCtxName = varName;
              item.context = context;
            }
            parent.insertBefore(item, comment);
            newItems.set($$i, { idx, item });
            binding(item);
            idx++;
          }));
        };
        update();
        let lastContext = element.context;
        comment.updateWhenModelChange = () => {
          if (lastContext === element.context) {
            return;
          }
          lastContext = element.context;
          update();
        };
        onprop(parent, collectionName, element.context, update);
        return {};
      };

      const bindingIfInstruction = (
        /**@type HTMLElement */ element,
        keyChangeRemove
      ) => {
        let ifExp = element.getAttribute("if.");
        const comment = document.createComment(element.outerHTML);
        const parent = element.parentElement;
        parent.insertBefore(comment, element);
        element.remove();
        let item;
        let lastValue;
        const update = () => {
          const value = evalInContext(ifExp, element.context);
          if (keyChangeRemove && value !== lastValue && item) {
            removeItem(item);
            item = undefined;
          }
          if (value) {
            if (item) {
              return;
            }
            item = element.cloneNode(true);
            item.removeAttribute("if.");
            item.removeAttribute("keyif.");
            parent.insertBefore(item, comment);
            item.context = element.context;
            binding(item);
          } else if (item) {
            removeItem(item);
            item = null;
          }
        };
        update();
        let lastContext = element.context;
        comment.updateWhenModelChange = () => {
          if (lastContext === element.context) {
            return;
          }
          lastContext = element.context;
          update();
        };
        for (const exp of getPropsFromExp(ifExp)) {
          onprop(parent, exp, element.context, update);
        }
        return {};
      };

      const getPropNameFromBindingAttr = (attr) => {
        return attr.replace(/-(\w)/g, (_, c) => c.toUpperCase());
      };

      const getPropsFromExp = (exp) => {
        return exp.match(/([a-zA-Z0-9_$.\[\]]|\?\.)+/g) || [];
        // return exp.match(/[a-zA-Z0-9_$.]+/g) || []
      };

      const bindingAttrs = (/**@type HTMLElement */ element) => {
        if (element.hasAttribute("for.")) {
          return bindingForInstruction(element);
        }
        if (element.hasAttribute("if.")) {
          return bindingIfInstruction(element, element.hasAttribute("keyif."));
        }
        if (element.updateWhenModelChange) {
          element.updateWhenModelChange();
          return element;
        }
        const bindingAttrs = element
          .getAttributeNames()
          .filter((p) => p.endsWith("."));
        for (const prop of bindingAttrs) {
          const $$exp = element.getAttribute(prop);
          const effectedAttr = prop
            .slice(0, -".".length)
            .split(",")
            .map((a) => a.trim())
            .filter((a) => a);

          if (effectedAttr.some((a) => a.startsWith("on"))) {
            const value = `(function($event){with(this){${$$exp}}}).call(event.target.context, event)`;
            for (const ea of effectedAttr) {
              if (ea.endsWith("$")) {
                element.setAttribute(
                  ea.slice(0, -1),
                  "event.stopPropagation();" + value
                );
              } else {
                element.setAttribute(ea, value);
              }
            }
            continue;
          }
          const update = () => {
            const value = evalInContext($$exp, element.context);
            for (const ea of effectedAttr) {
              if (ea === "model") {
                if (element.updateModel) {
                  element.updateModel(value);
                } else {
                  element.modelBeforeInit = value;
                }
                continue;
              }
              if (ea === "focus") {
                if (value) {
                  if (element.scrollIntoViewIfNeeded) {
                    element.scrollIntoViewIfNeeded();
                  } else {
                    element.scrollIntoView();
                  }
                  element.focus();
                }
                continue;
              }
              if (ea === "scrollintoview") {
                if (value) {
                  if (element.scrollIntoViewIfNeeded) {
                    element.scrollIntoViewIfNeeded();
                  } else {
                    element.scrollIntoView();
                  }
                }
                continue;
              }
              if (ea.startsWith("class-")) {
                const className = ea.slice("class-".length);
                if (value) {
                  element.classList.add(className);
                } else {
                  element.classList.remove(className);
                }
                continue;
              } else if (ea.startsWith("style-")) {
                const prop = ea.slice("style-".length, -1);
                element.style.setProperty(prop, value);
                continue;
              }
              if (ea.endsWith("$")) {
                let prop = getPropNameFromBindingAttr(ea.slice(0, -1));
                switch (prop) {
                  case "innerHtml":
                    prop = "innerHTML";
                    break;
                }
                element[prop] = value;
                continue;
              }
              if (value === undefined || value === null) {
                element.removeAttribute(ea);
              } else if (element[ea] !== value) {
                element.setAttribute(ea, value);
              }
            }
          };
          update();
          for (const exp of getPropsFromExp($$exp)) {
            onprop(element.parentElement, exp, element.context, update);
          }
        }
        return element;
      };

      const binding = (/**@type HTMLElement */ element) => {
        /**@type { Object.<string,HTMLElement> } */
        const components = element.context.components;
        if (element.hasAttribute) {
          const handler = bindingAttrs(element);
          //collect ids
          if (element.hasAttribute("id")) {
            components[element.getAttribute("id")] = handler;
          }
          if (handler !== element) {
            return;
          }
        }
        for (const child of [...element.children]) {
          if (
            child.context == element.context ||
            (child.context &&
              Object.getPrototypeOf(child.context) === element.context)
          ) {
          } else {
            child.context = element.context;
          }
          binding(child);
        }
      };

      const getNameFromTagName = (tagName) => {
        return tagName.replace(/(?:^|-)(\w)/g, (_, c) => c.toUpperCase());
      };

      class DelayDispatcher {
        constructor(delay = 50) {
          this.delay = delay;
          this.currentTask;
          this.running = false;
          this.lastDispatchTime = 0;
          this.groups = new Map();
          this.count = 0;
          // this.delayListeners = new Map()
        }

        set(obj, key, method) {
          let group = this.groups.get(obj);
          if (!group) {
            group = {};
            this.groups.set(obj, group);
          }
          group[key] = method;
        }

        async start() {
          if (this.running) {
            return;
          }
          this.running = true;
          this.currentTask = new Promise(async (resolve) => {
            while (this.running) {
              let now = Date.now();
              let remain = this.delay - (now - this.lastDispatchTime);
              if (remain > 0) {
                await new Promise((r) => setTimeout(r, remain));
              }
              let groups = this.groups;
              await new Promise((resolve) =>
                window.requestAnimationFrame(async () => {
                  this.groups = new Map();
                  for (let [obj, group] of groups) {
                    if (!obj || !group) {
                      continue;
                    }
                    for (let p in group) {
                      try {
                        group[p]?.();
                      } catch (e) {
                        console.log(e);
                      }
                    }
                  }
                  resolve();
                })
              );
            }
            this.lastDispatchTime = Date.now();
            this.currentTask = undefined;
            this.running = false;
            resolve();
          });
          await this.currentTask;
        }

        async stop() {
          this.running = false;
          await this.currentTask;
        }

        setDelay(delay) {
          this.delay = delay;
        }
      }

      const delayDispatcher = new DelayDispatcher();

      const registerProperties = (obj, ...props) => {
        const backup = {};
        if (!obj.define) {
          addPropChange(obj);
        }
        props.forEach((prop) => {
          const desc = Object.getOwnPropertyDescriptor(obj, prop);
          if (desc && !desc.configurable) {
            delete backup[prop];
            return;
          }
          let propValue;
          let [propName, handler] =
            prop instanceof Array ? prop : [prop, undefined];
          if (obj[propName] !== undefined) {
            backup[propName] = obj[propName];
          }
          Object.defineProperty(obj, propName, {
            get() {
              return propValue;
            },
            set(newValue) {
              if (propValue === newValue) {
                return;
              }
              const oldValue = propValue;
              propValue = newValue;
              obj.raise(propName, newValue, oldValue);
              handler?.(newValue, oldValue);
              delayDispatcher.set(obj, propName, () => {
                obj.raise(propName, newValue, oldValue, true);
              });
            },
          });
        });
        Object.assign(obj, backup);
        return obj;
      };

      const registerAllProperties = (obj) => {
        return registerProperties(obj, ...Object.keys(obj));
      };

      Object.defineProperty(Object.prototype, "registerProperties", {
        value: function (...props) {
          return registerProperties(this, ...props);
        },
      });

      Object.defineProperty(Object.prototype, "registerAllProperties", {
        value: function () {
          return registerAllProperties(this);
        },
      });

      delayDispatcher;

      const addPropChange = (/**@type { Object } */ obj) => {
        /**@type Map<string, Set<{(newValue, oldValue):any}>> */
        const atonceListeners = new Map();
        const delayListeners = new Map();
        const thisProp = "this";
        Object.defineProperty(obj, thisProp, {
          get() {
            return obj;
          },
        });
        Object.defineProperty(obj, "define", {
          value: (...props) => registerProperties(obj, ...props),
        });
        Object.defineProperty(obj, "on", {
          value: (
            /**@type string */ prop,
            listener,
            delay = false,
            additional
          ) => {
            let l = delay ? delayListeners : atonceListeners;
            if (!l.has(prop)) {
              l.set(prop, new Map());
            }
            l.get(prop).set(listener, additional);
            if (delay && delayDispatcher?.delayListeners) {
              delayDispatcher.delayListeners.set(listener, additional);
            }
            delayDispatcher.count++;
          },
        });

        Object.defineProperty(obj, "off", {
          value: (prop, listener, delay = false) => {
            let l = delay ? delayListeners : atonceListeners;
            if (!l.has(prop)) {
              return;
            }
            l.get(prop).delete(listener);
            if (delay && delayDispatcher?.delayListeners) {
              delayDispatcher.delayListeners.delete(listener);
            }
            delayDispatcher.count--;
          },
        });

        Object.defineProperty(obj, "clearOn", {
          value: (delay) => {
            let l = delay ? delayListeners : atonceListeners;
            delayDispatcher.count -= l.size;
            if (delay && delayDispatcher?.delayListeners) {
              l.forEach((_, listener) => {
                delayDispatcher.delayListeners.delete(listener);
              });
            }
            l.clear();
            // for (let p in obj) {
            //   obj[p].clearOn?.(delay)
            // }
          },
        });
        Object.defineProperty(obj, "dispose", {
          value: () => {
            obj.clearOn(false);
            obj.clearOn(true);
          },
        });
        Object.defineProperty(obj, "hasOn", {
          value: (prop, delay = false) => {
            let l = delay ? delayListeners : atonceListeners;
            return l.has(prop);
          },
        });

        Object.defineProperty(obj, "raise", {
          value: (prop, newValue, oldValue, delay = false) => {
            if (prop !== thisProp) {
              obj.raise(thisProp, obj, obj, delay);
            }
            let l = delay ? delayListeners : atonceListeners;
            if (!l.has(prop)) {
              return;
            }
            for (const [listener, _] of l.get(prop)) {
              listener(newValue, oldValue);
            }
          },
        });
      };

      const registerElement = (tagName, /**@type { string } */ constructor) => {
        const elementClassName = `HTML${
          constructor || getNameFromTagName(tagName)
        }Element`;
        constructor = constructor || "Object";
        eval(`
    class ${elementClassName} extends HTMLElement{
      constructor(){
        super()
        const shadow = this.attachShadow({mode:'open'})
        const template = document.getElementById('${tagName}')
        if(!template || template.tagName !== 'TEMPLATE' ){
          throw new Error('Define Template')
        }
        this.template_ = template
        this.shadow_ = shadow
        this.model_ = new ${constructor}()
        this.model_.components = { host: this.shadow_ }
        if(this.context && this.hasAttribute('model.')){
          const modeExp = this.getAttribute('model.')
          this.model = evalInContext(modeExp, this.context)
        }else if(this.modelBeforeInit){
          this.model = this.modelBeforeInit
        }else{
          this.model =  {}
        }
      }

      rebuildView(){
        this.shadow_.innerHTML = ''
        const instance = document.importNode(this.template_.content, true)
        this.shadow_.appendChild(instance)
      }
  
      get model(){
        return this.model_
      }
  
      set model(value){
        if(value?.on){
          this.model_ = value || {}
          this.model_.components = { host: this.shadow_ , ...this.model_.components||{}}
        }else{
          //combine code behind with model
          Object.assign(this.model_, value)
        }
        this.shadow_.context = this.model_ 
        this.rebuildView()
      }
  
      updateModel(value){
        this.model = value
        this.connectedCallback()
      }
      
      connectedCallback(){
        binding(this.shadow_)
        if(this.model_.launch){
          this.model_.launch()
        } 
      }
    }
    customElements.define('${tagName}', ${elementClassName})
    `);
      };
      return {
        registerElement,
        registerProperties,
        evalInContext,
        delayDispatcher,
      };
    })();

    const sleep = (timeout) =>
      new Promise((resolve) => setTimeout(resolve, timeout));

    class AppBase {
      async launch() {
        if (this.launched) {
          return;
        }
        this.launched = true;
        this.storage = this.initStorage_();
        this.data = await this.initData(window.appData);
        window.app = this;
        await this.start();
      }

      async registerStorageProperties(...props) {
        if (!this.storage) {
          return;
        }
        let asyncTimeout = 50;
        const bgTimeout = 200;
        for (const [prop, defaultValue, onchange] of props) {
          let propValue;
          let valueModified = false;
          let successLoadFromStorage = false;
          let loadFunc;
          let bgLoad = false;
          const mergeValue = (savedValue) => {
            if (successLoadFromStorage) {
              return;
            }
            successLoadFromStorage = true;
            if (!valueModified) {
              valueModified = true;
              propValue = savedValue;
            } else {
              // merge strategy
              propValue = savedValue;
            }
            if (bgLoad && onchange) {
              onchange();
            }
          };
          loadFunc = async () => {
            const jsonStr = await this.storage.getItem(prop);
            let savedValue;
            if (!jsonStr) {
              savedValue = defaultValue;
            } else {
              try {
                savedValue = JSON.parse(jsonStr);
              } catch {
                savedValue = defaultValue;
              }
            }
            mergeValue(savedValue);
          };
          const tryLoad = async () => {
            bgLoad = true;
            const func = loadFunc;
            loadFunc = null;
            await Promise.race([
              func(),
              sleep(bgTimeout).then(() => {
                if (!successLoadFromStorage) {
                  loadFunc = func;
                }
              }),
            ]);
          };
          await Promise.race([
            loadFunc(),
            sleep(asyncTimeout).then(() => {
              if (!valueModified) {
                propValue = defaultValue;
                valueModified = true;
                asyncTimeout = 0;
              }
            }),
          ]);
          Object.defineProperty(this, prop, {
            get() {
              if (loadFunc) {
                tryLoad();
              }
              return propValue;
            },
            set(newValue) {
              propValue = newValue;
              if (successLoadFromStorage) {
                this.storage.setItem(prop, JSON.stringify(propValue));
              }
            },
          });
        }
      }

      initStorage_() {
        if (window.$localStorage) {
          return window.$localStorage;
        }
        try {
          const s = window.localStorage;
          return s;
        } catch {
          return {
            getItem: () => "",
            setItem: () => true,
          };
        }
      }

      async initData(data) {
        return data;
      }

      async start() {
        console.log("start");
      }

      async pause() {
        console.log("pause");
      }

      async resume() {
        console.log("pause");
      }

      async stop() {
        console.log("stop");
      }
    }

    window.onload = async () => {
      let currentClass = App;
      while (true) {
        let baseClass = Object.getPrototypeOf(currentClass);
        if (
          !baseClass ||
          Object.getPrototypeOf(Object) === Object.getPrototypeOf(currentClass)
        ) {
          break;
        }
        currentClass = baseClass;
      }
      Object.setPrototypeOf(currentClass.prototype, AppBase.prototype);
      for (const template of document.querySelectorAll(
        "template[id][view-model]"
      )) {
        const tagName = template.getAttribute("id");
        if (!tagName) {
          continue;
        }
        const codeBehind = template.getAttribute("view-model");
        registerElement(tagName, codeBehind);
      }
      delayDispatcher.start();
    };
  </script>

  <style>
    html,
    body {
      height: 100%;
      margin: 0;
    }
  </style>

  <body>
    <app-main></app-main>

    <template id="h-stack" view-model>
      <slot></slot>
      <style>
        :host {
          display: flex;
          flex-direction: row;
        }
      </style>
    </template>
    <template id="v-stack" view-model>
      <slot></slot>
      <style>
        :host {
          display: flex;
          flex-direction: column;
        }
      </style>
    </template>
    <template id="hv-stack" view-model>
      <slot></slot>
      <style>
        :host {
          display: flex;
          flex-direction: column;
        }

        @media (orientation: landscape) {
          :host {
            flex-direction: row;
          }
        }
      </style>
    </template>

    <template id="vh-stack" view-model>
      <slot></slot>
      <style>
        :host {
          display: flex;
          flex-direction: row;
        }

        @media (orientation: landscape) {
          :host {
            flex-direction: column;
          }
        }
      </style>
    </template>

    <template id="h-square" view-model>
      <slot></slot>
      <style>
        :host {
          width: 100vw;
          height: 100vw;
        }

        @media (orientation: landscape) {
          :host {
            width: 100vh;
            height: 100vh;
          }
        }
      </style>
    </template>

    <template id="h-spacer" view-model>
      <slot></slot>
      <style>
        :host {
          flex: 1;
          display: flex;
        }
      </style>
    </template>

    <template id="h-text" view-model>
      <span inner-text$.="content"></span>
      <style>
        :host {
          flex: 1;
          display: flex;
          align-items: center;
          place-content: center;
        }
      </style>
    </template>

    <template id="play-button" view-model>
      <span id="btnPlay" class="play-button" class-pause.="isPlaying"></span>
      <style>
        :host {
          display: block;
          border-radius: 5px;
          padding: 3px 10px;
          background-color: #fff4;
        }

        .play-button {
          display: block;
          width: 100%;
          height: 100%;
          background-color: var(--color);
          clip-path: polygon(25% 10%, 25% 90%, 95% 50%, 25% 10%);
          transition: 200ms all ease-in-out;
        }

        .play-button.pause {
          clip-path: polygon(
            60% 50%,
            20% 20%,
            20% 80%,
            60% 50%,
            60% 80%,
            80% 80%,
            80% 20%,
            60% 20%
          );
        }
      </style>
    </template>

    <template id="menu-bar" view-model>
      <h-stack>
        <div class-hidden.="!item.show" class="menu-item" for.="item of menus">
          <span inner-text$.="item.name" onclick.="item.onclick()"></span>
        </div>
      </h-stack>
      <style>
        :host {
          display: block;
        }

        h-stack {
          overflow: hidden;
        }

        .menu-item {
          margin: 5px;
          background-color: var(--menu-background-color);
          border-radius: 4px;
          padding: 2px 5px;
          color: var(--menu-color);
          display: flex;
          justify-content: center;
          flex: 1;
        }

        .menu-item > span {
          display: block;
          text-overflow: ellipsis;
          white-space: pre;
          overflow: hidden;
          max-width: 6em;
        }

        .hidden {
          display: none;
        }
      </style>
    </template>

    <script>
      class MenuItem {
        constructor(name = "", onclick = null, show = true) {
          registerProperties(this, "name", "show");
          this.name = name;
          this.show = show;
          this.onclick = onclick;
        }
      }
    </script>

    <template id="modal-panel" view-model="Modal">
      <div>
        <span
          class="toastMessage"
          if.="toastMessage"
          inner-text$.="toastMessage"
        ></span>
        <div if.="open" class="modal-wraper" onclick.="close()">
          <div class="modal" onclick="event.stopPropagation()">
            <div class="title">
              <span inner-text$.="title"></span>
            </div>
            <div class="body">
              <div if.="items?.length">
                <div
                  class="item"
                  for.="item of items"
                  class-highlight.="item === selectedItem"
                  onclick.="close(item)"
                >
                  <span
                    inner-text$.="options.itemName?item[options.itemName]:item"
                  ></span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <style>
        .hidden {
          /* left: -100%; */
          /* transition: ease-in-out 0.05s left; */
          display: none;
        }

        .toastMessage {
          color: var(--toast-color, #eee);
          background-color: var(--toast-background-color, #0008);
          position: fixed;
          bottom: 0;
          margin: 20px auto;
          left: 50%;
          transform: translate(-50%, 0);
          padding: 5px 20px;
          border-radius: 4px;
          text-align: center;
          backdrop-filter: blur(5px);
        }

        .modal-wraper {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .modal {
          background: #fff;
          border-radius: 10px;
          padding: 10px;
          width: 90%;
          max-height: 90%;
          box-shadow: 3px 3px 5px;
        }

        .modal .title {
          font-size: large;
          margin: 5px 0;
          font-weight: bold;
        }

        .modal .body {
          margin: 5px 0;
        }

        .modal .foot {
          margin: 5px 0;
        }

        .item {
          margin: 8px 0;
          background: #0002;
          padding: 5px;
          border-radius: 8px;
        }

        .item.highlight {
          background: #0008;
          color: white;
        }
      </style>
    </template>
    <script>
      class Modal {
        constructor() {
          /**@type { Object.<string,HTMLElement> } */
          this.components;
          /**@type { Storage | {  } } */
          this.storage;
          registerProperties(
            this,
            "toastMessage",
            "title",
            "items",
            "selectedItem",
            "open",
            "options"
          );
        }
        toast(/**@string */ msg, /**@type number */ timeout = 1000, task) {
          return new Promise(async (resolve) => {
            this.toastMessage = msg;
            await task;
            setTimeout(() => {
              this.toastMessage = null;
              resolve();
            }, timeout);
          });
        }

        close(result) {
          if (!this.resolveTask) {
            return;
          }
          if (this.options.requilred && !result) {
            return;
          }
          this.open = undefined;
          this.resolveTask.resolve(result);
        }

        select(
          /** @type string */ msg,
          /** @type [any] */ values = [],
          defaultIdx = 0,
          opt = undefined
        ) {
          if (this.resolveTask) {
            const { resolve, reject } = this.resolveTask;
            this.resolveTask = undefined;
            reject();
          }
          this.title = msg;
          this.items = values;
          this.selectedItem = values[defaultIdx];
          this.options = opt || {};
          this.open = true;
          return new Promise(
            (resolve, reject) => (this.resolveTask = { resolve, reject })
          );
        }
      }
    </script>
    <template id="pop-up" view-model="Popup">
      <div class="popup">
        <slot></slot>
      </div>
      <style>
        :host {
          display: block;
          position: relative;
          left: 0;
          top: 0;
          bottom: 0;
          right: 0;
          position: fixed;
          background: #0008;
          backdrop-filter: blur(5px);
        }

        .popup {
          max-width: 99%;
          max-height: 99%;
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
        }
      </style>
    </template>
    <script>
      class Popup {}
    </script>
  </body>
</html>
