<html>
<meta charset="utf-8" />

<script src="https://cdn.jsdelivr.net/npm/@json-editor/json-editor@2.9.0-beta.0/dist/nonmin/jsoneditor.js"></script>

<script>
  class ResizeWatcher {
    dispose() {
      this.target_.removeEventListener("resize", this.onResize_);
    }

    constructor(target = window, delay = 0) {
      /** @type Window & typeof globalThis */
      this.target_ = target;
      this.onResize_ = this.onResize_.bind(this);
      this.target_.addEventListener("resize", this.onResize_);
      this.resizeThreshold_ = 10;
      this.callbacks_ = [];
      this.isWatching_ = false;
      this.checkThreshold_ = 200;
      this.delay_ = delay;
    }

    register(callback) {
      callback && this.callbacks_.push(callback);
      if (!this.isWatching_) {
        this.isWatching_ = true;
        this.lastCheckTime_ = 0;
        this.lastW_ = this.target_.innerWidth;
        this.lastH_ = this.target_.innerHeight;
      }
    }

    unregister(callback) {
      if (!callback) {
        return;
      }
      const idx = this.callbacks_.findIndex((c) => c === callback);
      if (idx < 0) {
        return;
      }
      this.callbacks_.splice(idx, 1);
      if (this.callbacks_.length === 0) {
        this.isWatching_ = false;
      }
    }

    onResize_(/** @type UIEvent */ ev) {
      if (!this.isWatching_) {
        return;
      }
      const now = Date.now();
      if (now - this.lastCheckTime_ < this.checkThreshold_) {
        return;
      }
      this.lastCheckTime_ = now;
      const raise = () => {
        const w = this.target_.innerWidth;
        const h = this.target_.innerHeight;

        if (
          Math.abs(this.lastW_ - w) < this.resizeThreshold_ &&
          Math.abs(this.lastH_ - h) < this.resizeThreshold_
        ) {
          return;
        }
        this.lastW_ = w;
        this.lastH_ = h;
        for (const callback of this.callbacks_) {
          callback(w, h);
        }
      };
      if (!this.delay_) {
        raise();
      } else {
        setTimeout(() => {
          raise();
        }, this.delay_);
      }
    }
  }

  const Api = {
    appService: window.os.app,
    localStorage: window.os.localStorage,
  };
  // javascript-astar 0.4.1
  // http://github.com/bgrins/javascript-astar
  // Freely distributable under the MIT License.
  // Implements the astar search algorithm in javascript using a Binary Heap.
  // Includes Binary Heap (with modifications) from Marijn Haverbeke.
  // http://eloquentjavascript.net/appendix2.html

  const { astarG, astar } = (function () {
    function pathTo(node) {
      var curr = node;
      var path = [];
      while (curr.parent) {
        path.unshift(curr);
        curr = curr.parent;
      }
      return path;
    }

    function getHeap() {
      return new BinaryHeap(function (node) {
        return node.f;
      });
    }

    var astar = {
      /**
      * Perform an A* Search on a graph given a start and end node.
      * @param {Graph} graph
      * @param {GridNode} start
      * @param {GridNode} end
      * @param {Object} [options]
      * @param {bool} [options.closest] Specifies whether to return the
                 path to the closest node if the target is unreachable.
      * @param {Function} [options.heuristic] Heuristic function (see
      *          astar.heuristics).
      */
      search: function (graph, start, end, options) {
        graph.cleanDirty();
        options = options || {};
        var heuristic = options.heuristic || astar.heuristics.manhattan;
        var closest = options.closest || false;

        var openHeap = getHeap();
        var closestNode = start; // set the start node to be the closest if required

        start.h = heuristic(start, end);
        graph.markDirty(start);

        openHeap.push(start);

        while (openHeap.size() > 0) {
          // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
          var currentNode = openHeap.pop();

          // End case -- result has been found, return the traced path.
          if (currentNode === end) {
            return pathTo(currentNode);
          }

          // Normal case -- move currentNode from open to closed, process each of its neighbors.
          currentNode.closed = true;

          // Find all neighbors for the current node.
          var neighbors = graph.neighbors(currentNode);

          for (var i = 0, il = neighbors.length; i < il; ++i) {
            var neighbor = neighbors[i];

            if (neighbor.closed || neighbor.isWall()) {
              // Not a valid node to process, skip to next neighbor.
              continue;
            }

            // The g score is the shortest distance from start to current node.
            // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.
            var gScore = currentNode.g + neighbor.getCost(currentNode);
            var beenVisited = neighbor.visited;

            if (!beenVisited || gScore < neighbor.g) {
              // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
              neighbor.visited = true;
              neighbor.parent = currentNode;
              neighbor.h = neighbor.h || heuristic(neighbor, end);
              neighbor.g = gScore;
              neighbor.f = neighbor.g + neighbor.h;
              graph.markDirty(neighbor);
              if (closest) {
                // If the neighbour is closer than the current closestNode or if it's equally close but has
                // a cheaper path than the current closest node then it becomes the closest node
                if (
                  neighbor.h < closestNode.h ||
                  (neighbor.h === closestNode.h && neighbor.g < closestNode.g)
                ) {
                  closestNode = neighbor;
                }
              }

              if (!beenVisited) {
                // Pushing to heap will put it in proper place based on the 'f' value.
                openHeap.push(neighbor);
              } else {
                // Already seen the node, but since it has been rescored we need to reorder it in the heap
                openHeap.rescoreElement(neighbor);
              }
            }
          }
        }

        if (closest) {
          return pathTo(closestNode);
        }

        // No result was found - empty array signifies failure to find path.
        return [];
      },
      // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
      heuristics: {
        manhattan: function (pos0, pos1) {
          var d1 = Math.abs(pos1.x - pos0.x);
          var d2 = Math.abs(pos1.y - pos0.y);
          return d1 + d2;
        },
        diagonal: function (pos0, pos1) {
          var D = 1;
          var D2 = Math.sqrt(2);
          var d1 = Math.abs(pos1.x - pos0.x);
          var d2 = Math.abs(pos1.y - pos0.y);
          return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
        },
      },
      cleanNode: function (node) {
        node.f = 0;
        node.g = 0;
        node.h = 0;
        node.visited = false;
        node.closed = false;
        node.parent = null;
      },
    };

    /**
     * A graph memory structure
     * @param {Array} gridIn 2D array of input weights
     * @param {Object} [options]
     * @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed
     */
    function Graph(gridIn, options) {
      options = options || {};
      this.nodes = [];
      this.diagonal = !!options.diagonal;
      this.grid = [];
      for (var x = 0; x < gridIn.length; x++) {
        this.grid[x] = [];

        for (var y = 0, row = gridIn[x]; y < row.length; y++) {
          var node = new GridNode(x, y, row[y]);
          this.grid[x][y] = node;
          this.nodes.push(node);
        }
      }
      this.init();
    }

    Graph.prototype.init = function () {
      this.dirtyNodes = [];
      for (var i = 0; i < this.nodes.length; i++) {
        astar.cleanNode(this.nodes[i]);
      }
    };

    Graph.prototype.cleanDirty = function () {
      for (var i = 0; i < this.dirtyNodes.length; i++) {
        astar.cleanNode(this.dirtyNodes[i]);
      }
      this.dirtyNodes = [];
    };

    Graph.prototype.markDirty = function (node) {
      this.dirtyNodes.push(node);
    };

    Graph.prototype.neighbors = function (node) {
      var ret = [];
      var x = node.x;
      var y = node.y;
      var grid = this.grid;

      // West
      if (grid[x - 1] && grid[x - 1][y]) {
        ret.push(grid[x - 1][y]);
      }

      // East
      if (grid[x + 1] && grid[x + 1][y]) {
        ret.push(grid[x + 1][y]);
      }

      // South
      if (grid[x] && grid[x][y - 1]) {
        ret.push(grid[x][y - 1]);
      }

      // North
      if (grid[x] && grid[x][y + 1]) {
        ret.push(grid[x][y + 1]);
      }

      if (this.diagonal) {
        // Southwest
        if (grid[x - 1] && grid[x - 1][y - 1]) {
          ret.push(grid[x - 1][y - 1]);
        }

        // Southeast
        if (grid[x + 1] && grid[x + 1][y - 1]) {
          ret.push(grid[x + 1][y - 1]);
        }

        // Northwest
        if (grid[x - 1] && grid[x - 1][y + 1]) {
          ret.push(grid[x - 1][y + 1]);
        }

        // Northeast
        if (grid[x + 1] && grid[x + 1][y + 1]) {
          ret.push(grid[x + 1][y + 1]);
        }
      }

      return ret;
    };

    Graph.prototype.toString = function () {
      var graphString = [];
      var nodes = this.grid;
      for (var x = 0; x < nodes.length; x++) {
        var rowDebug = [];
        var row = nodes[x];
        for (var y = 0; y < row.length; y++) {
          rowDebug.push(row[y].weight);
        }
        graphString.push(rowDebug.join(" "));
      }
      return graphString.join("\n");
    };

    function GridNode(x, y, weight) {
      this.x = x;
      this.y = y;
      this.weight = weight;
    }

    GridNode.prototype.toString = function () {
      return "[" + this.x + " " + this.y + "]";
    };

    GridNode.prototype.getCost = function (fromNeighbor) {
      // Take diagonal weight into consideration.
      if (
        fromNeighbor &&
        fromNeighbor.x != this.x &&
        fromNeighbor.y != this.y
      ) {
        return this.weight * 1.41421;
      }
      return this.weight;
    };

    GridNode.prototype.isWall = function () {
      return this.weight === 0;
    };

    function BinaryHeap(scoreFunction) {
      this.content = [];
      this.scoreFunction = scoreFunction;
    }

    BinaryHeap.prototype = {
      push: function (element) {
        // Add the new element to the end of the array.
        this.content.push(element);

        // Allow it to sink down.
        this.sinkDown(this.content.length - 1);
      },
      pop: function () {
        // Store the first element so we can return it later.
        var result = this.content[0];
        // Get the element at the end of the array.
        var end = this.content.pop();
        // If there are any elements left, put the end element at the
        // start, and let it bubble up.
        if (this.content.length > 0) {
          this.content[0] = end;
          this.bubbleUp(0);
        }
        return result;
      },
      remove: function (node) {
        var i = this.content.indexOf(node);

        // When it is found, the process seen in 'pop' is repeated
        // to fill up the hole.
        var end = this.content.pop();

        if (i !== this.content.length - 1) {
          this.content[i] = end;

          if (this.scoreFunction(end) < this.scoreFunction(node)) {
            this.sinkDown(i);
          } else {
            this.bubbleUp(i);
          }
        }
      },
      size: function () {
        return this.content.length;
      },
      rescoreElement: function (node) {
        this.sinkDown(this.content.indexOf(node));
      },
      sinkDown: function (n) {
        // Fetch the element that has to be sunk.
        var element = this.content[n];

        // When at 0, an element can not sink any further.
        while (n > 0) {
          // Compute the parent element's index, and fetch it.
          var parentN = ((n + 1) >> 1) - 1;
          var parent = this.content[parentN];
          // Swap the elements if the parent is greater.
          if (this.scoreFunction(element) < this.scoreFunction(parent)) {
            this.content[parentN] = element;
            this.content[n] = parent;
            // Update 'n' to continue at the new position.
            n = parentN;
          }
          // Found a parent that is less, no need to sink any further.
          else {
            break;
          }
        }
      },
      bubbleUp: function (n) {
        // Look up the target element and its score.
        var length = this.content.length;
        var element = this.content[n];
        var elemScore = this.scoreFunction(element);

        while (true) {
          // Compute the indices of the child elements.
          var child2N = (n + 1) << 1;
          var child1N = child2N - 1;
          // This is used to store the new position of the element, if any.
          var swap = null;
          var child1Score;
          // If the first child exists (is inside the array)...
          if (child1N < length) {
            // Look it up and compute its score.
            var child1 = this.content[child1N];
            child1Score = this.scoreFunction(child1);

            // If the score is less than our element's, we need to swap.
            if (child1Score < elemScore) {
              swap = child1N;
            }
          }

          // Do the same checks for the other child.
          if (child2N < length) {
            var child2 = this.content[child2N];
            var child2Score = this.scoreFunction(child2);
            if (child2Score < (swap === null ? elemScore : child1Score)) {
              swap = child2N;
            }
          }

          // If the element needs to be moved, swap it, and continue.
          if (swap !== null) {
            this.content[n] = this.content[swap];
            this.content[swap] = element;
            n = swap;
          }
          // Otherwise, we are done.
          else {
            break;
          }
        }
      },
    };

    return {
      astar: astar,
      astarG: Graph,
    };
  })();

  class MazeBuilder {
    constructor(width, height) {
      this.width = width;
      this.height = height;

      this.cols = 2 * this.width + 1;
      this.rows = 2 * this.height + 1;

      this.maze = this.initArray([]);

      // place initial walls
      this.maze.forEach((row, r) => {
        row.forEach((cell, c) => {
          switch (r) {
            case 0:
            case this.rows - 1:
              this.maze[r][c] = ["wall"];
              break;

            default:
              if (r % 2 == 1) {
                if (c == 0 || c == this.cols - 1) {
                  this.maze[r][c] = ["wall"];
                }
              } else if (c % 2 == 0) {
                this.maze[r][c] = ["wall"];
              }
          }
        });

        if (r == 0) {
          // place exit in top row
          let doorPos = this.posToSpace(this.rand(1, this.width));
          this.maze[r][doorPos] = ["door", "exit"];
        }

        if (r == this.rows - 1) {
          // place entrance in bottom row
          let doorPos = this.posToSpace(this.rand(1, this.width));
          this.maze[r][doorPos] = ["door", "entrance"];
        }
      });

      // start partitioning
      this.partition(1, this.height - 1, 1, this.width - 1);
    }

    initArray(value) {
      return new Array(this.rows)
        .fill()
        .map(() => new Array(this.cols).fill(value));
    }

    rand(min, max) {
      return min + Math.floor(Math.random() * (1 + max - min));
    }

    posToSpace(x) {
      return 2 * (x - 1) + 1;
    }

    posToWall(x) {
      return 2 * x;
    }

    inBounds(r, c) {
      if (
        typeof this.maze[r] == "undefined" ||
        typeof this.maze[r][c] == "undefined"
      ) {
        return false; // out of bounds
      }
      return true;
    }

    shuffle(array) {
      // sauce: https://stackoverflow.com/a/12646864
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    partition(r1, r2, c1, c2) {
      // create partition walls
      // ref: https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method

      let horiz, vert, x, y, start, end;

      if (r2 < r1 || c2 < c1) {
        return false;
      }

      if (r1 == r2) {
        horiz = r1;
      } else {
        x = r1 + 1;
        y = r2 - 1;
        start = Math.round(x + (y - x) / 4);
        end = Math.round(x + (3 * (y - x)) / 4);
        horiz = this.rand(start, end);
      }

      if (c1 == c2) {
        vert = c1;
      } else {
        x = c1 + 1;
        y = c2 - 1;
        start = Math.round(x + (y - x) / 3);
        end = Math.round(x + (2 * (y - x)) / 3);
        vert = this.rand(start, end);
      }

      for (let i = this.posToWall(r1) - 1; i <= this.posToWall(r2) + 1; i++) {
        for (
          let j = this.posToWall(c1) - 1;
          j <= this.posToWall(c2) + 1;
          j++
        ) {
          if (i == this.posToWall(horiz) || j == this.posToWall(vert)) {
            this.maze[i][j] = ["wall"];
          }
        }
      }

      let gaps = this.shuffle([true, true, true, false]);

      // create gaps in partition walls

      if (gaps[0]) {
        let gapPosition = this.rand(c1, vert);
        this.maze[this.posToWall(horiz)][this.posToSpace(gapPosition)] = [];
      }

      if (gaps[1]) {
        let gapPosition = this.rand(vert + 1, c2 + 1);
        this.maze[this.posToWall(horiz)][this.posToSpace(gapPosition)] = [];
      }

      if (gaps[2]) {
        let gapPosition = this.rand(r1, horiz);
        this.maze[this.posToSpace(gapPosition)][this.posToWall(vert)] = [];
      }

      if (gaps[3]) {
        let gapPosition = this.rand(horiz + 1, r2 + 1);
        this.maze[this.posToSpace(gapPosition)][this.posToWall(vert)] = [];
      }

      // recursively partition newly created chambers

      this.partition(r1, horiz - 1, c1, vert - 1);
      this.partition(horiz + 1, r2, c1, vert - 1);
      this.partition(r1, horiz - 1, vert + 1, c2);
      this.partition(horiz + 1, r2, vert + 1, c2);
    }

    isGap(...cells) {
      return cells.every((array) => {
        let row, col;
        [row, col] = array;
        if (this.maze[row][col].length > 0) {
          if (!this.maze[row][col].includes("door")) {
            return false;
          }
        }
        return true;
      });
    }

    countSteps(array, r, c, val, stop) {
      if (!this.inBounds(r, c)) {
        return false; // out of bounds
      }

      if (array[r][c] <= val) {
        return false; // shorter route already mapped
      }

      if (!this.isGap([r, c])) {
        return false; // not traversable
      }

      array[r][c] = val;

      if (this.maze[r][c].includes(stop)) {
        return true; // reached destination
      }

      this.countSteps(array, r - 1, c, val + 1, stop);
      this.countSteps(array, r, c + 1, val + 1, stop);
      this.countSteps(array, r + 1, c, val + 1, stop);
      this.countSteps(array, r, c - 1, val + 1, stop);
    }

    getKeyLocation() {
      let fromEntrance = this.initArray();
      let fromExit = this.initArray();

      this.totalSteps = -1;

      for (let j = 1; j < this.cols - 1; j++) {
        if (this.maze[this.rows - 1][j].includes("entrance")) {
          this.countSteps(fromEntrance, this.rows - 1, j, 0, "exit");
        }
        if (this.maze[0][j].includes("exit")) {
          this.countSteps(fromExit, 0, j, 0, "entrance");
        }
      }

      let fc = -1,
        fr = -1;

      this.maze.forEach((row, r) => {
        row.forEach((cell, c) => {
          if (typeof fromEntrance[r][c] == "undefined") {
            return;
          }
          let stepCount = fromEntrance[r][c] + fromExit[r][c];
          if (stepCount > this.totalSteps) {
            fr = r;
            fc = c;
            this.totalSteps = stepCount;
          }
        });
      });

      return [fr, fc];
    }

    placeKey() {
      let fr, fc;
      [fr, fc] = this.getKeyLocation();

      this.maze[fr][fc] = ["key"];
    }

    display(id) {
      this.parentDiv = document.getElementById(id);

      if (!this.parentDiv) {
        alert(
          'Cannot initialise maze - no element found with id "' + id + '"'
        );
        return false;
      }

      while (this.parentDiv.firstChild) {
        this.parentDiv.removeChild(this.parentDiv.firstChild);
      }

      const container = document.createElement("div");
      container.id = "maze";
      container.dataset.steps = this.totalSteps;

      this.maze.forEach((row) => {
        let rowDiv = document.createElement("div");
        row.forEach((cell) => {
          let cellDiv = document.createElement("div");
          if (cell) {
            cellDiv.className = cell.join(" ");
          }
          rowDiv.appendChild(cellDiv);
        });
        container.appendChild(rowDiv);
      });

      this.parentDiv.appendChild(container);

      return true;
    }
  }
  // import { astarG, astar } from '../libs/astar.mjs'
  Array.prototype.rsort =
    Array.prototype.rsort ||
    function () {
      let a = this.map((i) => [i, Math.random()]);
      let b = a.sort((i, j) => i[1] - j[1]);
      return b.map((i) => i[0]);
    };
  const generateRandomName = (length) => {
    return Array.from({ length }, () =>
      String.fromCodePoint(Math.round(Math.random() * 500) + 0x4e00 + 0)
    ).join("");
  };

  class SessionGenerator {
    async generate(
      width,
      height,
      floorCount = 1,
      pEntries = 0,
      pUnits = 0,
      pFriendlyUnits = 0,
      moneyTimes = 10,
      skills = []
    ) {
      width = Math.floor((width - 1) / 2);
      height = Math.floor((height - 1) / 2);
      const PLAYER_GROUP = 1;
      let floorEntries = [];
      let randomEntries = [];
      let BUFF = Math.floor((Math.random() * (floorCount - 1)) / 2) + 1;
      let maxLevel = floorCount;
      let units = [];
      let nskills = skills.filter((s) => !s.positive);
      let pskills = skills.filter((s) => s.positive);
      const props = ["jin", "mu", "shui", "huo", "tu"];
      const updateRandomUnit = (unit, ave, min, max) => {
        const dd = Math.max(0, ave - min);
        const di = Math.max(0, max - ave);
        const rP = (() => {
          if (dd === 0 && di === 0) {
            return () => ave;
          }
          const d = dd + di;
          const pdd = ((di + 1) * ave) / d / d;
          const pdi = ((dd + 1) * ave) / d / d;
          return () =>
            ave -
            (Math.random() < pdd ? Math.floor(Math.random() * dd) : 0) +
            (Math.random() < pdi ? Math.floor(Math.random() * di) : 0);
        })();
        unit.name = generateRandomName(2);
        delete unit.inCorner;
        const skillsCount = Math.max(
          unit.levelTimes > 1 ? 1 : 0,
          Math.floor(Math.random() * Math.log2(ave))
        );
        unit.money = Math.floor(
          (Math.random() *
            (skillsCount + 1) *
            (moneyTimes * (unit.inCorner ? 2 : 1)) *
            (unit.floor + 1)) /
          floorCount
        );
        unit.skills = [
          ...nskills
            .sort(() => Math.random() - 0.5)
            .slice(0, skillsCount)
            .map((s) => s.name),
          ...pskills
            .sort(() => Math.random() - 0.5)
            .slice(0, Math.random() * skillsCount)
            .map((s) => s.name),
        ];
        for (let prop of props) {
          unit[prop] = Math.min(maxLevel, Math.floor(rP()));
        }
      };
      let player = { mu: 1, group: PLAYER_GROUP };
      if (pUnits) {
        updateRandomUnit(player, 2, 1, 5);
      }
      let generateFloor =
        pUnits > 0
          ? () => "12345"[Math.floor(Math.random() * props.length)]
          : () => "1";
      const floors = Array.from({ length: floorCount }, (_, floor) => {
        const b = new MazeBuilder(width, height);
        let entrance;
        let exit;
        let map = [];
        const f = b.maze.map((column, y) =>
          column
            .map(([type, entry], x) => {
              const t = (() => {
                if (entry === "exit") {
                  exit = { floor, x, y };
                  return generateFloor();
                }
                if (entry === "entrance") {
                  entrance = { floor, x, y };
                  return generateFloor();
                }
                if (type) {
                  return "0";
                }
                return generateFloor();
              })();
              if (pEntries > 0 || pUnits > 0) {
                map[y] = map[y] || [];
                map[y][x] = t === "0" ? undefined : [];
                if (x > 0 && y > 0 && map[y][x] !== undefined) {
                  if (map[y - 1][x] !== undefined) {
                    map[y - 1][x].push({ x, y });
                    map[y][x].push({ x, y: y - 1 });
                  }
                  if (map[y][x - 1] !== undefined) {
                    map[y][x - 1].push({ x, y });
                    map[y][x].push({ x: x - 1, y: y });
                  }
                }
              }
              return t;
            })
            .join("")
        );
        const fd = {
          cells: f,
        };
        floorEntries.push([entrance, exit]);
        if (!pEntries && !pUnits) {
          return fd;
        }
        const graph = new astarG(
          map.map((column, y) =>
            column.map((c, x) => {
              return c !== undefined ? 1 : 0;
            })
          )
        );
        const result = astar.search(
          graph,
          graph.grid[entrance.y][entrance.x],
          graph.grid[exit.y][exit.x]
        );
        // console.log(map.map(l => l.map(c => c === undefined ? '-' : String(c)).join('')).join('\n'))
        // console.log(result)
        const floorGuarder = {
          floor,
          x: result[result.length - 2].y,
          y: result[result.length - 2].x,
          levelTimes: 3,
        };
        units.push(floorGuarder);
        const mainRoad = new Set([
          `${entrance.x}-${entrance.y}`,
          ...result.map((r) => `${r.y}-${r.x}`),
          `${exit.x}-${exit.y}`,
        ]);
        // console.log(mainRoad)
        let corners = [];
        let crosses = [];
        let others = [];
        let doors = [];
        let cellsCount = 0;
        for (let y = 0; y < map.length; y++) {
          for (let x = 0; x < map[0].length; x++) {
            if (
              map[y][x] === undefined ||
              (x === entrance.x && y === entrance.y) ||
              (x === exit.x && y === exit.y)
            ) {
              continue;
            }
            let group;
            let n = map[y][x].length;
            if (n === 1) {
              group = corners;
            } else if (n === 2) {
              group = others;
            } else {
              group = crosses;
              doors = doors.concat(
                map[y][x]
                  .map((i) => [
                    `${i.x}-${i.y}`,
                    [{ floor, x: i.x, y: i.y }, Math.random()],
                  ])
                  .filter((n) => !mainRoad.has(n[0]))
              );
            }
            if (x === floorGuarder.x && y === floorGuarder.y) {
              continue;
            }
            cellsCount++;
            group.push([{ floor, x, y }, Math.random()]);
          }
        }
        let doorsSet = new Map(doors);
        // console.log(mainRoad)
        // console.log(doorsSet)
        corners = corners.filter(([{ x, y }]) => !doorsSet.has(`${x}-${y}`));
        crosses = crosses.filter(([{ x, y }]) => !doorsSet.has(`${x}-${y}`));
        others = others.filter(([{ x, y }]) => !doorsSet.has(`${x}-${y}`));
        doors = Array.from(doorsSet.values());
        // console.log(doors)
        corners.sort((i, j) => i[1] - j[1]);
        crosses.sort((i, j) => i[1] - j[1]);
        others.sort((i, j) => i[1] - j[1]);
        doors.sort((i, j) => i[1] - j[1]);
        let entriesCount = Math.floor(
          cellsCount * pEntries * (0.75 + Math.random() / 4)
        );
        let cornerEntries = corners.slice(0, entriesCount).map((s) => s[0]);
        entriesCount = entriesCount - cornerEntries.length;
        let othersEntries = others.slice(0, entriesCount).map((s) => s[0]);
        let unitsCount = Math.floor(
          cellsCount * pUnits * (0.75 + Math.random() / 4)
        );
        let doorUnits = doors.map((s) => s[0]);
        let cornersUnits = corners
          .slice(cornerEntries.length)
          .map((s) => s[0]);
        cornersUnits.forEach((u) => {
          u.inCorner = true;
          u.movable = true;
        });
        let otherUnits = others
          .slice(entriesCount, entriesCount + unitsCount)
          .map((s) => s[0]);
        otherUnits.forEach((u) => {
          u.movable = true;
          u.levelTimes = 1.5;
        });
        randomEntries = randomEntries
          .concat(cornerEntries)
          .concat(othersEntries);
        units = units
          .concat(doorUnits)
          .concat(cornersUnits)
          .concat(otherUnits);
        if (pFriendlyUnits > 0) {
          let nonGuaderUnits = [
            ...doorUnits,
            ...cornersUnits,
            ...otherUnits,
          ].rsort();
          nonGuaderUnits
            .slice(0, nonGuaderUnits.length * pFriendlyUnits)
            .forEach((u) => (u.group = PLAYER_GROUP));
        }
        return fd;
      });
      let start = floorEntries[0][0];
      let end = floorEntries[floorEntries.length - 1][1];
      units.forEach((unit) => {
        updateRandomUnit(
          unit,
          (unit.floor + 1) * (unit.levelTimes || 1),
          1,
          Math.max(((unit.floor + 1) * 3) / 2, unit.floor + 5)
        );
        delete unit.levelTimes;
      });
      if (randomEntries.length) {
        // randomEntries.sort(() => Math.random() - 0.5)
        randomEntries = randomEntries.map((e) => [
          e,
          1.5 * BUFF * (1 - 2 * Math.random()) + e.floor,
        ]);
        randomEntries = randomEntries.sort((i, j) => i[1] - j[1]);
        randomEntries = randomEntries.map((i) => i[0]);
      }
      let entries = Array.from(
        { length: floorEntries.length - 1 },
        (_, i) => [floorEntries[i][1], floorEntries[i + 1][0], true]
      ).concat(
        Array.from({ length: randomEntries.length / 2 }, (_, i) => [
          randomEntries[2 * i],
          randomEntries[2 * i + 1],
          false,
        ])
      );
      const session = {
        floors,
        start,
        end,
        args: {
          BUFF,
        },
        player,
        entries,
        units,
        maxLevel,
        skills,
      };
      return session;
    }
  }

  class OldModal {
    constructor(container) {
      this.container_ = container || document.body;
    }

    showModal(msg, onclose, input = null, hideButtons) {
      const panel = document.createElement("div");
      panel.className = "modal-panel";
      this.close = () => {
        this.container_.removeChild(panel);
      };
      const closeModal = (ok) => {
        this.close();
        onclose(ok);
      };
      panel.focus();
      panel.onclick = () => closeModal(false);
      const div = document.createElement("div");
      div.onclick = (ev) => ev.stopPropagation();
      const title = document.createElement("h1");
      title.innerText = msg;
      const btnGroups = document.createElement("div");
      btnGroups.classList.add("btn-groups");
      const btnOk = document.createElement("input");
      btnOk.type = "button";
      btnOk.value = "确定";
      btnOk.onclick = () => closeModal(true);
      const btnCancle = document.createElement("input");
      btnCancle.type = "button";
      btnCancle.value = "取消";
      btnCancle.onclick = () => closeModal(false);
      div.appendChild(title);
      if (input) {
        div.appendChild(input);
        div.addEventListener("keydown", (k) => {
          if (k && k.key === "Enter") {
            k.stopPropagation();
            closeModal(true);
            return;
          }
          if (k && k.key === "Escape") {
            k.stopPropagation();
            closeModal(false);
          }
        });
      }
      if (!hideButtons) {
        div.appendChild(btnGroups);
      }
      btnGroups.appendChild(btnOk);
      btnGroups.appendChild(btnCancle);
      panel.appendChild(div);
      this.container_.appendChild(panel);
      const focusEle = input || btnOk || btnCancle;
      focusEle.focus();
    }

    select(
        /** @type string */ msg,
        /** @type [any] */ values = [],
      defaultIdx = 0
    ) {
      return new Promise((resolve) => {
        const container = document.createElement("div");
        container.className = "value-items";
        for (let i = 0; i < values.length; i++) {
          let value = values[i];
          const item = document.createElement("div");
          item.innerText = value;
          item.className =
            "value-item " + (defaultIdx === i ? "current-value-item" : "");
          item.onclick = () => {
            this.close?.();
            resolve(i);
          };
          container.appendChild(item);
        }
        this.showModal(
          msg,
          (ok) => {
            if (ok) {
              resolve(defaultIdx);
            } else {
              resolve(null);
            }
          },
          container,
          true
        );
      });
    }

    prompt(/** @type string */ msg, /** @type any */ defValue = null, opt) {
      return new Promise((resolve) => {
        const txbInput = document.createElement("input");
        txbInput.type = "input";
        txbInput.value = defValue;
        if (opt) {
          txbInput.type = opt.type;
          txbInput.max = opt.max;
          txbInput.min = opt.min;
          txbInput.step = opt.step;
        }
        [("autocomplete", "autocorrect", "autocapitalize")].forEach((prop) =>
          txbInput.setAttribute(prop, "off")
        );
        ["spellcheck"].forEach((prop) =>
          txbInput.setAttribute(prop, "false")
        );
        txbInput.select();
        txbInput.focus();
        this.showModal(
          msg,
          (ok) => {
            if (ok) {
              resolve(txbInput.value);
            } else {
              resolve(null);
            }
          },
          txbInput
        );
      });
    }

    confirm(/** @type string */ msg) {
      return new Promise((resolve) => {
        this.showModal(msg, (ok) => resolve(!!ok));
      });
    }

    popup(/** @type HTMLElement */ ele, callback = null, showClose = true) {
      return new Promise((resolve) => {
        const panel = document.createElement("div");
        panel.className = "popup-panel";
        const closeModal = (ok) => {
          try {
            this.container_.removeChild(panel);
          } catch { }
          resolve(ok);
        };
        if (showClose) {
          const btnClose = document.createElement("span");
          // btnClose.innerText = '×';
          btnClose.classList.add("close");
          btnClose.onclick = () => closeModal(false);
          panel.appendChild(btnClose);
        }
        panel.appendChild(ele);
        this.container_.appendChild(panel);
        if (callback) {
          callback(closeModal);
        }
      });
    }

    toast(msg, timeout = 1000) {
      return new Promise((resolve) => {
        const panel = document.createElement("div");
        panel.className = "toast-panel";
        const div = document.createElement("div");
        panel.appendChild(div);
        const span = document.createElement("span");
        span.innerText = msg;
        div.appendChild(span);
        this.container_.appendChild(panel);
        setTimeout(() => {
          this.container_.removeChild(panel);
          resolve();
        }, timeout);
      });
    }
  }

  window.MazeBuilder = MazeBuilder;

  const customeStyles = `
.json-editor-btntype-toggle > span,
.json-editor-btn-edit_properties.json-editor-btntype-properties > span,
.json-editor-btn-moveup>span,
.json-editor-btn-movedown>span,
.json-editor-btn-add>span,
.json-editor-btn-subtract,
.json-editor-btn-delete>span
{
  display: none;
}

.json-editor-btntype-toggle::before{
  content: '⌲';
}

.json-editor-btn-edit_properties.json-editor-btntype-properties::before{
  content: '📝';
}

.json-editor-btn-moveup::before{
  content: '⌃';
}
.json-editor-btn-movedown::before{
  content: '⌵';
}

.json-editor-btn-delete::before{
  content: '-';
}

.json-editor-btn-add::before{
  content: '+';
}

div[data-theme="html"] .je-indented-panel{
  margin:0px 5px;
}

.je-header {
  margin: 0;
  font-size: 1rem;
}
`;

  const whenSchema = {
    type: "object",
    title: "触发器",
    properties: {
      tryEnter: { $ref: "#/$defs/triger" },
      enter: { $ref: "#/$defs/triger" },
      tryLeave: { $ref: "#/$defs/triger" },
      leave: { $ref: "#/$defs/triger" },
      defeat: { $ref: "#/$defs/triger" },
      win: { $ref: "#/$defs/triger" },
    },
    defaultProperties: [],
    $defs: {
      result: {
        type: "object",
        patternProperties: {
          "^((?!if|set|inc|msg|interrupt|get|lost).)*$": {
            type: "array",
            items: { $ref: "#/$defs/result" },
          },
          "^if$": { type: "string" },
          "^inc": { $ref: "#/$defs/inc" },
          "^set": { $ref: "#/$defs/set" },
          "^get": { $ref: "#/$defs/get" },
          "^lost": { $ref: "#/$defs/lost" },
          "^msg$": { type: "string" },
          "^interrupt$": { type: ["boolean", "string"] },
        },
        defaultProperties: ["if"],
        headerTemplate: "${self.if||' '}",
        options: {
          collapsed: true,
        },
      },
      triger: {
        options: {
          collapsed: true,
        },
        type: "array",
        items: {
          type: "object",
          headerTemplate: "${self.query||' '}",
          options: {
            collapsed: true,
          },
          properties: {
            query: { type: "string" },
            question: { type: "string" },
            answers: {
              anyOf: [
                { type: "string" },
                {
                  type: "array",
                  items: {
                    type: "string",
                    headerTemplate: " ",
                  },
                },
              ],
            },
            results: {
              type: "array",
              items: { $ref: "#/$defs/result" },
            },
            cancable: {
              type: "boolean",
            },
          },
        },
      },
      set: {
        type: "object",
        properties: {
          j: { type: ["null", "number", "string"] },
          m: { type: ["null", "number", "string"] },
          s: { type: ["null", "number", "string"] },
          h: { type: ["null", "number", "string"] },
          t: { type: ["null", "number", "string"] },
          mc: { type: ["null", "number", "string"] },
          g: { type: ["null", "number", "string"] },
          sp: { type: ["null", "string"] },
          gt: { type: ["null", "boolean", "string"] },
          d: { type: ["null", "boolean", "string"] },
          w: { type: ["null", "number", "string"] },
          x: { type: ["null", "number", "string"] },
          y: { type: ["null", "number", "string"] },
          f: { type: ["null", "number", "string"] },
        },
        defaultProperties: [],
      },
      inc: {
        type: "object",
        properties: {
          j: { type: ["null", "number", "string"] },
          m: { type: ["null", "number", "string"] },
          s: { type: ["null", "number", "string"] },
          h: { type: ["null", "number", "string"] },
          t: { type: ["null", "number", "string"] },
          mc: { type: ["null", "number", "string"] },
        },
        defaultProperties: [],
      },
      get: {
        type: "object",
        properties: {
          name: { type: "string" },
          count: { type: ["null", "number", "string"] },
          last: { type: ["null", "number", "string"] },
          cooldown: { type: ["null", "number", "string"] },
          level: { type: ["null", "number", "string"] },
          cast: { type: ["null", "number", "string"] },
          attackQuit: { type: ["null", "boolean", "string"] },
          soldable: { type: ["null", "boolean", "string"] },
          obj: { type: ["null", "boolean", "string"] },
          buffers: {
            type: "array",
            items: {
              type: "object",
              properties: {
                arg: { type: "string" },
                value: { type: ["number", "string"] },
              },
            },
          },
          positive: {
            type: "object",
            properties: {
              last: { type: ["null", "number", "string"] },
              cooldown: { type: ["null", "number", "string"] },
            },
          },
        },
        defaultProperties: ["name"],
      },
      lost: {
        type: "object",
        properties: {
          name: { type: "string" },
          count: { type: ["null", "number", "string"] },
        },
        defaultProperties: ["name"],
      },
    },
  };

  const CURRENT_SESSION_ID_KEY = "currentSessionId";
  const LAST_PLAYER_KEY = "lastPlayer";
  const LAST_EDITING_SESSION_INFOS_KEY = "lastEditingSessionInfos";
  const CALCULATE_PROPS_PREFIX = "@";
  const MID_GROUP = 0;
  const GROUP_A = 1;
  const GROUP_B = 2;
  const MAX_MEMS_COUNT = 3;
  const MAX_CONSOLEOUTS_COUNT = 10;
  const isEnemy = (g1, g2) => {
    if (!g1 || !g2) {
      return false;
    }
    return g1 !== g2;
  };
  const createEntryObj = (start, end, direction) => {
    let entry = {};
    registerProperties(entry, "start", "end", "direction");
    entry.start = start;
    entry.end = end;
    entry.direction = direction;
    return entry;
  };
  const tryUpdateInContext = (exp, context) => {
    if (Array.isArray(exp)) {
      return exp.map((e) => tryUpdateInContext(e, context));
    }
    if (exp?.startsWith?.(CALCULATE_PROPS_PREFIX)) {
      exp = exp.slice(CALCULATE_PROPS_PREFIX.length);
      if (exp.startsWith(CALCULATE_PROPS_PREFIX)) {
        exp = exp.slice(CALCULATE_PROPS_PREFIX.length);
        exp = "`" + exp.replace("{", "${") + "`";
      }
      return evalInContext(exp, context);
    }
    if (exp && typeof exp === "object") {
      let res = {};
      for (let p in exp) {
        res[tryUpdateInContext(p, context)] = tryUpdateInContext(
          exp[p],
          context
        );
      }
      return res;
    }
    return exp;
  };

  const cloneObject = (obj) => {
    if (Array.isArray(obj)) {
      return obj.map((e) => cloneObject(e));
    }
    if (obj && typeof obj === "object") {
      let res = {};
      for (let p in obj) {
        res[p] = cloneObject(obj[p]);
      }
      return res;
    }
    return obj;
  };

  const MAX_DISPLAY_CELLS_SIZE = 11;
  const MAX_BATTLE_INFOS = 4;

  const getNextInCycle = (ps) => (p) => {
    return ps[(ps.indexOf(p) + 1) % ps.length];
  };

  Array.prototype.obj = function () {
    return Object.fromEntries(this);
  };
  Array.prototype.rsort =
    Array.prototype.rsort ||
    function () {
      let a = this.map((i) => [i, Math.random()]);
      let b = a.sort((i, j) => i[1] - j[1]);
      return b.map((i) => i[0]);
    };

  class Skill {
    static props = [
      "name",
      "level",
      "buffers",
      "positive",
      "last",
      "cooldown",
      "filters",
      "attackQuit",
      "cast",
      "count",
      "obj",
      "soldable",
    ];
    constructor(info) {
      registerProperties(this, ...Skill.props);
      for (let p of Skill.props) {
        this[p] = info[p];
      }
    }
  }

  const propsMapArray = [
    ["b", "buffers"],
    ["l", "life"],
    ["lvl", "level"],
    ["mc", "money"],
    ["mpn", "mainProps"],
    ["p", "current"],
    ["sk", "skills"],
    ["g", "group"],
    ["gt", "ghost"],
    ["d", "died"],
    ["n", "name"],
  ];

  const rePropsMap = new Map(propsMapArray);
  const propsMap = new Map(propsMapArray.map((i) => [...i].reverse()));

  class Calculator {
    constructor(context, session) {
      this.context = context;
      this.session = session;
    }

    insertUnit(context, unit, id, clone = false) {
      if (clone) {
        context = Object.assign({}, context);
      }
      for (let prop of this.context.pn) {
        let p = prop[0] + id;
        context[p] = unit.current[prop];
        context["d" + p] = unit.current["d" + prop];
        context["o" + p] = unit[prop];
      }
      context["has" + id] = (name) =>
        unit.skills.some((s) => s.name === name);

      context["bpn" + id] = unit.position.prop;
      context["x" + id] = unit.position.x;
      context["y" + id] = unit.position.y;
      context["f" + id] = unit.position.floor;

      context["op" + id] = unit;

      for (let [s, p] of rePropsMap) {
        context[s + id] = unit[p];
      }
      return context;
    }

    createContext(...units) {
      let context = Object.assign({}, this.context, this.session.args);
      context.isEnemy = isEnemy;
      for (let i = 0; i < units.length; i++) {
        const unit = units[i];
        context = this.insertUnit(context, unit, i);
      }
      return context;
    }

    /**
     * 属性 jN{0,1}, mN, sN, hN, tN;本质属性: oXN;差异： dXN
     * 属性名、集合： pn, mpnN, cpn；pN, opN
     * 属性函数: fs, fk, fsr, fkr
     * 其他属性: lN
     * 辅助函数 Math.x, fx(p)
     */

    attack(source, target, attackProps, excludeSplash) {
      let context = this.createContext(source, target);
      // console.log(context)
      let attackProp = "";
      let attackDamage = 0;
      for (let prop of (attackProps || source.mainProps).rsort()) {
        const damage = evalInContext(
          this.session.formules.damage,
          Object.assign({}, context, { cpn: prop })
        );
        if (!attackProp || damage > attackDamage) {
          attackDamage = damage;
          attackProp = prop;
        }
      }
      context = Object.assign({}, context, {
        cpn: attackProp,
        dmg: attackDamage,
      });
      const hint = evalInContext(this.session.formules.hint, context);
      const splash = !excludeSplash
        ? evalInContext(this.session.formules.splash, context)
        : 0;
      const leech = hint
        ? evalInContext(this.session.formules.leech, context)
        : 0;
      const reflect = hint
        ? evalInContext(this.session.formules.reflect, context)
        : 0;
      const daze = hint && evalInContext(this.session.formules.daze, context);
      return [attackProp, hint, attackDamage, splash, leech, reflect, daze];
    }

    getExps(source, target) {
      return evalInContext(
        this.session.formules.getExps,
        this.createContext(source, target)
      );
    }

    getMoney(source, target) {
      return evalInContext(
        this.session.formules.getMoney,
        this.createContext(source, target)
      );
    }

    getSkill(source, target) {
      return evalInContext(
        this.session.formules.getSkill,
        this.createContext(source, target)
      );
    }

    daze(source, target) {
      return evalInContext(
        this.session.formules.daze,
        this.createContext(source, target)
      );
    }

    upExp(unit, cp) {
      return evalInContext(
        this.session.formules.upExp,
        Object.assign({}, this.createContext(unit), { cp })
      );
    }

    incLife(unit) {
      return evalInContext(
        this.session.formules.incLife,
        this.createContext(unit)
      );
    }

    incMoney(unit) {
      return evalInContext(
        this.session.formules.incMoney,
        this.createContext(unit)
      );
    }

    cooldown(unit) {
      return evalInContext(
        this.session.formules.cooldown,
        this.createContext(unit)
      );
    }
  }

  class Unit {
    static props = [
      "position",
      "jin",
      "mu",
      "shui",
      "huo",
      "tu",
      "pJin",
      "pMu",
      "pShui",
      "pHuo",
      "pTu",
      "current",
      "exp",
      "requireExp",
      "moving",
      "tracking",
      "group",
      "skills",
      "buffers",
      "money",
      "movable",
      "fighting",
      "ghost",
      "positiveSkills",
      "filters",
      "icon",
      "soldableSkills",
      "sprite",
      "activedSkills",
      "realActivedSkills",
      "steps",
      "isWall",
      "obj",
      "life",
      "level",
      "died",
      "name",
      "initPos",
      "mainProps",
      "aliving",
      "id",
      "nearby",
    ];
    constructor() {
      registerProperties(this, ...Unit.props);
    }

    copy(from, to) {
      for (let p of [
        "jin",
        "mu",
        "shui",
        "huo",
        "tu",
        "exp",
        "requireExp",
        "moving",
        "tracking",
        "group",
        "money",
        "movable",
        "fighting",
        "icon",
        "sprite",
        "ghost",
        "steps",
        "isWall",
        "obj",
        "life",
        "level",
        "died",
        "name",
        "aliving",
        "id",
      ]) {
        to[p] = cloneObject(from[p]);
      }
      to.skills = from.skills.map((s) => new Skill(s));
      to.position = from.position;
      to.initPos = from.initPos;
      to.when = cloneObject(from.when);
    }

    clone() {
      let clone = {};
      for (let p of Unit.props) {
        clone[p] = this[p];
      }
      return clone;
    }

    saveClone() {
      let clone = new Unit();
      this.copy(this, clone);
      return clone;
    }
  }

  class Player extends Unit {
    constructor() {
      super();
    }
    saveClone() {
      let clone = new Player();
      this.copy(this, clone);
      return clone;
    }
  }

  class BattleInfo {
    constructor() {
      // registerProperties(this, 'source', 'target', 'result', 'details')
    }
  }

  class App {
    constructor() {
      /** @type { Object.<string,HTMLElement> } */
      this.components;
      this.localStorage = Api.localStorage;
      registerProperties(
        this,
        "sessions",
        "currentSessionId",
        "session",
        "floorId",
        "floor",
        "displayFloor",
        "mems",
        "player",
        "units",
        "selectedUnits",
        "dx",
        "dy",
        "cellWidth",
        "success",
        "moving",
        "selectedCell",
        "lastEditingCell",
        "batting",
        "autoRunning",
        "showHelp",
        "battleInfos",
        "args",
        "customArgs",
        "unLeartSkills",
        "positiveSkills",
        "soldableSkills",
        "currentAction",
        "selectingMem",
        "editing",
        "currentEntry",
        "currentEntryFirst",
        "editingEntries",
        "editingFloors",
        "currentUnit",
        "editingResult",
        "editingResultInfo",
        "floorName",
        "sessionName",
        "saving",
        "currentModifierIdx",
        "cellModifiers",
        "editingUnit",
        "isEditingUnit",
        "isEditingEntry",
        "showConsole",
        "consoleIn",
        "consoleOuts",
        "editingSessionInfos",
        "editingCell",
        "cellButtons",
        "JSONEditor",
        "whenEditor"
      );
    }

    exitEditUnit() {
      this.currentUnit = undefined;
      this.isEditingUnit = undefined;
    }

    async createUnit() {
      let unit = new Unit();
      unit.name = "单位";
      unit.group = GROUP_B;
      for (let p of this.PROPS) {
        unit[p] = 0;
      }
      await this.updateProps(unit, unit);
      await this.moveTo(unit, this.selectedCell || this.floor.cells[0][0]);
      this.units = [
        this.player,
        unit,
        ...this.units.filter((u) => u !== this.player),
      ];
      this.locateUnit(unit);
    }

    async locateUnit(unit, locateOnly = false) {
      if (unit === this.player) {
        return;
      }
      this.exitAllEditingMode();
      if (!locateOnly) {
        this.isEditingUnit = true;
      }
      this.currentUnit = unit;
      if (this.floorId != unit.position.floor) {
        await this.loadFloor(unit.position.floor);
      }
      this.selectedCell = unit.position;
    }

    async deleteUnit(unit) {
      if (unit === this.player) {
        return;
      }
      this.units = [...this.units.filter((u) => u !== unit)];
      await this.exitEditUnit();
    }

    async toggleUnitMovable(unit) {
      this.locateUnit(unit);
      unit.movable = !unit.movable;
    }

    async changeUnitName(unit) {
      if (this.currentUnit !== unit && unit !== this.player) {
        this.locateUnit(unit);
        return;
      }
      this.locateUnit(unit);
      let str = await this.prompt(
        "修改单位名",
        `${unit.group === undefined ? "" : unit.group} ${unit.name || ""}`
      );
      if (str === undefined) {
        return;
      }
      let [group, name] = str.split(/,|\s/).filter((s) => s !== "");
      if (name === undefined) {
        name = group;
        group = undefined;
      }
      unit.name = name || "";
      unit.group = undefined;
      group = group * 1;
      if (!isNaN(group)) {
        unit.group = group;
      }
    }

    editUnitWhen() {
      if (
        !this.JSONEditor ||
        !this.editingUnit ||
        !this.components.whenEditor
      ) {
        return;
      }
      if (this.whenEditor) {
        this.whenEditor.destroy();
      }
      const editor = new JSONEditor(this.components.whenEditor, {
        schema: whenSchema,
        disable_collapse: undefined,
        disable_edit_json: true,
        template: {
          compile: (template) => (vars) => {
            const result = evalInContext("`" + template + "`", vars);
            return result;
          },
        },
      });
      editor.on("ready", () => {
        editor.setValue(this.editingUnit.when || {});
      });
      this.whenEditor = editor;
    }

    async saveUnitWhen() {
      if (
        !this.JSONEditor ||
        !this.editingUnit ||
        !this.components.whenEditor ||
        !this.whenEditor
      ) {
        return;
      }
      const errors = this.whenEditor.validate();
      if (errors.length) {
        await this.confirm(
          errors.map((e) => `${e.path},${e.property}:${e.message}`).join("\n")
        );
        return;
      }
      this.editingUnit.when = this.whenEditor.getValue();
      await this.modal_.toast("已更新");
    }

    async startEditingUnitDetail(unit) {
      this.editingUnit = unit;
      await sleep(200);
      await this.editUnitWhen();
    }

    async changeUnitProp(unit) {
      this.locateUnit(unit);
      this.startEditingUnitDetail(unit);
      // let str = (await this.prompt(
      //   `修改${unit.name || ''}的属性:${this.PROPS.map(p => this.getPropName(p)).join(',')}`,
      //   this.PROPS.map(p => unit[p] + "").join(', ')
      // ))
      // if (str === undefined) {
      //   return
      // }
      // let propValues = str.split(/,|\s/).filter(s => s !== '').map(i => (i * 1) || 0)
      // for (let i = 0; i < this.PROPS.length; i++) {
      //   unit[this.PROPS[i]] = propValues[i] || 0
      // }
      // this.updateProps(unit, unit)
      // this.units = [...this.units]
    }

    async createSession(forceCreate = false) {
      this.showHelp = false;
      this.editing = true;
      this.sessionInfo = forceCreate
        ? undefined
        : this.lastEditingSessionInfo;
      await this.restart();
    }

    saveApp() {
      const status = {};
    }

    save() {
      if (
        !this.floor ||
        this.success ||
        this.moving ||
        this.batting ||
        this.currentAction
      ) {
        return;
      }
      let mem = {
        name: `${this.player.name}\t(等级:${this.player.level})\t(位置:${this.currentSessionId.name || this.currentSessionId + 1
          },${this.floor.name || this.floorId + 1},${this.player.position.x},${this.player.position.y
          })\t(${new Date().toLocaleString()})`,
      };
      mem.units = this.units.map((u) => u.saveClone());
      mem.steps = this.steps;
      mem.visited = this.session.floors.map((f) =>
        f.cells.map((col) => col.map((c) => c.visited === true))
      );
      this.mems = [mem, ...this.mems.slice(0, MAX_MEMS_COUNT - 1)];
      this.modal_.toast("已生成快照快照");
    }

    async load(mem) {
      this.selectingMem = false;
      if (
        !this.floor ||
        this.success ||
        this.moving ||
        this.batting ||
        this.currentAction
      ) {
        return;
      }
      this.selectedCell = undefined;
      this.session.floors.forEach((f) =>
        f.cells.forEach((l) =>
          l.forEach((c) => {
            c.isWall = undefined;
            c.units = undefined;
          })
        )
      );
      this.steps = mem.steps;
      this.units = mem.units.map((u) => u.saveClone());
      this.session.floors.forEach((f, floor) =>
        f.cells.forEach((col, y) =>
          col.forEach((c, x) => {
            const visited = mem.visited[floor][y][x];
            if (visited) {
              c.visited = true;
            } else {
              c.visited = undefined;
            }
          })
        )
      );
      this.player = this.units[0];
      this.selectedUnits = [this.player];
      this.units.forEach((u) => {
        if (u.id) {
          this.session.unitIds[u.id] = u;
        }
        this.updateProps(u, u);
        this.learnSkills(u, [], u === this.player);
        this.moveTo(u, u.position, true);
      });
      await this.loadFloor(this.player.position.floor);
      this.moveTo(this.player, this.player.position, true);
      this.modal_.toast("已加载快照");
    }

    async prompt(msg, value) {
      return await new OldModal(this.components.app).prompt(msg, value, {
        type: "text",
      });
    }

    async confirm(msg) {
      return await new OldModal(this.components.app).confirm(msg);
    }

    async select(
        /** @type string */ msg,
        /** @type [any] */ values = [],
      defaultIdx = 0
    ) {
      return await new OldModal(this.components.app).select(
        msg,
        values,
        defaultIdx
      );
    }

    async changeFloorName() {
      let str = await this.prompt("修改关名", this.floorName || "");
      this.floor.name = str;
      this.floorName = this.floor.name;
    }

    async changeSessionName() {
      let str = await this.prompt("修改层名", this.sessionName || "");
      if (!str) {
        return;
      }
      if (str === this.session.name) {
        return;
      }
      if (this.editingSessionInfos.infos[str]) {
        this.modal_.toast(str + "已存在");
        return;
      }
      let lastName = this.session.name;
      this.session.name = str;
      this.sessionName = this.session.name;
      const { sessionInfo } = await this.generateCurrentSessionInfo();
      if (lastName) {
        delete this.editingSessionInfos.infos[lastName];
      }
      this.editingSessionInfos.infos[
        this.sessionName
      ] = this.lastEditingSessionInfo = sessionInfo;
      await this.saveSessionInfo();
      await this.modal_.toast("已保存");
    }

    changeArg(arg, event) {
      let newValue = undefined;
      let str = event.target.value.trim();
      if (str) {
        try {
          newValue = JSON.parse(str);
        } catch {
          console.log(`Invalid arg value ${arg} :${str}`);
        }
      }
      if (newValue === undefined) {
        delete this.customArgs[arg];
      } else {
        this.customArgs[arg] = newValue;
      }
      this.session.args = Object.assign(
        {},
        this.session.initArgs,
        this.customArgs
      );
      switch (arg) {
        case "BUFF":
          this.session.propStrength = this.session.args.BUFF;
          this.selectedUnits = [...this.selectedUnits];
          break;
        case "RATE_BUY":
          this.unLeartSkills = [...this.unLeartSkills];
          break;
        case "RATE_SELL":
          this.soldableSkills = [...this.soldableSkills];
          break;
        case "RATE_USE_SKILL":
          this.positiveSkills = [...this.positiveSkills];
          break;
        case "FPS":
          delayDispatcher.setDelay(1000 / this.session.args.FPS);
          break;
        default:
          break;
      }
    }

    async loadCurrentSessionId(d = 0) {
      if (!this.data.sessions) {
        return d;
      }
      try {
        return (
          JSON.parse(
            await this.localStorage.getItem(CURRENT_SESSION_ID_KEY)
          ) || d
        );
      } catch {
        return d;
      }
    }

    async saveCurrentSessionId(sessionId) {
      this.currentSessionId = sessionId;
      try {
        await this.localStorage.setItem(
          CURRENT_SESSION_ID_KEY,
          JSON.stringify(this.currentSessionId)
        );
      } catch { }
    }

    registerMediaData(pre, data) {
      if (!data) {
        return;
      }
      for (let p in data) {
        if (!p.startsWith(pre) || !Array.isArray([data[p]])) {
          continue;
        }
        let prop = p.slice(pre.length);
        if (!prop) {
          continue;
        }
        Object.defineProperty(data, prop, {
          get: () => {
            if (this.mediaDataCaches?.has(prop)) {
              return this.mediaDataCaches.get(prop);
            }
            for (let [value, query] of data[p]) {
              if (!query || window.matchMedia?.(query)?.matches) {
                this.mediaDataCaches = this.mediaDataCaches || new Map();
                this.mediaDataCaches.set(prop, value);
                return value;
              }
            }
          },
        });
      }
    }

    consoleLog(...msgs) {
      this.appendToConsoleOuts(msgs.join("\n"));
    }

    setConsole(show) {
      if (this.showConsole === show) {
        return;
      }
      this.showConsole = show;
      // window.console._log = window.console._log || window.console.log
      // if (this.showConsole) {
      //   window.console.log = (...msgs) => {
      //     this.appendToConsoleOuts(msgs.join('\n'))
      //   }
      // } else {
      //   window.console.log = window.console._log
      // }
    }

    appendToConsoleOuts(str) {
      this.consoleOuts.push({ content: str });
      while (this.consoleOuts.length >= MAX_CONSOLEOUTS_COUNT) {
        this.consoleOuts.shift();
      }
      this.consoleOuts = [...this.consoleOuts];
    }

    async clearAllData() {
      if (await this.confirm("确认删除所有数据")) {
        await this.localStorage.clear();
        await this.modal_.toast("已删除");
      }
    }

    async executeConsole() {
      if (!this.consoleIn) {
        return;
      }
      let consoleIn = this.consoleIn.trim();
      if (!this.consoleIn) {
        return;
      }
      if (consoleIn.length > 100) {
        let sessionInfo;
        try {
          sessionInfo = JSON.parse(consoleIn);
        } catch {
          await this.modal_.toast("命令太长");
          return;
        }
        if (sessionInfo && sessionInfo.floors) {
          this.lastEditingSessionInfo = sessionInfo;
          this.sessionInfo = sessionInfo;
          this.setConsole(false);
          await this.modal_.toast("已导入");
          await this.restart();
          return;
        }
        await this.modal_.toast("命令太长");
        return;
      }
      this.consoleIn = "";
      this.consoleLog("> " + consoleIn);
      let res;
      try {
        res = evalInContext(consoleIn, this);
      } catch (e) {
        this.consoleLog(e);
      }
      this.consoleLog(res);
    }

    async start() {
      this.registerMediaData("@media-", this.data);
      new ResizeWatcher(window, 50).register(() => {
        this.mediaDataCaches = undefined;
      });
      this.showConsole = false;
      this.consoleIn = "";
      this.consoleOuts = [];
      /** @type { { toast:(msg:string, timeout:number = 1000)=>Promise<any> } } */
      this.modal_ = this.components.modal.model;
      this.PROPS = ["jin", "mu", "shui", "huo", "tu"];
      this.PROPSIDS = this.PROPS.map((p, i) => [p, i + 1 + ""]).obj();
      this.data.MAX_DISPLAY_CELLS_SIZE =
        this.data.MAX_DISPLAY_CELLS_SIZE || MAX_DISPLAY_CELLS_SIZE;
      this.PROPS_SHENG = ["jin", "shui", "mu", "huo", "tu"];
      this.PROPS_KE = ["jin", "mu", "tu", "shui", "huo"];
      this.CONTEXT = {
        pn: this.PROPS,
        rand: Math.random,
        rave: (ave, d) => ave + d * (1 - Math.random() * 2),
        rave1: (d) => 1 + d * (1 - Math.random() * 2),
        max: Math.max,
        max0: (i) => Math.max(0, i),
        max1: (i) => Math.max(1, i),
        min: Math.min,
        min0: (i) => Math.min(0, i),
        min1: (i) => Math.min(1, i),
        pow: Math.pow,
        pow2: (i) => Math.pow(2, i),
        log2: (i) => Math.log2(Math.max(0, i)),
        floor: Math.floor,
        floorn: (v, n) => Math.floor(v * Math.pow(10, n)) / Math.pow(10, n),
        fpn: (prop) => this.getPropName(prop),
        steps: () => this.steps,
        ids: (id) => this.session?.unitIds[id],
        fs: getNextInCycle(this.PROPS_SHENG),
        fsr: getNextInCycle([...this.PROPS_SHENG].reverse()),
        fk: getNextInCycle(this.PROPS_KE),
        fkr: getNextInCycle([...this.PROPS_KE].reverse()),
      };
      try {
        this.lastPlayer = JSON.parse(
          await this.localStorage.getItem(LAST_PLAYER_KEY)
        );
      } catch { }
      try {
        this.editingSessionInfos = JSON.parse(
          await this.localStorage.getItem(LAST_EDITING_SESSION_INFOS_KEY)
        );
      } catch {
        this.editingSessionInfos = { current: "", infos: {} };
      }
      this.editingSessionInfos = this.editingSessionInfos || {};
      this.editingSessionInfos.infos = this.editingSessionInfos.infos || {};
      if (this.data.editor) {
        this.editing = true;
        this.lastEditingSessionInfo = this.editingSessionInfos.infos[
          this.editingSessionInfos.current
        ];
        this.sessionInfo = this.lastEditingSessionInfo;
      }
      if (this.editing) {
        this.cellModifiers = [
          ...this.PROPS.map((p) => (cell) => {
            cell.type = "Floor";
            cell.prop = p;
          }),
          (cell) => {
            cell.type = "Wall";
          },
          (cell) => {
            cell.type = "Wall";
            cell.isCorner = true;
          },
          (cell) => {
            cell.type = "Wall";
            cell.empty = true;
          },
        ];
        this.currentModifierIdx = 0;
        this.cloneCellProps = [
          "floor",
          "x",
          "y",
          "id",
          "type",
          "prop",
          "empty",
          "isCorner",
        ];
        this.editingCellProps = [
          "target",
          "isInEntry",
          "isOutEntry",
          "isStart",
          "isEnd",
          ...this.cloneCellProps,
        ];
        this.templateCells = this.cellModifiers.map((m, i) => {
          let cell = {};
          registerProperties(cell, ...this.editingCellProps);
          m(cell);
          cell.id = i;
          return cell;
        });
        this.cellButtons = [
          {
            name: "单位",
            classes: "prop mu",
            invoke: () => this.createUnit(),
          },
          {
            name: "通道",
            classes: "prop mu",
            invoke: () => this.createEntry(),
          },
          {
            name: "上加",
            classes: "prop mu",
            invoke: () => this.addRow(true),
          },
          { name: "下加", classes: "prop mu", invoke: () => this.addRow() },
          {
            name: "左加",
            classes: "prop mu",
            invoke: () => this.addColumn(true),
          },
          {
            name: "右加",
            classes: "prop mu",
            invoke: () => this.addColumn(),
          },
          {
            name: "删行",
            classes: "prop huo",
            invoke: () => this.deleteRow(),
          },
          {
            name: "删列",
            classes: "prop huo",
            invoke: () => this.deleteColumn(),
          },
        ];
      }
      this.JSONEditor = window.JSONEditor;
      if (this.JSONEditor) {
        this.JSONEditor.prototype.addNewStyleRulesToShadowRoot = function addNewStyleRulesToShadowRoot(
          themeName,
          rules,
          shadowRoot
        ) {
          var qualifier = this.element.nodeName.toLowerCase();
          var cssText = "";
          Object.keys(rules).forEach(function (selector) {
            var sel =
              themeName === "default"
                ? selector
                : ""
                  .concat(qualifier, '[data-theme="')
                  .concat(themeName, '"] ')
                  .concat(selector);
            cssText +=
              sel + " {" + decodeURIComponent(rules[selector]) + "}" + "\n";
          });
          //   var styleSheet = new CSSStyleSheet();
          //   styleSheet.replaceSync(cssText);
          //   shadowRoot.adoptedStyleSheets = [].concat(_toConsumableArray(shadowRoot.adoptedStyleSheets), [styleSheet]);
          var styleSheet = document.createElement("style");
          styleSheet.innerText = cssText + customeStyles;
          shadowRoot.appendChild(styleSheet);
        };
      }
      await this.loadSession(await this.loadCurrentSessionId());
      new ResizeWatcher(window, 50).register(this.resize.bind(this));
      delayDispatcher.setDelay(1000 / this.session.args.FPS);
      window.addEventListener("keydown", this.onKeyDown.bind(this));
    }

    updateFloorCellsCor(affectedX, affectedY) {
      for (let y = affectedY; y < this.floor.cells.length; y++) {
        for (let x = affectedX; x < this.floor.cells[0].length; x++) {
          let cell = this.floor.cells[y][x];
          cell.x = x;
          cell.y = y;
        }
      }
    }

    async deleteCells(deleteCells, affectedX, affectedY, updateFloor) {
      const getNewPos = ({ x, y }) => {
        let col = this.floor.cells[y] || this.floor.cells[y - 1];
        return col[x] || col[x - 1];
      };
      let affectedUnits = this.units.filter(
        (u) => deleteCells.has(u.position) && u !== this.player
      );
      let affectedEntries = this.editingEntries.filter(
        (e) => deleteCells.has(e.start) || deleteCells.has(e.end)
      );
      // if (affectedUnits.length || affectedEntries.length) {
      // }
      if (
        !(await this.confirm(
          `将影响${affectedUnits.length}个单位与${affectedEntries.length}个通道`
        ))
      ) {
        return;
      }
      updateFloor();
      this.updateFloorCellsCor(affectedX, affectedY);
      this.selectedCell = getNewPos(this.selectedCell);

      for (let u of [
        ...(deleteCells.has(this.player.position) ? [this.player] : []),
        ...affectedUnits,
      ]) {
        this.moveTo(u, getNewPos(u.position), true);
      }
      for (let e of this.editingEntries) {
        if (deleteCells.has(e.start)) {
          let newPos = getNewPos(e.start);
          if (newPos.isInEntry || newPos.isOutEntry) {
            e.start = undefined;
          } else {
            e.start = newPos;
          }
        }
        if (deleteCells.has(e.end)) {
          let newPos = getNewPos(e.end);
          if (newPos.isInEntry || newPos.isOutEntry) {
            e.end = undefined;
          } else {
            e.end = newPos;
          }
        }
        this.updateEntryConnections(e);
      }
      this.editingEntries = [...this.editingEntries];
    }

    async deleteRow() {
      if (!this.floor || !this.selectedCell || this.floor.cells.length < 2) {
        return;
      }
      let deleteIdx = this.selectedCell.y;
      await this.deleteCells(
        new Set(this.floor.cells[deleteIdx]),
        0,
        deleteIdx,
        () => {
          this.floor.cells.splice(deleteIdx, 1);
          this.floor.cells = [...this.floor.cells];
        }
      );
    }

    async deleteColumn() {
      if (
        !this.floor ||
        !this.selectedCell ||
        this.floor.cells[0].length < 2
      ) {
        return;
      }
      let deleteIdx = this.selectedCell.x;
      await this.deleteCells(
        new Set(this.floor.cells.map((i) => i[deleteIdx])),
        deleteIdx,
        0,
        () => {
          this.floor.cells = this.floor.cells.map((col) => {
            col.splice(deleteIdx, 1);
            return [...col];
          });
        }
      );
    }

    cloneEditingCell(c) {
      let nc = {};
      registerProperties(nc, this.editingCellProps);
      for (let p of this.cloneCellProps) {
        nc[p] = c[p];
      }
      delete nc.isInEntry;
      delete nc.isOutEntry;
      return nc;
    }

    addRow(before) {
      if (!this.floor) {
        return;
      }
      let fromRowIdx = this.selectedCell
        ? this.selectedCell.y
        : before
          ? 0
          : this.floor.cells.length - 1;
      let newCells = this.floor.cells[fromRowIdx].map((c) =>
        this.cloneEditingCell(c)
      );
      let insertPosition = fromRowIdx + (before ? 0 : 1);
      let cells;
      if (insertPosition < 0) {
        cells = [newCells, ...this.floor.cells];
      } else {
        cells = [...this.floor.cells];
        cells.splice(insertPosition, 0, newCells);
      }
      this.floor.cells = cells;
      this.updateFloorCellsCor(0, Math.min(insertPosition, 0));
      this.moveTo(this.player, this.player.position);
      this.editingEntries = [...this.editingEntries];
    }

    addColumn(before) {
      if (!this.floor) {
        return;
      }
      let fromColumnIdx = this.selectedCell
        ? this.selectedCell.x
        : before
          ? 0
          : this.floor.cells[0].length - 1;
      let newCells = this.floor.cells
        .map((col) => col[fromColumnIdx])
        .map((c) => this.cloneEditingCell(c));
      let insertPosition = fromColumnIdx + (before ? 0 : 1);
      this.floor.cells = this.floor.cells.map((col, y) => {
        if (insertPosition < 0) {
          return [newCells[y], ...col];
        }
        col = [...col];
        col.splice(insertPosition, 0, newCells[y]);
        return col;
      });
      this.updateFloorCellsCor(0, Math.min(insertPosition, 0));
      this.moveTo(this.player, this.player.position);
      this.editingEntries = [...this.editingEntries];
    }

    resize() {
      if (!this.displayFloor) {
        return;
      }
      let cellWidth = Math.min(
        Math.floor(window.innerWidth / this.displayFloor[0].length),
        Math.floor(window.innerHeight / this.displayFloor.length)
      );
      let dataCellWidth = this.data.cellWidth;
      if (dataCellWidth) {
        cellWidth = Math.min(cellWidth, dataCellWidth);
      }
      this.cellWidth = cellWidth;
    }

    getSessionSize(sessionId) {
      let dataCellWidth = this.data.cellWidth;
      if (dataCellWidth) {
        const cellWidth = dataCellWidth;
        const cellCount = Math.min(
          Math.floor(window.innerWidth / cellWidth),
          Math.floor(window.innerHeight / cellWidth)
        );
        this.data.MAX_DISPLAY_CELLS_SIZE = cellCount;
      }
      const width =
        this.data.width ||
        this.data.initWidth + sessionId ||
        this.data.MAX_DISPLAY_CELLS_SIZE;
      const height =
        this.data.height || this.data.initHeight + sessionId || width;
      return [width, height];
    }

    createSmipleSessionInfo(width, height, floorCount) {
      let midWidth = Math.floor((width - 1) / 2);
      return {
        units: [],
        start: { floor: 0, x: midWidth, y: height - 2 },
        end: { floor: floorCount - 1, x: midWidth, y: 1 },
        entries: Array.from({ length: floorCount - 1 }, (_, i) => [
          { floor: i, x: midWidth, y: 1 },
          { floor: i + 1, x: midWidth, y: height - 2 },
          true,
        ]),
        player: { jin: 1 },
        floors: Array.from({ length: floorCount }, () => ({
          cells: Array.from({ length: height }, (_y, y) =>
            Array.from({ length: width }, (_x, x) =>
              x === 0 || y === 0 || x === width - 1 || y === height - 1
                ? "0"
                : "1"
            )
          ),
        })),
      };
    }

    async createTmpSessionInfo(width = 0, height = 0, floorCount = 3) {
      if (!width) {
        [width, height] = this.getSessionSize(0);
      }
      let str = await this.prompt("新建关卡(宽，高):", `${width},${height}`);
      if (str) {
        let [w, h] = str
          .split(/,|\s/)
          .map((s) => s * 1)
          .filter((s) => s);
        if (w) {
          width = w;
          height = h;
        }
      }
      if (!height) {
        height = width;
      }
      let info = this.session?.args?.RANDOM_CREATE_FLOOR
        ? await new SessionGenerator().generate(
          width,
          height,
          floorCount,
          this.data.pEntries || 0,
          this.data.pUnits || 0,
          this.data.pFriendlyUnits || 0
        )
        : this.createSmipleSessionInfo(width, height, floorCount);
      info.customeCorner = true;
      return info;
    }

    async setEditingUnitProp(prop, value) {
      if (!this.editingUnit) {
        return;
      }
      this.editingUnit[prop] = value * 1 || 0;
      await this.updateProps(this.editingUnit, this.editingUnit);
    }

    async tryGetSessionInfo(sessionId) {
      sessionId = Math.max(0, sessionId);
      if (this.data.sessions) {
        if (sessionId >= this.data.sessions.length) {
          await this.modal_.toast("通过全部关卡， 游戏重新开始");
          this.player = undefined;
          sessionId = 0;
        }
        await this.saveCurrentSessionId(sessionId);
        return this.data.sessions[sessionId];
      }
      await this.saveCurrentSessionId(sessionId);
      const [width, height] = this.getSessionSize(sessionId);
      return await new SessionGenerator().generate(
        width,
        height,
        this.data.floorsCount || 1,
        this.data.pEntries || 0,
        this.data.pUnits || 0,
        this.data.pFriendlyUnits || 0,
        this.data.args?.moneyTimes || 100,
        this.data.skills || []
      );
    }

    getPropName(attachProp) {
      switch (attachProp) {
        case "jin":
          return "金";
        case "mu":
          return "木";
        case "tu":
          return "土";
        case "shui":
          return "水";
        case "huo":
          return "火";
      }
    }

    async selectSessionOrCreate() {
      let sessionNames = Object.keys(this.editingSessionInfos.infos).sort();
      if (!sessionNames.length) {
        return await this.createTmpSessionInfo();
      }
      let selectIdx =
        (await this.select("编辑场景", ["<新建>", ...sessionNames])) - 1;
      return (
        this.editingSessionInfos.infos[sessionNames[selectIdx]] ||
        (await this.createTmpSessionInfo())
      );
    }

    async loadSession(sessionId) {
      let sessionInfo;
      if (this.editing) {
        if (
          this.sessionInfo &&
          this.sessionInfo === this.lastEditingSessionInfo
        ) {
          sessionInfo = this.sessionInfo;
        } else {
          sessionInfo = await this.selectSessionOrCreate();
        }
      } else {
        if (
          this.sessionInfo &&
          (this.steps || this.sessionInfo === this.lastEditingSessionInfo)
        ) {
          sessionInfo = this.sessionInfo;
        } else {
          sessionInfo = await this.tryGetSessionInfo(sessionId);
        }
      }
      this.sessionInfo = sessionInfo;
      this.mems = [];
      this.autoRunning = undefined;
      this.batting = undefined;
      this.battleInfos = [];
      this.dx = 0;
      this.dy = 0;
      this.floor = undefined;
      this.floorId = undefined;
      this.moving = undefined;
      let lastPlayer = this.lastPlayer;
      this.player = undefined;
      this.selectedUnits = undefined;
      this.success = undefined;
      this.units = undefined;
      this.steps = 0;
      this.editingEntries = [];
      this.editingFloors = [];

      const session = {};
      session.formules = Object.assign(
        {
          getExps: `//经验获取
        [...mpn1].map(p => [p,
          //rand() < pow2(ds0)) //水属性失衡
          floorn(max(1 / 2, //最低经验
            (op1[p] - op0[p] + 1) * pow(2, op1[p] - op0[p] - 2)) //等级差异
            * (1
              + (p === bpn0 ? BUFF : 0) / 3
              + pow2(ds0 - 2)), 1)  //水属性失衡
        ]).obj()
      `,
          upExp: `//升级经验 ;2,4,8;16;32;...256
        pow2(cp)
      `,
          incLife: `//生命恢复
        (MAX_LIFE * BUFF / max(1, log2(max1(lvl0 - BUFF))) / MAX_RECOVERY_COUNT) * (1 + b0.pRecovery)
      `,
          incMoney: `//金币增长
        floor(rand() * (1 + log2(max1(lvl0 / 3)) / 10) * (1 + max(1 / 32, pow2(dj0 - 2)) / 5))
      `,
          getMoney: `// 金币获取
        floor(rand() * (lvl1 + m1 * 0.05) * (1 + max(1 / 32, pow2(dj0 - dj1 - 4) / 2)))
      `,
          getSkill: `//技能获取
        rand() < pow2(lvl1 - lvl0 - 3)
      `,
          damage: `//伤害
        floor(
          pow2(((p0[cpn] - p1[cpn]) * 0.5 - 1)) //主属性伤害
          * pow2((p0[cpn] + p1[fk(cpn)]) / 3) //克制增强
          * (1 //暴击
            + max0(rave1(0.25) / 4 * (log2(dh0))) //火属性失衡
            + max0(rave1(0.25) / 4 * (log2(p0[fsr(cpn)]))) //辅助增强
            + b0.pAttack //buff
          )
          * (rand() < b0.pTrueDamage ? 1 : //真伤
            max0(1 //伤减
              - max0(rave1(0.25) / 4 * (log2(dt1))) //土属性失衡
              - b1.pDefend //buff
            ))
        )
      `,
          hint: `//命中
        rand() < pow2(p0[cpn] - p1[fkr(cpn)] - 1) //反制命中
        * (1 + b0.pHint) //命中
        * (1 - b1.pEscape) //闪避
      `,
          leech: `//吸血
        floor(min(dmg, l1)
          * (0
            + max0(rave1(0.25) / 4 * (log2(dm0)))  //木属性失衡
            + b0.pLeech //buff
          )
        )
      `,
          reflect: `//反伤
        floor(min(dmg, l1)
          * (0
            + max0(rave1(0.25) / 4 * (log2(dt1)))  //土属性失衡
            + b1.pReflect //buff
          )
        )
      `,
          daze: `//眩晕
        rand() < (
          max(1 / 32, pow2(dt0 - dm1 - 4) / 2) //土木属性失衡
          + b0.pDaze //buff
        )
      `,
          cooldown: `//攻击冷却
        pow(1.05, -dj0) //金属性失衡
        * (1 + b0.pCooldown) //buff
      `,
          splash: `//溅射率
        (b0.pSplash) //buff
      `,
        },
        this.data.formules,
        sessionInfo.formules
      );
      session.initArgs = Object.assign(
        {
          BUFF: 2,
          DIED_RECOVERY: 1,
          DISTANCE_ASSISTANCE: 2,
          DISTANCE_CANCLE_TRACKING: 3,
          DISTANCE_SHADOW: 0,
          DISTANCE_TRACKING: 2,
          FPS: 20,
          MAX_LEVEL: 9,
          MAX_LIFE: 100,
          MAX_RECOVERY_COUNT: 100,
          P_ALIVING_LIVE: 0.6,
          P_ATTACK_ORDER_DIST: 100,
          P_ATTACK_ORDER_LEVEL: 1,
          P_ATTACK_ORDER_RANDOM: 1,
          P_BUILDING_RECOVERY: 5,
          P_POSITIVE_COOLDOWN: 0.5,
          P_SKILL_COOLDOWN: 1,
          P_WAKE_UP_LIFE: 0.8,
          RANDOM_CREATE_FLOOR: 0,
          RATE_BUY: 30,
          RATE_SELL: 10,
          RATE_USE_SKILL: 3,
          TIME_AUTO_SAVE: 60,
        },
        this.data.args,
        sessionInfo.args
      );
      this.customArgs = {};
      session.args = Object.assign(session.initArgs, this.customArgs);
      this.args = Object.keys(session.initArgs);
      session.propStrength = session.args.BUFF;
      session.skills = (sessionInfo.skills || []).sort(
        (i, j) => i.level - j.level
      );
      session.skillsObj = session.skills.map((s) => [s.name, s]).obj();
      session.crossProps = sessionInfo.crossProps || this.data.crossProps;
      session.theme = sessionInfo.theme || this.data.theme;
      session.themes = sessionInfo.themes || this.data.themes;
      session.customeCorner =
        sessionInfo.customeCorner !== undefined
          ? sessionInfo.customeCorner
          : this.data.customeCorner;
      session.images = sessionInfo.images || this.data.images;
      session.floors = this.createFloors(sessionInfo, session);
      if (this.editing) {
        this.editingFloors = [...session.floors];
      }
      session.name = sessionInfo.name;
      session.whens = sessionInfo.whens || this.data.whens;
      session.start =
        session.floors[sessionInfo.start.floor].cells[sessionInfo.start.y][
        sessionInfo.start.x
        ];
      session.start.isStart = true;
      session.end =
        session.floors[sessionInfo.end.floor].cells[sessionInfo.end.y][
        sessionInfo.end.x
        ];
      session.end.isEnd = true;
      if (this.editing) {
        this.editingEntries = [
          createEntryObj(undefined, session.start, 1),
          createEntryObj(session.end, undefined, 1),
        ];
      }
      for (let [start, end, bidirection] of sessionInfo.entries) {
        const startCell = session.floors[start.floor].cells[start.y][start.x];
        const endCell = session.floors[end.floor].cells[end.y][end.x];
        startCell.isInEntry = true;
        startCell.target = endCell;
        endCell.isOutEntry = true;
        if (bidirection) {
          startCell.isOutEntry = true;
          endCell.isInEntry = true;
          endCell.target = startCell;
        }
        if (this.editing) {
          this.editingEntries.push(
            createEntryObj(startCell, endCell, bidirection ? 0 : 1)
          );
        }
      }
      session.unitIds = {};
      this.session = session;
      this.sessionName = this.session.name;
      this.calculator = new Calculator(this.CONTEXT, this.session);
      await this.modal_.toast(`开始第${this.currentSessionId + 1}关`);
      const player = new Player();
      const playerInfo = Object.assign(
        {},
        this.data.player,
        sessionInfo.player
      );
      // cloneObject(sessionInfo.player)
      if (lastPlayer) {
        for (let p in lastPlayer) {
          if (p === "skills") {
            continue;
          }
          playerInfo[p] = lastPlayer[p];
        }
      }
      playerInfo.skills = [
        ...(playerInfo.baseSkills || []),
        ...(playerInfo.skills || []),
      ];
      this.updateProps(player, playerInfo);
      player.life = (playerInfo.life || 1) * this.session.args.MAX_LIFE;
      player.initPos = session.start;
      player.id = playerInfo.id;
      player.name = playerInfo.name || playerInfo.id;
      if (!player.name) {
        player.name = "玩家";
        // } else {
        //   player.name = `${player.name}(玩家)`
      }
      this.learnSkillsByName(
        player,
        [...[], ...(playerInfo.skills || [])],
        true
      );
      if (lastPlayer?.skills) {
        this.learnSkills(player, lastPlayer.skills, true);
      }
      player.money = playerInfo.money || 0;
      player.movable = true;
      player.icon = playerInfo.icon && this.session.images?.[playerInfo.icon];
      player.sprite = playerInfo.sprite;
      player.group = playerInfo.group;
      if (player.group === undefined) {
        player.group = GROUP_A;
      }
      player.isWall = playerInfo.isWall || false;
      this.player = player;
      await this.loadFloor(this.session.start.floor);
      await this.moveTo(this.player, undefined);
      this.updateExps(this.player, {});
      this.selectedUnits = [this.player];
      this.units = [
        this.player,
        ...sessionInfo.units.map((i) => {
          const unit = new Unit();
          this.updateProps(unit, i);
          unit.life = (i.life || 1) * this.session.args.MAX_LIFE;
          unit.id = i.id;
          unit.name = i.name || i.id || "野怪";
          unit.group = i.group;
          if (unit.group === undefined) {
            unit.group = GROUP_B;
          }
          unit.icon = i.icon && this.session.images?.[i.icon];
          unit.sprite = i.sprite;
          unit.movable = i.movable || false;
          unit.money = i.money || 0;
          unit.isWall = i.isWall || false;
          if (typeof i.when === "string") {
            unit.when = cloneObject(this.session.whens?.[i.when]);
          } else if (i.when?.ref) {
            const refs = Array.isArray(i.when.ref)
              ? i.when.ref
              : [i.when.ref];
            const mergeWhens = (whens) => {
              let when = {};
              for (let w of whens) {
                for (let p in w) {
                  when[p] = (when[p] || []).concat(w[p] || []);
                }
              }
              return when;
            };
            unit.when = Object.assign(
              mergeWhens(
                refs.map((ref) => cloneObject(this.session.whens?.[ref]))
              ),
              { _args: { ...i.when, ref: undefined } }
            );
          } else {
            unit.when = i.when;
          }
          unit.ghost = i.ghost;
          this.learnSkillsByName(unit, i.skills);
          unit.initPos = this.session.floors[i.floor].cells[i.y][i.x];
          this.moveTo(unit);
          this.updateExps(unit, {});
          return unit;
        }),
      ];
      this.units.forEach((u) => {
        if (u.id) {
          session.unitIds[u.id] = u;
        }
      });
      this.resize();
    }

    createFloors(sessionInfo, session) {
      return sessionInfo.floors.map((f, floor) => {
        let floorObj = {};
        if (this.editing) {
          const props = ["name", "cells"];
          registerProperties(floorObj, ...props);
        }
        Object.assign(floorObj, f);
        floorObj.cells = f.cells.map((ys, y) =>
          Array.from(ys, (xs, x) => {
            const c = {};
            if (this.editing) {
              registerProperties(c, ...this.editingCellProps);
            }
            c.floor = floor;
            c.x = x;
            c.y = y;
            c.prop = this.PROPS[1 * xs - 1];
            if (xs === "0") {
              c.type = "Wall";
            } else if (xs === "+") {
              c.type = "Wall";
              c.isCorner = true;
            } else if (xs === "_") {
              c.type = "Wall";
              c.empty = true;
            } else {
              c.type = "Floor";
            }
            if (!session.customeCorner) {
              if (
                x === ys.length - 1 ||
                x === 0 ||
                y === f.cells.length - 1 ||
                y === 0
              ) {
                c.isCorner = true;
              }
            }
            registerProperties(c, "isWall", "visited", "nearby");
            return c;
          })
        );
        floorObj.theme = Object.assign(
          {},
          session.theme,
          f.theme === undefined || typeof f.theme === "string"
            ? session.themes?.[f.theme || "defalut"]
            : f.theme
        );
        if (floorObj.theme?.bgImg) {
          floorObj.theme.bgImg = session.images?.[floorObj.theme.bgImg];
        }
        floorObj.id = floor;
        return floorObj;
      });
    }

    learnSkillsByName(unit, skillNames, isPlayer) {
      let skills = (skillNames || [])
        .map((n) => this.session.skillsObj[n])
        .filter((s) => s);
      this.learnSkills(unit, skills, isPlayer);
    }

    updateBuffers(unit) {
      const activedSkills = unit.skills.filter(
        (s) => !s.positive || s.last > 0
      );
      unit.activedSkills = activedSkills;
      unit.realActivedSkills = activedSkills.filter((s) => !s.obj);
      const buffers = activedSkills.map((s) => s.buffers || []).flat();
      const bufferDict = new Map();
      for (let b of buffers) {
        let buffer = bufferDict.get(b.arg);
        if (!buffer) {
          buffer = { arg: b.arg };
          bufferDict.set(b.arg, buffer);
        }
        buffer.value = (buffer.value || 0) + (b.value || 0);
      }
      unit.buffers = this.createDefaultZeroProxy(
        Array.from(bufferDict.values())
          .map(({ arg, value }) => [arg, value])
          .obj()
      );
      unit.filters = Array.from(
        new Set(activedSkills.map((s) => s.filters || []).flat())
      )
        .map((f) => "b-" + f)
        .join(" ");
    }

    createDefaultZeroProxy(value, withSet = false) {
      return new Proxy(value, {
        get: function (obj, prop) {
          return prop in obj ? obj[prop] : 0;
        },
        set: withSet
          ? function (obj, prop, value) {
            obj[prop] = value;
          }
          : undefined,
      });
    }

    useSkill(unit, skill) {
      if (this.batting || this.autoRunning) {
        return;
      }
      if (!skill.positive) {
        return;
      }
      if (skill.cooldown > 0) {
        return;
      }
      let cast = 0;
      if (skill.cast) {
        cast = skill.cast * this.session.args.RATE_USE_SKILL;
        if (this.player.money < cast) {
          this.modal_.toast("金币不足");
          return;
        }
      }
      if (skill.count !== undefined) {
        if (skill.count <= 0) {
          return;
        }
        skill.count = skill.count - 1;
      }
      this.player.money = this.player.money - cast;
      skill.cooldown = skill.positive.cooldown;
      skill.last = skill.positive.last;
      this.updateBuffers(unit);
    }

    updateSkillPositive(unit, skill) {
      if (!skill.positive) {
        return;
      }

      skill.cooldown = Math.max(
        0,
        (skill.cooldown || 0) -
        1 /
        Math.max(
          0.00001,
          (1 + unit.buffers.pSkillCooldown) *
          this.session.args.P_SKILL_COOLDOWN
        )
      );
      // console.log(skill.cooldown)
      if (skill.last > 0) {
        skill.last = Math.max(0, (skill.last || 0) - 1);
        if (skill.last === 0) {
          this.updateBuffers(unit);
        }
      }
      if (skill.count === 0 && !skill.last) {
        this.forgetSkills(unit, [skill]);
      }
    }

    forgetSkills(unit, skills) {
      let forgetDict = new Map(skills.map((s) => [s.name, s]));
      let remainSkills = unit.skills.filter((s) => !forgetDict.has(s.name));
      this.updateSkills(unit, remainSkills, unit === this.player);
    }

    updateSkills(unit, skills, isPlayer) {
      unit.skills = skills;
      unit.positiveSkills = unit.skills.filter((s) => s.positive);
      unit.soldableSkills = unit.skills.filter((s) => s.soldable);
      if (isPlayer) {
        let skillsDict = new Map((unit.skills || []).map((s) => [s.name, s]));
        this.unLeartSkills = this.session.skills.filter(
          (s) => (s.count !== undefined || !skillsDict.has(s.name)) && s.level
        );
        this.positiveSkills = unit.positiveSkills;
        this.soldableSkills = unit.soldableSkills;
      }
      this.updateBuffers(unit);
    }

    learnSkills(unit, skills, isPlayer) {
      let skillsDict = new Map((unit.skills || []).map((s) => [s.name, s]));
      for (let s of skills || []) {
        s = new Skill(s);
        let existedSkill = skillsDict.get(s.name);
        if (!existedSkill) {
          skillsDict.set(s.name, s);
        } else {
          if (existedSkill.count !== undefined) {
            if (s.count !== undefined) {
              existedSkill.count += s.count || 0;
            } else {
              skillsDict.set(s.name, s);
            }
          }
          if (s.last !== undefined) {
            existedSkill.last = s.last;
          }

          if (s.cooldown !== undefined) {
            existedSkill.cooldown = s.cooldown;
          }
        }
      }
      this.updateSkills(unit, Array.from(skillsDict.values()), isPlayer);
    }

    async buyAndLearnSkill(skill) {
      const cast = skill.level * this.session.args.RATE_BUY;
      if (this.player.money < cast) {
        await this.modal_.toast("金币不足");
        return;
      }
      this.player.money = this.player.money - cast;
      this.learnSkills(this.player, [skill], true);
      await this.modal_.toast(`已购买${skill.name}`);
    }

    async sellSkill(skill) {
      const cast = skill.level * this.session.args.RATE_SELL;
      this.player.money = this.player.money + cast;
      this.forgetSkills(this.player, [skill]);
      await this.modal_.toast(`已出售${skill.name}`);
    }

    outofDisplayRange({ x, y }) {
      return (
        x < this.dx ||
        y < this.dy ||
        x >= this.dx + this.displayFloor[0].length ||
        y >= this.dy + this.displayFloor.length
      );
    }

    async getCommands(source, target) {
      const cells = this.floor.cells.map((column, y) =>
        column.map((c, x) => {
          if (this.outofDisplayRange({ x, y })) {
            return 0;
          }
          return (!this.isWallCell(c) && !c.isInEntry) || c === target
            ? 1
            : 0;
        })
      );
      // for (let unit of this.units) {
      //   if (unit.died || unit.position.floor !== this.floorId) {
      //     continue
      //   }
      //   cells[unit.position.y][unit.position.x] = 0
      // }
      const graph = new astarG(cells);
      const start = graph.grid[source.y][source.x];
      const end = graph.grid[target.y][target.x];
      const result = astar.search(graph, start, end);
      const commands = [];
      let current = start;
      for (let i = 0; i < result.length; i++) {
        commands.push({
          dy: result[i].x - current.x,
          dx: result[i].y - current.y,
        });
        current = result[i];
      }
      return commands;
    }

    async touchUnit(unit) {
      await this.touchCell(unit.position);
    }

    isWallCell(cell) {
      return cell && (cell.isWall || cell.type === "Wall");
    }

    exitAllEditingMode(unselect = false) {
      if (!this.editing) {
        return;
      }
      this.exitEditUnit();
      this.exitEditingEntry();
      this.exitEditingCell();
      if (unselect) {
        this.selectedCell = undefined;
      }
    }

    exitEditingCell() {
      this.editingCell = false;
      this.lastEditingCell = undefined;
    }

    startEditingCell(id) {
      let alreadlyEditingCell = this.editingCell;
      this.exitAllEditingMode();
      this.editingCell = true;
      if (id !== undefined) {
        this.currentModifierIdx = id;
        if (this.selectedCell && alreadlyEditingCell) {
          if (this.selectedCell === this.lastEditingCell) {
            this.currentModifierIdx = id - 1;
          }
          this.touchCell(this.selectedCell);
        }
      }
    }
    async touchCell(cell) {
      let lastCell = this.selectedCell;
      if (this.editing) {
        this.moveTo(this.player, cell);
        if (this.currentUnit) {
          this.selectedCell = cell;
          let nonPlayerUnits = cell.units?.filter((u) => u !== this.player);
          if (nonPlayerUnits?.length) {
            if (nonPlayerUnits.some((u) => u === this.currentUnit)) {
              // await this.exitEditUnit()
              if (!this.isEditingUnit) {
                this.isEditingUnit = true;
              } else {
                this.startEditingUnitDetail(this.currentUnit);
              }
              return;
            } else {
              this.currentUnit = nonPlayerUnits[0];
              return;
            }
          }
          if (this.isEditingUnit) {
            await this.moveTo(this.currentUnit, cell);
            return;
          }
        }
        if (this.currentEntry) {
          this.selectedCell = cell;
          let selectedEntry = this.editingEntries.find(
            (e) => e.start === cell || e.end === cell
          );
          if (selectedEntry) {
            if (this.currentEntry === selectedEntry) {
              // this.exitEditingEntry()
              this.isEditingEntry = true;
              this.selectedCell = cell;
              return;
            }
            this.currentEntry = selectedEntry;
            this.currentEntryFirst = cell === this.currentEntry.start;
            return;
          }
          if (!this.isEditingEntry) {
            this.exitEditingEntry();
            return;
          }
          if (cell.type !== "Floor") {
            cell.type = "Floor";
            cell.prop = this.PROPS[0];
            cell.empty = undefined;
            cell.isCorner = undefined;
            // cell = undefined
          }
          this.clearEntryConnections(this.currentEntry);
          if (this.currentEntryFirst) {
            this.currentEntry.start = cell;
          } else {
            this.currentEntry.end = cell;
          }
          this.updateEntryConnections(this.currentEntry);
        }
        if (this.editingCell) {
          this.currentModifierIdx =
            this.lastEditingCell === cell
              ? (this.currentModifierIdx + 1) % this.cellModifiers.length
              : this.currentModifierIdx;
          this.lastEditingCell = cell;
          this.selectedCell = cell;
          cell.type = undefined;
          cell.empty = undefined;
          cell.isCorner = undefined;
          cell.prop = undefined;
          this.cellModifiers[this.currentModifierIdx](cell);
          return;
        }
        this.selectedCell = cell;
        let unit = this.selectedCell.units?.find(
          (u) => u !== this.player && !u.died && !u.ghost && !u.isWall
        );
        if (unit) {
          this.locateUnit(unit, true);
          return;
        }
        this.exitEditUnit();
        let e = this.editingEntries.find(
          (e) => e.start === cell || e.end === cell
        );
        if (e) {
          this.currentEntry = e;
          this.currentEntryFirst = cell === e.start;
          return;
        }
        this.exitEditingEntry();
        // if (lastCell === this.selectedCell) {
        //   this.editingCell = true
        // }
        return;
      }
      if (this.isWallCell(cell)) {
        this.selectedUnits = [this.player];
        return;
      }
      let doubleTouch = this.selectedUnits[1]?.position === cell;
      if (!doubleTouch) {
        if (cell.units?.length) {
          let selectedUnits = cell.units.filter(
            (u) => u !== this.player && !u.died && !u.ghost
          );
          if (selectedUnits.length) {
            this.selectedUnits = [this.player, ...selectedUnits];
            return;
          }
        }
      }

      if (cell === this.player.position) {
        return;
      }

      const commands = await this.getCommands(this.player.position, cell);
      if (!commands.length) {
        return;
      }
      this.autoRunning = true;
      for (let command of commands) {
        if (!this.autoRunning) {
          break;
        }
        await this.tryMove(command.dx, command.dy, true);
        await sleep(100);
      }
      this.autoRunning = false;
    }

    async onPosition(position, event) {
      if (!position?.units.length) {
        return;
      }
      await this.whenUnits(
        this.player,
        position.units.filter((u) => u !== this.player && !u.died),
        event
      );
    }

    getNearByPositions(cell) {
      if (!cell) {
        return [];
      }
      let distance = this.session.args.DISTANCE_SHADOW;
      if (!distance) {
        return [];
      }
      distance = distance - 1;
      let cells = this.session.floors[cell.floor].cells;
      let nearbys = Array.from({ length: 2 * distance + 1 }, (_y, y) =>
        Array.from({ length: 2 * distance + 1 }, (_x, x) => {
          let dx = x - distance;
          let dy = y - distance;
          let ncell = cells[cell.y + dy]?.[cell.x + dx];
          return {
            dx,
            dy,
            cell: ncell,
          };
        })
      );
      let walls = nearbys.map((col) =>
        col.map(({ cell }) => this.isWallCell(cell))
      );
      const visiable = ({ dx, dy, cell }) => {
        if (!cell) {
          return false;
        }
        // let d = Math.hypot(dx, dy);//Math.max(Math.abs(dx), Math.abs(dy))
        // return d <= distance
        let d = Math.max(Math.abs(dx), Math.abs(dy));
        if (d <= 0) {
          return true;
        }
        // return false
        if (d <= 0) {
          return true;
        }
        let stepX = dx / d;
        let stepY = dy / d;
        for (let i = 1; i < d; i++) {
          let x = i * stepX;
          let y = i * stepY;
          // let xs = Array.from(new Set([Math.floor(x), Math.ceil(x)]))
          // let ys = Array.from(new Set([Math.floor(y), Math.ceil(y)]))
          const di = 0;
          let xs = [(x - di).toFixed() * 1, (x + di).toFixed() * 1];
          let ys = [(y - di).toFixed() * 1, (y + di).toFixed() * 1];
          let xys = xs.map((x) => ys.map((y) => [x, y])).flat();
          let visiable = false;
          for (let [x, y] of xys) {
            if (x === dx && y === dy) {
              continue;
            }
            if (!walls[y + distance][x + distance]) {
              visiable = true;
              break;
            }
          }
          if (!visiable) {
            return false;
          }
        }
        return true;
      };
      return nearbys
        .flat()
        .filter((c) => visiable(c))
        .map((c) => c.cell);
    }

    async moveTo(unit, position, ignoreWhens) {
      unit.moving = true;
      if (unit.position?.units) {
        unit.position.units = unit.position.units.filter((u) => u !== unit);
        unit.position.isWall = unit.position.units.some((u) => u.isWall);
        if (
          !ignoreWhens &&
          this.player === unit &&
          unit.position !== position
        ) {
          await this.onPosition(unit.position, "leave");
        }
      }
      if (unit === this.player && unit.position) {
        for (let pos of this.getNearByPositions(unit.position)) {
          pos.nearby = undefined;
          pos.units?.forEach((u) => (u.nearby = undefined));
        }
      } else {
        unit.position?.units?.forEach(
          (u) => (u.nearby = unit.position.nearby)
        );
      }
      const movingToken = {};
      unit.movingToken = movingToken;
      position = position || unit.initPos;
      const currentProps = this.PROPS.map((p) => [
        p,
        unit[p] + (position.prop === p ? this.session.args.BUFF : 0),
      ]);
      const current = currentProps.obj();
      current.total = currentProps.reduce((s, i) => s + i[1], 0);
      current.ave = current.total / this.PROPS.length;
      this.PROPS.forEach(
        (p) => (current["d" + p] = current[p] - current.ave)
      );
      unit.current = current;
      unit.position = position;
      if (!unit.position.units) {
        unit.position.units = [];
      }
      unit.position.units = [unit, ...(unit.position.units || [])];
      unit.position.isWall = unit.position.units.some((u) => u.isWall);
      if (unit === this.player && unit.position) {
        for (let pos of this.getNearByPositions(unit.position)) {
          pos.nearby = true;
          pos.visited = true;
          pos.units?.forEach((u) => (u.nearby = true));
        }
      } else {
        unit.position.units.forEach((u) => (u.nearby = unit.position.nearby));
      }
      sleep(500).then(() => {
        if (unit.movingToken === movingToken) {
          unit.moving = false;
        }
      });
      if (unit !== this.player) {
        return;
      }
      this.selectedUnits = [...(this.selectedUnits ?? [])];
      if (
        this.floor.cells.length <= this.data.MAX_DISPLAY_CELLS_SIZE &&
        this.floor.cells[0].length <= this.data.MAX_DISPLAY_CELLS_SIZE
      ) {
        this.dx = 0;
        this.dy = 0;
        this.displayFloor = this.floor.cells;
        if (!ignoreWhens) {
          await this.onPosition(position, "enter");
        }
        return;
      }
      const height = Math.min(
        this.floor.cells.length,
        this.data.MAX_DISPLAY_CELLS_SIZE
      );
      const width = Math.min(
        this.floor.cells[0].length,
        this.data.MAX_DISPLAY_CELLS_SIZE
      );
      let dx = this.dx;
      let dy = this.dy;
      let keep = this.editing ? 3 : 2;
      if (dx + keep - 1 > this.player.position.x) {
        dx = Math.max(0, this.player.position.x - keep + 1);
      }
      if (dx + width - keep < this.player.position.x) {
        dx = Math.min(
          this.player.position.x + keep - width,
          this.floor.cells[0].length - width
        );
      }
      if (dy + keep - 1 > this.player.position.y) {
        dy = Math.max(0, this.player.position.y - keep + 1);
      }
      if (dy + height - keep < this.player.position.y) {
        dy = Math.min(
          this.player.position.y + keep - height,
          this.floor.cells.length - height
        );
      }
      this.dx = dx;
      this.dy = dy;
      this.displayFloor = this.floor.cells
        .slice(dy, height + dy)
        .map((l) => l.slice(dx, width + dx));
      if (!ignoreWhens) {
        await this.onPosition(position, "enter");
      }
    }

    updateProps(unit, { jin, mu, shui, huo, tu }) {
      unit.jin = Math.min(this.session.args.MAX_LEVEL, jin || 0);
      unit.mu = Math.min(this.session.args.MAX_LEVEL, mu || 0);
      unit.shui = Math.min(this.session.args.MAX_LEVEL, shui || 0);
      unit.huo = Math.min(this.session.args.MAX_LEVEL, huo || 0);
      unit.tu = Math.min(this.session.args.MAX_LEVEL, tu || 0);
      let mainProps = [];
      let maxP = 0;
      let total = 0;
      for (let prop of this.PROPS) {
        total += unit[prop];
        if (unit[prop] > maxP) {
          mainProps = [prop];
          maxP = unit[prop];
        } else if (unit[prop] === maxP) {
          mainProps.push(prop);
        }
      }
      unit.mainProps = mainProps;
      let mainPropsSet = new Set(mainProps);
      const p = 100 / (mainProps.length || 1);
      let cp = 0;
      for (let prop of this.PROPS) {
        const pp = "p" + prop[0].toUpperCase() + prop.slice(1);
        if (mainPropsSet.has(prop)) {
          cp += p;
        }
        unit[pp] = cp.toFixed(1) + "%";
      }
      const newLevel = maxP; //Math.floor(total / ELEMENTS_COUNT)
      if (newLevel > unit.level) {
        unit.life = this.session.args.MAX_LIFE;
      }
      unit.level = Math.min(newLevel, this.session.args.MAX_LEVEL);
    }

    async loadFloor(floorId) {
      this.selectedCell = undefined;
      this.floorId = floorId;
      this.floor = this.session.floors[this.floorId];
      this.floorName = this.floor.name;
      await this.resize();
      if (this.editing) {
        this.moveTo(this.player, this.floor.cells[0][0]);
      }
      if (this.session.floors.length > 1) {
        this.modal_.toast(`进入第${this.floorId + 1}层`);
      }
    }

    async insertFloor(after = false) {
      let sessionInfo = await this.createTmpSessionInfo(
        this.floor.cells[0].length,
        this.floor.cells.length,
        1
      );
      let floor = (await this.createFloors(sessionInfo, this.session))[0];
      let start = floor.cells[sessionInfo.start.y][sessionInfo.start.x];
      start.isStart = true;
      let end = floor.cells[sessionInfo.end.y][sessionInfo.end.x];
      end.isEnd = true;
      let id = this.floorId + (after ? 1 : -1);
      if (id < 0) {
        this.session.floors.unshift(floor);
      } else {
        this.session.floors.splice(id, 0, floor);
      }
      this.editingFloors = [...this.session.floors];
      this.editingEntries = [
        ...this.editingEntries,
        createEntryObj(undefined, start, 1),
        createEntryObj(end, undefined, 1),
      ];
      this.currentEntry = undefined;
      this.currentEntryFirst = undefined;
      this.selectedCell = undefined;
      this.updateFloorConnections();
      await this.loadFloor(floor.id);
    }

    updateFloorConnections() {
      this.editingFloors.forEach((f, i) => {
        f.id = i;
        f.cells.forEach((l) => l.forEach((c) => (c.floor = i)));
      });
    }

    async deleteFloor() {
      if (this.session.floors.length <= 1) {
        return;
      }
      let floor = this.floor;
      this.session.floors = this.session.floors.filter((f) => f !== floor);
      for (let e of this.editingEntries) {
        let needUpdate = false;
        if (e.start?.floor === floor.id) {
          e.start = undefined;
          needUpdate = true;
        }
        if (e.end?.floor === floor.id) {
          e.end = undefined;
          needUpdate = true;
        }
        if (needUpdate) {
          this.updateEntryConnections(e);
          if (this.currentEntry === e) {
            this.currentEntry = undefined;
            this.currentEntryFirst = undefined;
          }
        }
      }
      this.editingFloors = [...this.session.floors];
      this.updateFloorConnections();
      let floorId = this.floorId % this.session.floors.length;
      await this.loadFloor(floorId);
    }

    async setCurrentEntry(e, first) {
      this.exitAllEditingMode();
      if (this.currentEntry === e && this.currentEntryFirst === first) {
        this.exitEditingEntry();
        return;
      }
      this.isEditingEntry = true;
      this.currentEntry = e;
      this.currentEntryFirst = first;
      let { start, end, direction } = e;
      let target = first ? start : end;
      if (target) {
        if (this.floorId != target.floor) {
          await this.loadFloor(target.floor);
        }
        this.selectedCell = target;
      }
    }

    toggleEntry(e) {
      let { direction } = e;
      if (direction === 1) {
        direction = -1;
      } else if (direction === -1) {
        direction = 0;
      } else {
        direction = 1;
      }
      e.direction = direction;
      this.updateEntryConnections(e);
    }

    deleteEntry(e) {
      this.clearEntryConnections(e);
      if (this.currentEntry === e) {
        this.exitEditingEntry();
      }
      this.editingEntries = this.editingEntries.filter((en) => en != e);
    }

    exitEditingEntry() {
      this.isEditingEntry = undefined;
      this.currentEntry = undefined;
      this.currentEntryFirst = undefined;
    }

    async createEntry() {
      await this.exitEditUnit();
      let e = createEntryObj(this.selectedCell, undefined, 0);
      this.editingEntries = [e, ...this.editingEntries];
      this.currentEntry = e;
      this.currentEntryFirst = true;
      this.isEditingEntry = true;
      this.updateEntryConnections(e);
    }

    sortEntry(end = false) {
      const getOrder = (cell) => {
        if (!cell) {
          return 0;
        }
        let { floor, x, y } = cell;
        const pFloor = 1000;
        const pY = 1;
        const pX = 0.001;
        return floor * pFloor + x * pX + y * pY;
      };
      const compare = (left, right) => getOrder(left) - getOrder(right);
      this.editingEntries = [...this.editingEntries].sort((i, j) =>
        !end ? compare(i.start, j.start) : compare(i.end, j.end)
      );
    }

    clearEntryConnections(e) {
      [e.start, e.end].forEach((c) => {
        if (c) {
          c.isInEntry = undefined;
          c.isOutEntry = undefined;
          c.target = undefined;
          c.isStart = undefined;
          c.isEnd = undefined;
        }
      });
    }

    updateEntryConnections(e) {
      this.clearEntryConnections(e);
      if (!e.start && !e.end) {
        return;
      }
      if (e.start && e.end) {
        if (e.direction !== -1) {
          e.start.isInEntry = true;
          e.start.target = e.end;
          e.end.isOutEntry = true;
        }
        if (e.direction !== 1) {
          e.end.isInEntry = true;
          e.end.target = e.start;
          e.start.isOutEntry = true;
        }
        return;
      }
      if (e.direction !== -1 && e.direction !== 1) {
        return;
      }
      let [target, endDir] = e.start ? [e.start, 1] : [e.end, -1];
      if (target) {
        if (e.direction === endDir) {
          target.isEnd = true;
        } else {
          target.isStart = true;
        }
      }
    }

    async onKeyDown($event) {
      if (!this.editing && $event.ctrlKey && $event.code === "KeyE") {
        await this.createSession();
        return;
      }
      if (this.editing && $event.ctrlKey && $event.code === "KeyR") {
        if (this.editingResult) {
          await this.exitEditing();
          return;
        }
        await this.generateEditingResult();
        return;
      }
      if (this.editing && $event.ctrlKey && $event.code === "KeyS") {
        if (this.editingResult) {
          await this.saveSessionInfo();
          return;
        }
        await this.generateEditingResult();
        return;
      }
      if (this.showConsole) {
        if ($event.code === "Enter") {
          this.executeConsole();
        } else if ($event.key === "Escape") {
          this.showConsole = undefined;
        }
        return;
      }
      for (let p of ["editingResult", "editingUnit"]) {
        if (this[p]) {
          if ($event.key === "Escape") {
            this[p] = undefined;
          }
          return;
        }
      }
      if ($event.ctrlKey && $event.code === "KeyP") {
        this.setConsole(!this.showConsole);
        return;
      }
      if (this.editing) {
        switch ($event.code) {
          case "Escape":
            this.exitAllEditingMode();
            return;
        }
        if ($event.ctrlKey) {
          let i = $event.key * 1 - 1;
          if (this.cellButtons[i]) {
            this.cellButtons[i].invoke();
            return;
          }
        }
        if (!this.editingCell && !$event.ctrlKey) {
          let i = $event.key * 1 - 1;
          if (this.cellModifiers[i]) {
            this.startEditingCell(i);
            return;
          }
        }
      }
      if (this.selectedCell) {
        if (!this.floor) {
          this.selectedCell = undefined;
          return;
        }
        const moveSelectedCell = async (dx, dy) => {
          let newCell = this.floor.cells[this.selectedCell.y + dy]?.[
            this.selectedCell.x + dx
          ];
          if (newCell && !this.outofDisplayRange(newCell)) {
            this.selectedCell = newCell;
          }
          if (this.editing) {
            this.moveTo(this.player, this.selectedCell);
          }
        };
        switch ($event.code) {
          case "Escape":
            this.selectedCell = undefined;
            if (this.editing) {
              this.exitEditingEntry();
              this.exitEditUnit();
            }
            return;
          case "Space":
          case "Enter":
            if (this.editing) {
              await this.touchCell(this.selectedCell);
            } else {
              let cell = this.selectedCell;
              this.selectedCell = undefined;
              await this.touchCell(cell);
            }
            return;
          case "ArrowLeft":
            return await moveSelectedCell(-1, 0);
          case "ArrowUp":
            return await moveSelectedCell(0, -1);
          case "ArrowRight":
            return await moveSelectedCell(1, 0);
          case "ArrowDown":
            return await moveSelectedCell(0, 1);
        }
        if (this.editing) {
          let i = $event.key * 1 - 1;
          if (this.cellModifiers[i]) {
            if (this.lastEditingCell === this.selectedCell) {
              i--;
            }
            this.currentModifierIdx = i;
            await this.touchCell(this.selectedCell);
          }
        }
        return;
      }
      if (this.editing) {
        if ($event.code === "Enter" || $event.code === "Space") {
          if (
            this.lastEditingCell &&
            this.lastEditingCell.floor === this.floorId
          ) {
            this.selectedCell = this.lastEditingCell;
          } else {
            this.selectedCell = this.floor.cells[0][0];
          }
          return;
        }
        return;
      }
      if (this.currentAction) {
        const moveAnswer = (d) => {
          let length = this.currentAction.answers?.length;
          if (!length) {
            return;
          }
          let idx = this.currentAction.answers.findIndex(
            (a) => a === this.currentAction.currentAnswer
          );
          idx += d;
          idx = (idx + length) % length;
          this.currentAction.currentAnswer = this.currentAction.answers[idx];
          this.currentAction = { ...this.currentAction };
        };
        switch ($event.code) {
          case "Escape":
            await this.reply();
            return;
          case "Space":
          case "Enter":
            await this.reply(this.currentAction.currentAnswer);
            return;
          case "ArrowLeft":
          case "ArrowUp":
            moveAnswer(-1);
            return;
          case "ArrowRight":
          case "ArrowDown":
            moveAnswer(1);
            return;
          default:
            let i = $event.key * 1;
            let ans = this.currentAction.answers?.[i - 1];
            if (ans) {
              await this.reply(Array.isArray(ans) ? ans[1] : ans);
            }
            return;
        }
      }
      if (this.showHelp) {
        if ($event.code === "Escape") {
          this.showHelp = false;
        }
        return;
      }
      let skill = this.player?.positiveSkills?.[$event.key * 1 - 1];
      if (skill) {
        await this.useSkill(this.player, skill);
        return;
      }
      if (this.success) {
        await this.loadSession(this.currentSessionId + 1);
        return;
      }
      switch ($event.code) {
        case "Escape":
          this.showHelp = !this.showHelp;
          return;
        case "Space":
        case "Enter":
          if (this.player) {
            this.selectedCell = this.player.position;
          }
          return;
        case "ArrowLeft":
          return await this.tryMove(-1, 0);
        case "ArrowUp":
          return await this.tryMove(0, -1);
        case "ArrowRight":
          return await this.tryMove(1, 0);
        case "ArrowDown":
          return await this.tryMove(0, 1);
        // case "KeyR":
        //   return await this.restart()
        default:
          // console.log($event.code)
          return;
      }
    }

    async restart() {
      await this.loadSession(this.data.sessions ? this.currentSessionId : 0);
    }

    generateCurrentSessionInfo() {
      let sessionInfo = {
        player: {},
        start: {},
        end: {},
        entries: [],
        units: [],
        args: cloneObject(this.session.args),
        floors: [],
        customeCorner: true,
      };
      if (this.sessionName) {
        sessionInfo.name = this.sessionName;
      }
      let entries = [];
      let starts = [];
      let ends = [];
      const createEntryT = (c) => ({ floor: c.floor, x: c.x, y: c.y });
      const createUnit = (u) => {
        let unit = {};
        if (u.group !== undefined) {
          unit.group = u.group;
        }
        for (let p of this.PROPS) {
          if (u[p]) {
            unit[p] = u[p];
          }
        }
        for (let p of [
          "name",
          "movable",
          "ghost",
          "money",
          "died",
          "when",
          "sprite",
          "id",
          "isWall",
        ]) {
          if (u[p]) {
            unit[p] = u[p];
          }
        }
        if (unit.when) {
          delete unit.when._stores;
          delete unit.when._args;
        }
        return unit;
      };
      const createUnitWithPos = (u) => {
        let unit = createUnit(u);
        let pos = createEntryT(u.position);
        return Object.assign({}, unit, pos);
      };
      sessionInfo.player = createUnit(this.player);
      for (let e of this.editingEntries) {
        if (e.start && e.end) {
          entries.push([
            ...(e.direction !== -1 ? [e.start, e.end] : [e.end, e.start]).map(
              createEntryT
            ),
            !e.direction,
          ]);
        }
        for (let c of [e.start, e.end]) {
          if (!c) {
            continue;
          }
          if (c.isStart) {
            starts.push(c);
          }
          if (c.isEnd) {
            ends.push(c);
          }
        }
      }
      for (let u of this.units) {
        if (u === this.player) {
          continue;
        }
        sessionInfo.units.push(createUnitWithPos(u));
      }
      for (let f of this.session.floors) {
        let floor = {};
        if (f.name) {
          floor.name = f.name;
        }
        floor.cells = f.cells.map((l) =>
          l
            .map((c) => {
              if (c.type === "Wall") {
                if (c.isCorner) {
                  return "+";
                }
                if (c.empty) {
                  return "_";
                }
                return "0";
              }
              if (c.type === "Floor") {
                return this.PROPSIDS[c.prop] || "0";
              }
            })
            .join("")
        );
        sessionInfo.floors.push(floor);
      }
      if (starts.length) {
        sessionInfo.start = createEntryT(starts[0]);
      }
      if (ends.length) {
        sessionInfo.end = createEntryT(ends[0]);
      }
      sessionInfo.entries = entries;
      return { sessionInfo, starts, entries };
    }

    async generateEditingResult() {
      const {
        sessionInfo,
        starts,
        entries,
      } = this.generateCurrentSessionInfo();
      this.lastEditingSessionInfo = sessionInfo;
      this.editingResult = JSON.stringify(sessionInfo, null, 2);
      this.editingResultInfo = `起点数:${starts.length}
终点数${starts.length}
楼层数${sessionInfo.floors.length}
通道数${entries.length}
`;
    }

    async exportDotStory() {
      const storyName = this.lastEditingSessionInfo.name;
      const story = {
        sessions: Object.fromEntries(
          this.lastEditingSessionInfo.floors.map((f, i) => {
            const sessionName = f.name || `SessionNo.${i + 1}`;
            const width = f.cells[0].length;
            const height = f.cells.length;
            const walls = f.cells.map((col) =>
              Array.from(col, (cell) => {
                switch (cell) {
                  case "0":
                  case "$":
                    return "2";
                  case "1":
                  case "2":
                  case "3":
                  case "4":
                  case "5":
                    return "1";
                  default:
                    return "0";
                }
              }).join("")
            );
            const terrains = f.cells.map((col) =>
              Array.from(col, (cell) => {
                switch (cell) {
                  case "1":
                    return "0";
                  case "2":
                    return "1";
                  case "3":
                    return "2";
                  case "4":
                    return "3";
                  case "5":
                    return "4";
                  default:
                    return "4";
                }
              }).join("")
            );
            const starts = [];
            const ends = [];
            for (let [start, end] of this.lastEditingSessionInfo.entries) {
              if (start.floor !== i || end.floor !== i) {
                continue;
              }
              starts.push({ x: start.x, y: start.y });
              ends.push({ x: end.x, y: end.y });
            }
            return [
              sessionName,
              { width, height, walls, terrains, starts, ends },
            ];
          })
        ),
      };
      await this.prompt("塔防地图", JSON.stringify(story.sessions));
    }

    async deleteSessionInfo() {
      if (!(await this.confirm("确认删除"))) {
        return;
      }
      if (this.lastEditingSessionInfo?.name) {
        delete this.editingSessionInfos.infos[
          this.lastEditingSessionInfo.name
        ];
        this.editingSessionInfos.current = undefined;
        await this.localStorage.setItem(
          LAST_EDITING_SESSION_INFOS_KEY,
          JSON.stringify(this.editingSessionInfos)
        );
      }
      this.lastEditingSessionInfo = undefined;
      this.sessionInfo = undefined;
      this.editingResult = undefined;
      this.editingResultInfo = undefined;
      await this.modal_.toast("已删除");
      await this.restart();
    }

    async saveSessionInfo() {
      if (!this.lastEditingSessionInfo) {
        return;
      }
      if (!this.lastEditingSessionInfo.name) {
        let name = (await this.prompt("关卡名称"))?.trim();
        if (!name) {
          return;
        }
        this.lastEditingSessionInfo.name = name;
        this.session.name = name;
        this.sessionName = name;
      }
      this.editingSessionInfos.infos[
        this.lastEditingSessionInfo.name
      ] = this.lastEditingSessionInfo;
      this.editingSessionInfos.current = this.lastEditingSessionInfo.name;
      await this.localStorage.setItem(
        LAST_EDITING_SESSION_INFOS_KEY,
        JSON.stringify(this.editingSessionInfos)
      );
      await this.modal_.toast("已保存");
    }

    async reloadEditing() {
      try {
        this.lastEditingSessionInfo = JSON.parse(this.editingResult);
      } catch {
        await this.modal_.toast("非法数据");
        return;
      }
      this.editingResult = undefined;
      this.editingResultInfo = undefined;
      this.sessionInfo = this.lastEditingSessionInfo;
      this.currentUnit = undefined;
      this.currentEntry = undefined;
      this.currentEntryFirst = undefined;
      this.selectedCell = undefined;
      await this.restart();
    }

    async exitEditing() {
      this.editing = false;
      this.editingResult = undefined;
      this.editingResultInfo = undefined;
      this.sessionInfo = this.lastEditingSessionInfo;
      this.currentUnit = undefined;
      this.currentEntry = undefined;
      this.currentEntryFirst = undefined;
      this.selectedCell = undefined;
      await this.restart();
    }

    async close() {
      await this.saveApp();
      await Api.appService.close();
    }

    async updateExps(unit, dexps) {
      const exp = {};
      const requireExp = {};
      const newProps = {
        jin: unit.jin,
        mu: unit.mu,
        shui: unit.shui,
        huo: unit.huo,
        tu: unit.tu,
      };
      for (let prop of this.PROPS) {
        exp[prop] = (unit.exp?.[prop] || 0) + (dexps[prop] || 0);
        requireExp[prop] = this.calculator.upExp(unit, newProps[prop]);
        while (true) {
          if (exp[prop] >= requireExp[prop]) {
            newProps[prop] += 1;
            exp[prop] = exp[prop] - requireExp[prop];
            requireExp[prop] = this.calculator.upExp(unit, newProps[prop]);
          } else {
            break;
          }
        }
      }
      if (!unit.requireExp) {
        unit.requireExp = {};
      }
      if (!unit.exp) {
        unit.exp = {};
      }
      Object.assign(unit.requireExp, requireExp);
      Object.assign(unit.exp, exp);
      await this.updateProps(unit, newProps);
      await this.moveTo(unit, unit.position, true);
    }

    async battle(sources, targets) {
      let interrupt = false;
      const info = new BattleInfo();
      info.sources = sources.map((s) => s.clone());
      info.targets = targets.map((t) => t.clone());
      info.details = [];
      this.batting = true;
      let attackers = [];
      const fastCooldown = -999;
      for (let source of sources) {
        attackers.push([
          source,
          { enemies: this.sortEnemies(source, targets) },
          (source.buffers.pSneak ? fastCooldown : 0) +
          this.calculator.cooldown(source) *
          this.session.args.P_POSITIVE_COOLDOWN,
        ]);
      }
      for (let target of targets) {
        attackers.push([
          target,
          { enemies: this.sortEnemies(target, sources) },
          (target.buffers.pSneak ? fastCooldown : 0) +
          this.calculator.cooldown(target),
        ]);
      }
      attackers.sort((i, j) => i[2] - j[2]);
      attackers.forEach((a) => (a[0].fighting = true));
      const showMsg = async (msg, timeout) => {
        info.details.push(msg);
        console.log(msg);
        await this.modal_.toast(msg, timeout);
      };
      await showMsg(`战斗开始, ${attackers[0][0].name}抢先`, 200);
      let maxInvalidLoopCount = attackers.length * 10;
      let invalidLoop = 0;
      const insertAttacker = (attacker) => {
        let idx = attackers.findIndex(([a, _0, _1]) => a === attacker);
        let pair = attackers[idx];
        attackers.splice(idx, 1);
        pair[2] = Math.max(pair[2], 0) + this.calculator.cooldown(attacker);
        idx = attackers.findIndex(([_0, _1, t]) => t > pair[2]);
        if (idx > 0) {
          attackers.splice(idx - 1, 0, pair);
        } else if (idx === 0) {
          attackers.unshift(pair);
        } else {
          attackers.push(pair);
        }
      };
      while (attackers.length) {
        const [source, s] = attackers[0];
        const attackTarget = async (target, attackProps, excludeSplash) => {
          const [
            attackProp,
            hint,
            attackDamage,
            splash,
            recovery,
            reflect,
            daze,
          ] = await this.calculator.attack(
            source,
            target,
            attackProps,
            excludeSplash
          );
          const showMsgW = excludeSplash
            ? async (msg, timeout) => {
              await showMsg(`${source.name}->\t\t【溅射` + msg, timeout);
            }
            : async (msg, timeout) => {
              await showMsg(`${source.name}->\t` + msg, timeout);
            };
          if (!hint) {
            await showMsgW(`${target.name}:  闪避`, 20);
          } else {
            let targetLife = target.life;
            let sourceLife = source.life;
            target.life = Math.max(-1, target.life - attackDamage);
            source.life = Math.max(
              0,
              Math.min(
                this.session.args.MAX_LIFE,
                source.life + recovery - reflect
              )
            );
            await showMsgW(
              `${target.name}: -${attackDamage}` +
              (recovery > 0 ? `, ${source.name}: +${recovery}` : "") +
              (reflect > 0 ? `, ${source.name}: -${reflect}` : ""),
              20
            );
            if (daze) {
              insertAttacker(target);
              await showMsgW(`${target.name}: 眩晕`, 20);
            }
            if (targetLife !== target.life || sourceLife !== source.life) {
              invalidLoop = 0;
            }
          }
          this.stopSkillsOf(source, (s) => s.attackQuit);
          this.stopSkillsOf(target, (s) => s.attackQuit);
          if (target.life <= 0) {
            if (source !== this.player) {
              await this.whenUnits(this.player, [source], "win");
            }
            if (target !== this.player) {
              await this.whenUnits(this.player, [target], "defeat");
            }
            if (target.life <= 0) {
              target.died = true;
              const exps = await this.calculator.getExps(source, target);
              await this.updateExps(source, exps);
              let expMsgs = [];
              for (const prop of this.PROPS) {
                if (exps[prop] > 0) {
                  expMsgs.push(`【${this.getPropName(prop)}】${exps[prop]}`);
                }
              }
              showMsgW(
                `${source.name}获取经验: ${expMsgs.join(",") || "无"}`
              );

              let money = await this.calculator.getMoney(source, target);
              if (money > 0) {
                source.money = source.money + money;
                let decMoney = Math.min(money, target.money);
                target.money = target.money - decMoney;
                showMsgW(
                  `${source.name}: + $${money}, ${target.name}: - $${decMoney}`
                );
              }
              if (source === this.player && target.positiveSkills?.length) {
                let getSkill = await this.calculator.getSkill(source, target);
                if (getSkill) {
                  let skillName =
                    target.positiveSkills[
                      Math.floor(Math.random() * target.positiveSkills.length)
                    ].name;
                  let skill = this.session.skillsObj[skillName];
                  skill = Object.assign({}, skill, { count: 1 });
                  if (!skill.positive) {
                    skill.position = {
                      last: skill.level,
                      cooldown: 0,
                    };
                  }
                  this.learnSkills(source, [skill], source === this.player);
                  showMsgW(`${source.name}: 习得${skill.name}x1`);
                }
              }
              attackers.forEach(
                ([_, s]) =>
                  (s.enemies = s.enemies.filter((t) => t !== target))
              );
              attackers = attackers.filter(([unit]) => unit !== target);
              target.fighting = false;
            }
          }
          return [attackProp, splash];
        };
        const [attackProp, splash] = await attackTarget(s.enemies[0]);
        if (splash && attackProp) {
          for (let target of s.enemies.slice(1)) {
            await attackTarget(target, [attackProp], true);
          }
        }
        insertAttacker(source);
        if (!s.enemies.length) {
          break;
        }
        invalidLoop++;
        if (invalidLoop >= maxInvalidLoopCount) {
          await showMsg(`战斗中止`, 200);
          interrupt = true;
          break;
        }
      }

      info.sources.forEach((u, i) => {
        u.life = u.life + " -> " + sources[i].life;
      });
      info.targets.forEach((u, i) => {
        u.life = u.life + " -> " + targets[i].life;
      });
      info.units = [...info.sources, ...info.targets];
      this.battleInfos.unshift(info);
      this.battleInfos = this.battleInfos.slice(0, MAX_BATTLE_INFOS);
      attackers.forEach((a) => (a[0].fighting = false));
      this.batting = false;
      return interrupt;
    }

    async updateUnitLife(unit) {
      if (unit.ghost) {
        return;
      }
      if (unit.died) {
        if (!this.session.args.DIED_RECOVERY) {
          return;
        }
      }
      const lifeIncrease =
        (unit.movable ? 1 : this.session.args.P_BUILDING_RECOVERY) *
        this.calculator.incLife(unit);
      unit.life = Math.floor(
        Math.min(this.session.args.MAX_LIFE, unit.life + lifeIncrease)
      );
      if (unit.died) {
        if (
          unit.life >
          Math.floor(
            this.session.args.P_WAKE_UP_LIFE * this.session.args.MAX_LIFE
          )
        ) {
          unit.died = undefined;
          unit.aliving = undefined;
        } else if (
          unit.life >
          Math.floor(
            this.session.args.P_ALIVING_LIVE * this.session.args.MAX_LIFE
          )
        ) {
          unit.aliving = true;
        }
      } else if (!unit.ghost) {
        const moneyIncrease = this.calculator.incMoney(unit);
        unit.money = unit.money + moneyIncrease;
      }
    }

    async checkPlayerDied() {
      if (this.player.died) {
        if (this.player.initPos.floor !== this.floorId) {
          await this.loadFloor(this.player.initPos.floor);
        }
        await this.moveTo(this.player, undefined, true);
        this.player.died = false;
        this.player.life = this.session.args.MAX_LIFE;
        this.autoRunning = false;
        this.player.positiveSkills.forEach((s) => {
          s.cooldown = 0;
          s.last = 0;
        });
        let forgetSkills = this.player.skills.filter((s) => s.count === 0);
        if (forgetSkills.length) {
          this.forgetSkills(this.player, forgetSkills);
        } else {
          this.updateBuffers(this.player);
        }
        return false;
      }
    }

    stopSkillsOf(unit, filter) {
      const stopSkills = unit.activedSkills.filter(filter);
      if (!stopSkills.length) {
        return;
      }
      stopSkills.forEach((s) => (s.last = 0));
      this.updateBuffers(unit);
    }

    async actionResultOnMsg(target, propSet, context, showMsg) {
      if (target === this.player) {
        let backup = this.currentAction;
        let action = {
          target: context.op1,
          question: propSet,
          answers: [],
        };
        let task = new Promise((resolve) => (action.resolve = resolve));
        this.currentAction = action;
        await task;
        this.currentAction = backup;
      }
    }

    async actionResultOnStore(target, propSet, context, showMsg) {
      Object.assign(context.store, propSet);
    }

    async actionResultOnSet(target, propSet, context, showMsg) {
      for (let p in propSet) {
        const v = propSet[p];
        if (v === undefined || v === null) {
          continue;
        }
        switch (p) {
          case "mc":
            target.money = v || 0;
            showMsg?.(`金币置为: ${v}`);
            break;
          case "sp":
            target.sprite = v || undefined;
            break;
          case "g":
            target.group = v || 0;
            showMsg?.(`分组置为: ${v}`);
            break;
          case "gt":
            target.ghost = v || false;
            showMsg?.(`幽灵置为: ${v}`);
            break;
          case "d":
            target.died = v || false;
            showMsg?.(`死亡置为: ${v}`);
            break;
          case "w":
            target.isWall = v || false;
            await this.moveTo(target, target.position);
            showMsg?.(`类型置为: ${v ? "墙" : "普通"}`);
            break;
          case "j":
          case "m":
          case "s":
          case "h":
          case "t":
            const prop = ["jin", "mu", "shui", "huo", "tu"].find(
              (s) => s[0] === p
            );
            target[prop] = v || 0;
            this.updateProps(target, target);
            showMsg?.(`${this.getPropName(prop)}属性置为: ${v}`);
            break;
          case "x":
          case "y":
          case "f":
            p = p === "f" ? "floor" : p;
            const { x, y, floor } = target.position;
            const cor = { x, y, floor };
            cor[p] = v || 0;
            const cell = this.session?.floors[cor.floor]?.cells?.[cor.y]?.[
              cor.x
            ];
            if (!cell) {
              showMsg?.(`移动失败: ${floor},${y},${x}`);
              break;
            }
            await this.moveTo(target, cell, true);
            break;
          default:
            break;
        }
      }
    }

    async actionResultOnInc(target, propInc, context, showMsg) {
      for (let p in propInc) {
        const v = propInc[p];
        if (v === 0 || v === undefined || v === null || v === "") {
          continue;
        }
        switch (p) {
          case "mc":
            target.money = target.money + (v || 0);
            showMsg?.(`${v > 0 ? "获得" : "失去"}金币: ${Math.abs(v)}`);
            break;
          case "j":
          case "m":
          case "s":
          case "h":
          case "t":
            const prop = ["jin", "mu", "shui", "huo", "tu"].find(
              (s) => s[0] === p
            );
            target[prop] = target[prop] + v;
            this.updateProps(target, target);
            showMsg?.(
              `${v > 0 ? "增加" : "减少"}${this.getPropName(
                prop
              )}属性: ${Math.abs(v)}`
            );
            break;
        }
      }
    }

    async actionResultOnGet(target, get, context, showMsg) {
      const skill = new Skill(get);
      if (skill.last && !skill.positive) {
        skill.positive = {
          last: skill.last,
          cooldown: skill.last,
        };
      }
      await this.learnSkills(target, [skill], target === this.player);
      showMsg?.(
        `获得: ${skill.name}` + (skill.count ? `x${skill.count}` : "")
      );
    }

    async actionResultOnLost(target, lost, context, showMsg) {
      const skill = target.skills.find((s) => s.name === lost.name);
      let forgetSkill = true;
      if (lost.count && skill.count > lost.count) {
        skill.count = skill.count - lost.count;
        forgetSkill = false;
      }
      await this.forgetSkills(target, forgetSkill ? [skill] : []);
      showMsg?.(`失去: ${lost.name}` + (lost.count ? `x${lost.count}` : ""));
    }

    async actOnUnit(source, target, action, context) {
      let { query, question, answers, results, cancable } = action;
      question = tryUpdateInContext(question, context);
      answers = tryUpdateInContext(answers, context);
      if (!results) {
        results = [];
      }
      if (!Array.isArray(results)) {
        results = [results];
      }
      action = {
        query,
        question,
        answers,
        results,
        source,
        target,
        cancable,
      };
      if (question) {
        context = Object.assign({}, context, { as: answers });
        let task = new Promise((resolve) => {
          action.resolve = resolve;
        });
        this.currentAction = action;
        let reply = await task;
        if (reply === undefined && cancable) {
          return;
        }
        let idx;
        if (reply !== undefined && action.answers?.length) {
          idx = action.answers.findIndex((a) => a == reply);
        }
        context = Object.assign({}, context, { ia: idx, a: reply });
      }
      if (!action.results.length) {
        return;
      }
      const handleResult = async (result) => {
        if (result.if !== undefined) {
          if (!tryUpdateInContext(result.if, context)) {
            return;
          }
        }
        for (let rname in result) {
          if (rname === "if") {
            continue;
          }
          let r = result[rname];
          if (!r) {
            continue;
          }
          rname = tryUpdateInContext(rname, context);
          if (!rname) {
            continue;
          }
          if (Array.isArray(r)) {
            for (let subR of r) {
              if (await handleResult(subR)) {
                return true;
              }
            }
            continue;
          }
          let targetId;
          let aim;
          [rname, targetId] = rname.split("_");
          let showMsg;
          if (!targetId || targetId === "0") {
            aim = source;
            showMsg = (msg, timeout) => this.modal_.toast(msg, timeout);
          } else if (targetId === "1") {
            aim = target;
          } else {
            aim = this.session.unitIds[targetId];
            if (!aim) {
              console.log(`No such unit: ${targetId}`);
              continue;
            }
            context = this.calculator.insertUnit(context, aim, 2, true);
          }
          if (rname === "interrupt" && tryUpdateInContext(r, context)) {
            return true;
          }
          const f = `actionResultOn${rname[0].toUpperCase() + rname.slice(1)
            }`;
          if (!this[f]) {
            console.log(`Unimplemented result handler ${rname}`);
            continue;
          }
          await this[f](
            aim,
            tryUpdateInContext(r, context),
            context,
            showMsg
          );
        }
      };
      for (let result of action.results) {
        if (await handleResult(result)) {
          return true;
        }
      }
    }

    reply(ans) {
      ans = Array.isArray(ans) ? ans[1] : ans;
      if (
        ans === undefined &&
        this.currentAction?.answers?.length &&
        !this.currentAction?.cancable
      ) {
        return;
      }
      const resolve = this.currentAction?.resolve;
      this.currentAction = undefined;
      if (!resolve) {
        return;
      }
      resolve(ans);
    }

    async whenUnits(source, units, event) {
      if (this.editing) {
        return;
      }
      let eventUnits = units.filter((u) => u.when?.[event]?.length);
      for (let u of eventUnits) {
        let context = this.calculator.createContext(source, u);
        u.when._stores = u.when._stores || {};
        context.store = u.when._stores;
        u.when._args = u.when._args || {};
        context.args = new Proxy(u.when._args, {
          get: function (obj, prop) {
            return obj[prop];
          },
        });
        for (let action of u.when[event]) {
          if (
            action.query === undefined ||
            action.query === null ||
            action.query === "" ||
            evalInContext(action.query, context)
          ) {
            if (await this.actOnUnit(source, u, action, context)) {
              return true;
            }
          }
        }
      }
    }

    async move(dx, dy) {
      if (this.player.position.floor != this.floorId) {
        return;
      }
      let pCross = this.player.buffers.pCross;
      const nextPositions = Array.from(
        { length: pCross * this.player.level + 1 },
        (_, i) => i + 1
      )
        .map(
          (i) =>
            this.floor.cells[this.player.position.y + dy * i]?.[
            this.player.position.x + dx * i
            ]
        )
        .filter((c) => c);
      const idx = nextPositions.findIndex((p) => !this.isWallCell(p));
      const nextPosition = nextPositions[idx];
      if (!nextPosition) {
        return;
      }

      this.steps = this.steps + 1;

      for (const unit of this.units) {
        await this.updateUnitLife(unit);
      }
      let transPosition = false;
      const filter = this.player.buffers.pPhase
        ? (unit) => !unit.movable
        : () => true;
      let enemies = this.units.filter(
        (u) =>
          (u.position === nextPosition ||
            (u.position === this.player.position && this.player !== u)) &&
          !u.died &&
          filter(u)
      );
      enemies = enemies.filter((u) => !u.ghost);
      if (
        await this.whenUnits(
          this.player,
          this.units.filter((u) => u.position === this.player.position),
          "tryLeave"
        )
      ) {
        this.autoRunning = false;
        return;
      }
      if (
        await this.whenUnits(
          this.player,
          this.units.filter((u) => u.position === nextPosition),
          "tryEnter"
        )
      ) {
        this.autoRunning = false;
        return;
      }
      let friends = enemies.filter(
        (u) =>
          u.group === this.player.group && u.position === this.player.position
      );
      enemies = enemies.filter((u) => isEnemy(u.group, this.player.group));
      const moveToNextPosition = async () => {
        await this.moveTo(this.player, nextPosition);
        if (this.player.position.isEnd) {
          await this.modal_.toast("通关");
          this.success = true;
          if (!this.editing) {
            let lastPlayer = {};
            if (this.session?.crossProps?.length) {
              for (let p of this.session.crossProps) {
                lastPlayer[p] = this.player[p];
              }
              this.lastPlayer = lastPlayer;
            }
            try {
              await this.localStorage.setItem(
                LAST_PLAYER_KEY,
                JSON.stringify(this.lastPlayer)
              );
            } catch { }
          }
          return true;
        }
        if (this.player.position.isInEntry) {
          await sleep(500);
          this.player.initPos = nextPosition.target;
          transPosition = true;
          if (nextPosition.target.floor !== this.floorId) {
            await this.loadFloor(nextPosition.target.floor);
            await this.resize();
          }
          await this.moveTo(this.player, nextPosition.target);
        }
      };
      let interrupt = undefined;
      if (enemies.length) {
        this.selectedUnits = [this.player, ...friends, ...enemies];
        interrupt = await this.battle([this.player, ...friends], enemies);
        this.selectedUnits = [this.player];
        if (this.player.died) {
          await this.modal_.toast("失败", 1000);
        } else {
          interrupt = (await this.unitsMove(true)) || interrupt;
          if (interrupt) {
            this.autoRunning = false;
          } else {
            if (pCross) {
              await moveToNextPosition();
              if (await this.unitsMove(false, true)) {
                this.autoRunning = false;
              }
            } else if (this.autoRunning) {
              await this.move(dx, dy);
            }
          }
        }
      } else {
        if (await moveToNextPosition()) {
          return;
        }
        if (!transPosition) {
          await this.unitsMove(false);
        }
      }
      await this.updateUnitsSkillPositive();
      await this.checkPlayerDied();
    }

    async updateUnitsSkillPositive() {
      for (let unit of this.units) {
        for (let skill of unit.positiveSkills || []) {
          await this.updateSkillPositive(unit, skill);
        }
      }
    }

    async moveBackOtherFloorUnits() {
      const units = this.units.filter(
        (u) =>
          u !== this.player &&
          u.position !== u.initPos &&
          u.position.floor !== this.floorId &&
          !u.died &&
          !u.ghost
      );
      const graphs = [];
      for (const unit of units) {
        const graph =
          graphs[unit.position.floor] ||
          new astarG(
            this.session.floors[unit.position.floor].cells.map((column, y) =>
              column.map((c, x) => {
                return !this.isWallCell(c) && !c.isInEntry ? 1 : 0;
              })
            )
          );
        const targetPos = unit.initPos;
        graphs[unit.position.floor] = graph;
        const start = graph.grid[unit.position.y][unit.position.x];
        const end = graph.grid[targetPos.y][targetPos.x];
        const nextPos = astar.search(graph, start, end)[0];
        if (!nextPos) {
          continue;
        }
        const { x: y, y: x } = nextPos;
        const nextPosition = this.session.floors[unit.position.floor].cells[
          y
        ][x];
        await this.moveTo(unit, nextPosition);
        if (unit.position === unit.initPos) {
          unit.tracking = undefined;
        }
      }
    }

    sortEnemies(unit, enemies) {
      enemies = enemies.map((e) => [e, this.calculateAttackOrder(unit, e)]);
      enemies.sort((i, j) => i[1] - j[1]);
      enemies = enemies.map((i) => i[0]);
      // console.log("攻击顺序\n" + enemies.map(e => `${JSON.stringify({ x: e.position.x, y: e.position.y, level: e.level })}`).join('\n'))
      return enemies;
    }

    calculateAttackOrder(source, target) {
      let dist = Math.hypot(
        source.position.x - target.position.x,
        source.position.y - target.position.y
      );
      return (
        this.session.args.P_ATTACK_ORDER_LEVEL * target.level +
        this.session.args.P_ATTACK_ORDER_LEVEL * dist +
        this.session.args.P_ATTACK_ORDER_RANDOM * Math.random()
      );
    }

    async unitsMove(buildingAttack, positionAttackOnly) {
      if (!positionAttackOnly) {
        await this.moveBackOtherFloorUnits();
      }
      const units = this.units.filter(
        (u) =>
          !this.isWallCell(u.position) &&
          u !== this.player &&
          u.position.floor === this.floorId &&
          !u.died &&
          !u.ghost
      );
      const graph = new astarG(
        this.floor.cells.map((column, y) =>
          column.map((c, x) => {
            return !this.isWallCell(c) ? 1 : 0;
            // return (c.type === "Floor" && (!c.isInEntry)) ? 1 : 0
          })
        )
      );
      let enemies = [];
      let friends = [];
      for (let unit of units) {
        if (unit.group === this.player.group) {
          if (unit.position === this.player.position) {
            friends.push(unit);
          }
          continue;
        }
        if (!isEnemy(this.player.group, unit.group)) {
          continue;
        }
        const dx = this.player.position.x - unit.position.x;
        const dy = this.player.position.y - unit.position.y;
        const dist = this.player.buffers.pSneak
          ? Number.MAX_SAFE_INTEGER
          : Math.abs(dx) + Math.abs(dy);
        const attackSize = unit.movable
          ? positionAttackOnly
            ? 0
            : 1
          : this.session.args.DISTANCE_ASSISTANCE;
        if (dist <= attackSize) {
          // if (enemy.level < this.player.level) {
          //   continue
          // }
          enemies.push(unit);
          continue;
        }
        if (!unit.movable || positionAttackOnly) {
          continue;
        }
        let targetPos = undefined;
        const offDist =
          Math.abs(unit.position.x - unit.initPos.x) +
          Math.abs(unit.position.y - unit.initPos.y);
        if (unit.tracking === undefined) {
          if (dist <= this.session.args.DISTANCE_TRACKING) {
            unit.tracking = true;
            targetPos = this.player.position;
          }
        } else if (unit.tracking === true) {
          targetPos = this.player.position;
          if (
            offDist >= this.session.args.DISTANCE_CANCLE_TRACKING ||
            dist >= this.session.args.DISTANCE_CANCLE_TRACKING * 4
          ) {
            unit.tracking = false;
            targetPos = unit.initPos;
          }
        }

        if (!targetPos && unit.initPos !== unit.position) {
          targetPos = unit.initPos;
        }

        if (targetPos) {
          const start = graph.grid[unit.position.y][unit.position.x];
          const end = graph.grid[targetPos.y][targetPos.x];
          const nextPos = astar.search(graph, start, end)[0];
          if (!nextPos) {
            continue;
          }
          const { x: y, y: x } = nextPos;
          const nextPosition = this.floor.cells[y][x];
          await this.moveTo(unit, nextPosition);
          if (unit.position === unit.initPos) {
            unit.tracking = undefined;
          }
        }
      }

      if (
        enemies.length &&
        (buildingAttack || enemies.some((e) => e.movable)) &&
        !this.player.died
      ) {
        this.selectedUnits = [this.player, ...friends, ...enemies];
        let result = await this.battle(enemies, [this.player, ...friends]);
        this.selectedUnits = [this.player];
        if (this.player.died) {
          await this.modal_.toast("失败", 1000);
        }
        return result;
      }
    }

    async tryMove(dx, dy, autoRunning = false) {
      if (this.currentAction) {
        this.reply();
        return;
      }
      if (!this.player) {
        return;
      }
      if (this.autoRunning && !autoRunning) {
        this.autoRunning = false;
        return;
      }
      if (this.batting) {
        return;
      }
      if (this.success) {
        await this.loadSession(this.currentSessionId + 1);
        return;
      }
      if (this.moving) {
        return;
      }
      this.moving = true;
      try {
        await this.move(dx, dy);
      } catch (e) {
        console.log(e);
      }
      this.moving = false;
    }
  }
</script>
<template id="app-main" view-model="App">
  <div>
    <div id="app" class.="'app '+(editing?'editing ':'')+(floor?.theme?.dark ? 'dark' :'light')"
      style---cell-width$.="cellWidth+'px'" style---propstrength$.="session?.propStrength || 0">
      <div class="floor-bg" onclick.="exitAllEditingMode(true)">
        <div if.="floor?.theme?.bgImg">
          <img src$.="floor?.theme?.bgImg || ''" />
        </div>
      </div>
      <div if.="floor" class="floor-wraper floor-floor-wraper" class-with-bg.="floor?.theme?.bgImg">
        <div class="floor floor-floor">
          <div for.="row of displayFloor" class="row">
            <div for.="cell of row" class="cell" onclick.="touchCell(cell)"
              class-UnknownWall.="(!editing&&session.args.DISTANCE_SHADOW&&!cell.visited)">
              <div class.="(!cell.isWall&&cell.type!=='Wall')?cell.type:''"></div>
              <div if.="(!cell.isWall&&cell.type!=='Wall') && cell.prop" class.="'prop ' + cell.prop"></div>
              <div if.="(!cell.isWall&&cell.type!=='Wall') && (cell.isInEntry || cell.isOutEntry)" class="entry">
                <div class="avatar">
                  <span if.="cell.isInEntry" inner-text$.="cell.target?.floor + 1"></span>
                </div>
              </div>
              <div if.="(!cell.isWall&&cell.type!=='Wall') && cell.isEnd" class="end sprite">
                <span>🎯</span>
              </div>
              <div if.="editing && (!cell.isWall&&cell.type!=='Wall') && cell.isStart" class="start sprite">
                <span>📍</span>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div if.="floor" class="floor-wraper">
        <div class="floor wall-floor">
          <div for.="row of displayFloor" class="row">
            <div for.="cell of row" class="cell" class-EmptyWall.="((!cell.isWall&&cell.type!=='Wall')||cell.empty)">
              <div class.="'Wall '+ (cell.isCorner?'corner-cell ':'')"></div>
            </div>
          </div>
        </div>
      </div>
      <div if.="floor" class="floor-wraper">
        <div class="floor floor-floor">
          <div for.="row of displayFloor" class="row">
            <div for.="cell of row" class="cell" onclick.="touchCell(cell)">
              <div if.="cell === selectedCell" class="selected-cell">
                <span inner-text$.="cell.x + ',' + cell.y"></span>
              </div>
              <div if.="selectedCell&&cell!==selectedCell&&cell.floor===selectedCell.floor&&(cell.x===selectedCell.x)"
                class="half-selected-cell column"></div>
              <div if.="selectedCell&&cell!==selectedCell&&cell.floor===selectedCell.floor&&(cell.y===selectedCell.y)"
                class="half-selected-cell row"></div>
            </div>
          </div>
          <div if.="units?.length">
            <div for.="unit of units">
              <div onclick.="touchUnit(unit)" if.="unit.position.floor === floorId && !unit.isWall"
                class.=" unit.filters +(!editing&&session.args.DISTANCE_SHADOW&&!unit.nearby&&!unit.ghost&&!unit.died?'shadow-unit ':'') + (' group-'+unit.group + ' ') + (unit.ghost ? 'ghost ':'') + ' unit ' + (unit.fighting ? 'fighting ': '') + (unit.movable ? '': 'unmovable ') + (unit.skills?.length ? 'skilled ':'') + (unit===player ?'player':'') + (unit.moving ? ' moving' : '') + (unit.died ? ' died':'') + (unit.aliving ? ' aliving':'')"
                style---offset-x$.="cellWidth * (unit.position.x - dx)"
                style---offset-y$.="cellWidth * (unit.position.y - dy)" style---p-jin$.="unit.pJin"
                style---p-mu$.="unit.pMu" style---p-shui$.="unit.pShui" style---p-huo$.="unit.pHuo"
                style---p-tu$.="unit.pTu">
                <div class.="'pointer '+(selectedCell ? '':'active')">
                  <div></div>
                  <div></div>
                  <div></div>
                  <div></div>
                </div>
                <div if.="!unit.sprite" class="avatar"></div>
                <div if.="!unit.sprite" class="name">
                  <span inner-text$.="unit.level"></span>
                </div>
                <div if.="unit.sprite" class="sprite">
                  <span inner-text$.="unit.sprite"></span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div if.="session.args.DISTANCE_SHADOW&&!editing&&floor" class="floor-wraper shadow-floor-wraper">
        <div class="floor shadow-floor">
          <div for.="row of displayFloor" class="row">
            <div for.="cell of row" class="cell">
              <div class-visited-cell.="cell.visited&&!cell.nearby" class-nearby-cell.="cell.nearby"></div>
            </div>
          </div>
        </div>
      </div>
      <div if.="editing && templateCells?.length"
        class.="'cell-editing-panel-wraper first '+(editingCell?'editing':'')">
        <div class="cell-editing-panel">
          <div for.="cell of templateCells" onclick.="startEditingCell(cell.id)"
            class.="'cell-wraper '+(editingCell&&cell.id===currentModifierIdx?'selected-modifier ':'')">
            <div class.="'cell '+(cell.empty?'cell emptywall ':' ')">
              <div class.="(!cell.isWall&&cell.type!=='Wall')?cell.type:''"></div>
              <div if.="(!cell.isWall&&cell.type!=='Wall') && cell.prop" class.="'prop ' + cell.prop"></div>
              <div if.="cell.isWall||cell.type==='Wall'" class.="'Wall '+ (cell.isCorner?'corner-cell ':'')"></div>
            </div>
          </div>
        </div>
      </div>
      <div if.="editing && templateCells?.length" class="cell-editing-panel-wraper second editing">
        <div class="cell-editing-panel">
          <div for.="cell of cellButtons" onclick.="cell.invoke()" class="cell-wraper">
            <div class="cell">
              <span class="cell-button" inner-text$.="cell.name"></span>
              <div class.="cell.classes"></div>
            </div>
          </div>
        </div>
      </div>
      <div if.="!editing" class-hidden.="currentAction">
        <div class.="'menus bottom ' + (positiveSkills.length ? 'left': '')">
          <div>
            <div></div>
            <div class="Up icon-wraper" onclick.="tryMove(0, -1)">
              <div class="icon"></div>
            </div>
            <div></div>
          </div>
          <div>
            <div class="Left icon-wraper" onclick.="tryMove(-1, 0)">
              <div class="icon"></div>
            </div>
            <div></div>
            <div class="Right icon-wraper" onclick.="tryMove(1, 0)">
              <div class="icon"></div>
            </div>
          </div>
          <div>
            <div></div>
            <div class="Down icon-wraper" onclick.="tryMove(0, 1)">
              <div class="icon"></div>
            </div>
            <div></div>
          </div>
        </div>
        <div if.="positiveSkills?.length" class.="'menus right '">
          <div class="skills-control">
            <div for.="skill of positiveSkills" onclick.="useSkill(player, skill)"
              style---all-cooldown$.="skill.positive.cooldown || 0" style---cooldown$.="skill.cooldown || 0"
              class.="(skill.last > 0 ? 'active ': '') + (skill.cooldown > 0 ? 'uncooldown ': '')">
              <div class="status-indicator">
                <div style---total$.="skill.positive.last || 0" style---current$.="skill.last || 0"
                  class="skill-last top-indicator">
                  <div></div>
                  <div></div>
                </div>
                <div class="skill-cooldown">
                  <div></div>
                  <div></div>
                </div>
                <div style---total$.="skill.positive.last || 0" style---current$.="skill.last || 0"
                  class="skill-last top-indicator">
                  <div></div>
                  <div></div>
                </div>
              </div>
              <span class="skill-name" inner-text$.="skill.name"></span>
              <span if.="skill.count !== undefined">
                x<span inner-text$.="skill.count"></span>
              </span>
              <span if.="skill.cast" class="jin">
                <span inner-text$.="skill.cast * session.args.RATE_USE_SKILL"></span>
              </span>
            </div>
          </div>
        </div>
      </div>
      <div if.="editing" class="menus menus-editing">
        <div class.="'entry-items '+(isEditingEntry?'editing ':'')">
          <div class="entry-item">
            <span class="edit-entry-menu-item" onclick.="sortEntry()">起点</span>
            <span></span>
            <span class="edit-entry-menu-item" onclick.="sortEntry(true)">终点</span>
            <span></span>
          </div>
          <div class="entry-item hidden-in-landscape">
            <span class="edit-entry-menu-item" onclick.="sortEntry()">起点</span>
            <span></span>
            <span class="edit-entry-menu-item" onclick.="sortEntry(true)">终点</span>
            <span></span>
          </div>
        </div>
        <div class.="'entry-items entry-items-content '+(isEditingEntry?'editing ':'')">
          <div scrollIntoView.="e===currentEntry" class.="'entry-item '+(e===currentEntry?'current':'')"
            for.="e of editingEntries">
            <span
              class.="'entry-item '+(isEditingEntry?'editing ':'')+(e===currentEntry&&currentEntryFirst?'current':'')"
              inner-text$.="e.start?((e.start.floor+1)+','+e.start.x+','+e.start.y):'无'"
              onclick.="setCurrentEntry(e, true)"></span>
            <span inner-text$.="e.direction===1?'→':(e.direction===-1?'←':'⇋')" onclick.="toggleEntry(e)"></span>
            <span
              class.="'entry-item '+(isEditingEntry?'editing ':'')+(e===currentEntry&&!currentEntryFirst?'current':'')"
              inner-text$.="e.end?((e.end.floor+1)+','+e.end.x+','+e.end.y):'无'" onclick.="setCurrentEntry(e)"></span>
            <span if.="e===currentEntry" class="button danger" onclick.="deleteEntry(e)">删除</span>
            <span if.="e!==currentEntry"></span>
          </div>
        </div>
        <div class="floor-items">
          <div class.="'floor-item '+(f===floor?'current':'')" for.="f of editingFloors" onclick.="loadFloor(f.id)">
            <span inner-text$.="f.id + 1"></span>
          </div>
        </div>
      </div>
      <div if.="!editing" class="menus top">
        <div if.="selectedUnits?.length && (units?.length > 1 || (sessionInfo===lastEditingSessionInfo && !editing))"
          class="props-wraper" onclick.="showHelp=true">
          <div class="props" for.="unit of selectedUnits">
            <div class="name">
              <img class="name-icon" if.="unit.icon" src.="unit.icon" />
              <span inner-text$.="unit.name"></span>
              <span if.="unit.group" inner-text$.="'['+unit.group+']'"></span>
              <span class="money" if.="unit.money"><span inner-text$.="unit.money"></span></span>
              <span class="skills" if.="unit.activedSkills?.length">
                <span for.="skill of unit.activedSkills" class="skill">
                  <span inner-text$.="skill.name"> </span>
                  <span if.="skill.count !== undefined">
                    x<span inner-text$.="skill.count"></span>
                  </span>
                </span>
              </span>
            </div>
            <div class="life-wraper">
              <div class="status-indicator">
                <div style---total$.="session?.args.MAX_LIFE || 1" style---current$.="unit.life || 0"
                  class="top-indicator">
                  <div></div>
                  <div></div>
                </div>
              </div>
              命:<span inner-text$.="unit.life"></span>
            </div>
            <!-- <div class="jin">金:<span inner-text$.="unit.jin"></span></div>
          <div class="mu">木:<span inner-text$.="unit.mu"></span></div>
          <div class="shui">水:<span inner-text$.="unit.shui"></span></div>
          <div class="huo">火:<span inner-text$.="unit.huo"></span></div>
          <div class="tu">土:<span inner-text$.="unit.tu"></span></div> -->
            <div for.="p of PROPS" class.="p+'-wraper'">
              <div class="status-indicator">
                <div style---total$.="unit.requireExp?.[p] || 1" style---current$.="unit.exp?.[p] || 0"
                  class="top-indicator">
                  <div></div>
                  <div></div>
                </div>
              </div>
              <span inner-text$.="getPropName(p)"></span>:
              <span inner-text$.="unit[p]"></span>
              <span class="prop-increase"
                inner-text$.="(unit.current[p] - unit[p]) ? ('+' + (unit.current[p] - unit[p])):''"></span>
            </div>
          </div>
        </div>
        <div class="menu-buttons">
          <div onclick.="save()" class="Save icon-wraper">
            <div class="icon"></div>
          </div>
          <div onclick.="selectingMem=true" class.="'Load icon-wraper ' + (mems?.length?'':'disabled')">
            <div class="icon"></div>
          </div>
          <div class="info portrait-info" onclick.="setConsole(true)">
            <div>
              <span if.="!session?.name">第<span inner-text$.="currentSessionId + 1"></span>关</span>
              <span if.="session?.name">
                <span inner-text$.="session.name"></span>
                [<span inner-text$.="(currentSessionId + 1) || '' "></span>]
              </span>
            </div>
            <div>
              <span if.="!floor?.name && session?.floors?.length > 1">第<span
                  inner-text$.="(floorId + 1) || '' "></span>层</span>
              <span if.="floor?.name"><span inner-text$.="floor.name"></span>
                <span if.="session?.floors?.length > 1">[<span inner-text$.="(floorId + 1) || '' "></span>]</span>
              </span>
            </div>
          </div>
          <div onclick.="restart()" class="Restart icon-wraper">
            <div class="icon"></div>
          </div>
          <div onclick.="close()" class="Close icon-wraper">
            <div class="icon"></div>
          </div>
        </div>
        <div>
          <div class="info landscape-info" onclick.="setConsole(true)">
            <div>
              <span if.="!session?.name">第<span inner-text$.="currentSessionId + 1"></span>关</span>
              <span if.="session?.name">
                <span inner-text$.="session.name"></span>
                [<span inner-text$.="(currentSessionId + 1) || '' "></span>]
              </span>
            </div>
            <div>
              <span if.="!floor?.name && session?.floors?.length > 1">第<span
                  inner-text$.="(floorId + 1) || '' "></span>层</span>
              <span if.="floor?.name"><span inner-text$.="floor.name"></span>
                <span if.="session?.floors?.length > 1">[<span inner-text$.="(floorId + 1) || '' "></span>]</span>
              </span>
            </div>
          </div>
        </div>
      </div>
      <div if.="editing" class="menus top editing--top-menus">
        <div class="menu-buttons">
          <div onclick.="deleteFloor()" class="Delete icon-wraper">
            <div class="icon"></div>
          </div>
          <div onclick.="insertFloor()" class="InsertBefore icon-wraper">
            <div class="icon"></div>
          </div>
          <div class="info portrait-info">
            <div onclick.="changeSessionName()">
              <span inner-text$.="sessionName || ('第'+(floorId + 1)+'关')" />
            </div>
            <div onclick.="changeFloorName()">
              <span inner-text$.="floorName || ('第'+(floorId + 1)+'层')" />
            </div>
          </div>
          <div onclick.="insertFloor(true)" class="InsertAfter icon-wraper">
            <div class="icon"></div>
          </div>
          <div onclick.="generateEditingResult()" class="Close icon-wraper">
            <div class="icon"></div>
          </div>
        </div>
        <div class.="'props editing-units '+(isEditingUnit?'editing ':'')">
          <table>
            <tr>
              <th></th>
              <!-- <th for.="p of PROPS"><span inner-text$.="getPropName(p)"></span></th> -->
              <th>属性</th>
              <th>移动</th>
              <th></th>
            </tr>
            <tr for.="unit of units" class.="unit === currentUnit?'current ':''" scrollIntoView.="unit === currentUnit"
              onclick.="locateUnit(unit)">
              <td onclick.="changeUnitName(unit)">
                <div class="name">
                  <span if.="unit.group" inner-text$.="'['+unit.group+']'"></span>
                  <span inner-text$.="unit.name || unit.id || unit.sprite || ''"></span>
                </div>
              </td>
              <!-- <td for.="p of PROPS"><span inner-text$.="unit[p]" onclick.="changeUnitProp(unit)"></span></td> -->
              <td>
                <span inner-text$.="unit.jin+','+unit.mu+','+unit.shui+','+unit.huo+','+unit.tu"
                  onclick.="changeUnitProp(unit)"></span>
              </td>
              <td>
                <span inner-text$.="unit.movable?'是':'否'" onclick.="toggleUnitMovable(unit)"></span>
              </td>
              <td>
                <span if.="unit === currentUnit && unit !== player" class="button danger"
                  onclick.="deleteUnit(unit)">删除</span>
              </td>
            </tr>
          </table>
        </div>
      </div>
      <div if.="showHelp" class="help" onclick.="showHelp=false">
        <div class="help-content" onclick="event.stopPropagation()">
          <div>
            <div class="help-detail">
              <div>
                <span for.="p of PROPS_SHENG" class.="p" inner-text$.="getPropName(p)"></span>
                <div class="button" onclick.="createSession(true)">编辑</div>
                <div if.="lastEditingSessionInfo" class="button" onclick.="createSession()">
                  继编
                </div>
              </div>
              <div>
                <span for.="p of PROPS_KE" class.="p" inner-text$.="getPropName(p)"></span>
                <div class="button" onclick.="clearAllData()">清空数据</div>
              </div>
            </div>
            <div class="unleart" if.="unLeartSkills?.length">
              <div class="title">商店</div>
              <div class="skill" for.="skill of unLeartSkills">
                <span class="name" inner-text$.="skill.name"></span>
                <span if.="skill.count !== undefined">
                  x<span inner-text$.="skill.count"></span>
                </span>
                <span class="price jin"><span inner-text$.="(skill.level || 0) * session.args.RATE_BUY"></span></span>
                <span onclick.="buyAndLearnSkill(skill)" class="buy">购买</span>
              </div>
            </div>
            <div class="soldable" if.="soldableSkills?.length">
              <div class="title">背包</div>
              <div class="skill" for.="skill of soldableSkills">
                <span class="name" inner-text$.="skill.name"></span>
                <span class="price jin"><span
                    inner-text$.="(skill.level || 0) * session.args.RATE_SELL || ''"></span></span>
                <span onclick.="sellSkill(skill)" class="sell"
                  inner-text$.="(skill.level || 0) * session.args.RATE_SELL?'出售':'丢弃'"></span>
              </div>
            </div>
            <div class="battle-infos">
              <div for.="info of battleInfos" class="battle-info">
                <table class="props">
                  <tr>
                    <th></th>
                    <th for.="p of PROPS">
                      <span inner-text$.="getPropName(p)"></span>
                    </th>
                  </tr>
                  <tr for.="unit of info.units">
                    <td>
                      <div class="name">
                        <img class="name-icon" if.="unit.icon" src.="unit.icon" />
                        <span inner-text$.="unit.name"></span>
                        <span if.="unit.group" inner-text$.="'['+unit.group+']'"></span>
                        :<span inner-text$.="unit.life"></span>
                      </div>
                    </td>
                    <td for.="p of PROPS">
                      <span inner-text$.="unit[p]"></span><span class.="p" if.="unit.current[p] - unit[p]"
                        inner-text$.="'+' + (unit.current[p] - unit[p])"></span>
                    </td>
                  </tr>
                </table>
                <table class="props-skills">
                  <tr>
                    <th></th>
                    <th>技能</th>
                  </tr>
                  <tr for.="unit of info.units" if.="unit.realActivedSkills?.length">
                    <td>
                      <div class="name">
                        <img class="name-icon" if.="unit.icon" src.="unit.icon" />
                        <span if.="unit.group" inner-text$.="unit.group+'-'"></span>
                        <span inner-text$.="unit.name"> </span>
                      </div>
                    </td>
                    <td>
                      <span inner-text$.="unit.realActivedSkills.map(s => s.name).join('、')">
                      </span>
                    </td>
                  </tr>
                </table>
                <div class="battle-details">
                  <div for.="detail of info.details" class="battle-detail">
                    <div inner-text$.="detail"></div>
                  </div>
                </div>
              </div>
            </div>
            <div>
              <table class="args">
                <tr>
                  <th>参数</th>
                  <th>默认</th>
                  <th>值</th>
                </tr>
                <tr for.="arg of args">
                  <td><span inner-text$.="arg"></span></td>
                  <td>
                    <span inner-text$.="JSON.stringify(session.initArgs[arg])"></span>
                  </td>
                  <td>
                    <input onchange.="changeArg(arg, event)" type="text"
                      value$.="customArgs?.[arg] === undefined ? '': JSON.stringify(customArgs[arg])" />
                  </td>
                </tr>
              </table>
            </div>
          </div>
        </div>
      </div>
      <div if.="currentAction" class="action-wraper" onclick.="reply()">
        <div class="action-content" onclick="event.stopPropagation()">
          <div class="target-unit">
            <div if.="currentAction.target.icon" class="target-unit-icon">
              <img src.="currentAction.target.icon" />
            </div>
            <div class="target-unit-name">
              <span inner-text$.="currentAction.target.name"></span>
              <span
                inner-text$.="'('+currentAction.target.position.x+',' + currentAction.target.position.y + ')'"></span>
            </div>
          </div>
          <div class="action-body">
            <div class="question">
              <span inner-text$.="currentAction.question"></span>
            </div>
            <div class="answers" if.="currentAction.answers?.length">
              <div class.="'answer ' + (answer===currentAction?.currentAnswer?'current-answer':'')"
                for.="answer of currentAction.answers" onclick.="reply(answer)">
                <span inner-text$.="Array.isArray(answer)?answer[0]:answer"></span>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div if.="selectingMem" class="mems-wraper" onclick.="selectingMem=false">
        <div class="mems" onclick="event.stopPropagation()">
          <div class="title">快照</div>
          <div class="mem" for.="mem of mems" onclick.="load(mem)">
            <span inner-text$.="mem.name"></span>
          </div>
        </div>
      </div>
      <div if.="editingResult" class="editing-result-wraper" onclick.="editingResult=undefined">
        <div class="editing-result" onclick="event.stopPropagation()">
          <div class="editing-result-menus">
            <div class="title">编辑结果</div>
            <div class="spacer"></div>
            <div class="button" onclick.="exportDotStory()">塔防地形</div>
            <div class="button danger" onclick.="reloadEditing()">重加载</div>
            <div class="button" onclick.="saveSessionInfo()">保存</div>
            <div class="button danger" onclick.="deleteSessionInfo()">删除</div>
            <div class="button" onclick.="exitEditing()">运行</div>
          </div>
          <div class="editing-result-info" inner-text$.="editingResultInfo"></div>
          <textarea class="editing-result-content" value$.="editingResult"
            onchange.="editingResult=event.target.value"></textarea>
        </div>
      </div>
      <div if.="editingUnit" class="editing-unit-wrpaer modal-content-wraper"
        onclick.="startEditingUnitDetail(undefined)">
        <div class="editing-unit modal-content" onclick="event.stopPropagation()">
          <div class="title">单位详情</div>
          <div class="simple-props">
            <div>
              <label>名称:</label>
              <input type="text" value$.="editingUnit?.name || ''" onchange.="editingUnit.name=event.target.value" />
            </div>
            <div>
              <label>标识:</label>
              <input type="text" value$.="editingUnit?.id || ''" onchange.="editingUnit.id=event.target.value" />
            </div>
            <div>
              <label>文图:</label>
              <input type="text" value$.="editingUnit?.sprite || ''"
                onchange.="editingUnit.sprite=event.target.value" />
            </div>
            <div>
              <label>移动:</label>
              <input type="checkbox" checked$.="editingUnit?.movable === true"
                onchange.="editingUnit.movable=event.target.checked === true" />
            </div>
            <div>
              <label>死亡:</label>
              <input type="checkbox" checked$.="editingUnit?.died === true"
                onchange.="editingUnit.died=event.target.checked === true" />
            </div>
            <div>
              <label>幽灵:</label>
              <input type="checkbox" checked$.="editingUnit?.ghost === true"
                onchange.="editingUnit.ghost=event.target.checked === true" />
            </div>
            <div>
              <label>墙:</label>
              <input type="checkbox" checked$.="editingUnit?.isWall === true"
                onchange.="editingUnit.isWall=event.target.checked === true" />
            </div>
            <div>
              <label>金币:</label>
              <input type="number" min="0" step="1" value$.="editingUnit?.money || 0"
                onchange.="editingUnit.money=event.target.value*1" />
            </div>
            <div>
              <label>组:</label>
              <input type="range" max="2" min="0" step="1" value$.="editingUnit?.group || 0"
                onchange.="editingUnit.group=event.target.value*1" />
            </div>
            <div for.="p of PROPS">
              <label>
                <span inner-text$.="getPropName(p)+':'"></span>
              </label>
              <input type="range" max.="session.args.MAX_LEVEL" min="0" step="1" value$.="editingUnit?.[p] || 0"
                onchange.="setEditingUnitProp(p,event.target.value)" />
            </div>
          </div>
          <div if.="editingUnit!==player">
            <label>触发器:
              <span if.="JSONEditor">
                <!-- <span class="button" onclick.="editUnitWhen()">编辑</span> -->
                <span class="button" onclick.="saveUnitWhen()">更新</span>
              </span></label>
            <textarea if.="!JSONEditor" value$.="JSON.stringify(editingUnit?.when || {}, null, 2)"
              onchange.="try{editingUnit.when=JSON.parse(event.target.value)}catch{modal_.toast('无效数据！')}"></textarea>
            <div if.="JSONEditor">
              <div id="whenEditor"></div>
            </div>
          </div>
        </div>
      </div>
      <div if.="showConsole" class="console-panel-wraper modal-content-wraper" onclick.="setConsole(false)">
        <div class="console-panel modal-content" onclick="event.stopPropagation()">
          <div class="console-outs">
            <div for.="out of consoleOuts" class="console-out"
              scrollIntoView.="out===consoleOuts[consoleOuts.length-1]">
              <span inner-text$.="out.content"></span>
            </div>
          </div>
          <div class="console-in">
            <input autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" focus.="showConsole"
              type="text" value$.="consoleIn||''" onchange.="consoleIn=event.target.value" />
          </div>
        </div>
      </div>
      <div if.="saving" class="saving-wraper">
        <div class="saving">
          <span>保存中....</span>
        </div>
      </div>
    </div>
    <modal-panel id="modal"></modal-panel>
  </div>
  <style>
    :host {
      display: block;
    }

    .toast-panel,
    .modal-panel,
    .popup-panel {
      position: fixed;
      display: flex;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      z-index: 999;
      padding: 10px;
      box-sizing: border-box;
    }

    .toast-panel {
      flex-direction: column-reverse;
      pointer-events: none;
    }

    .popup-panel {
      padding: 0;
      background: #00000080;
    }

    .popup-panel>* {
      flex: 1;
    }

    .modal-panel {
      background-color: #00000080;
    }

    .toast-panel>div {
      background-color: #00000080;
      margin: 20px auto;
      padding: 2px 5px;
      border-radius: 0.25em;
    }

    .toast-panel>div>span {
      font-size: 1.25em;
      color: white;
    }

    .modal-panel>div {
      background-color: var(--bg);
      color: var(--fg);
      border-radius: 10px;
      width: 80%;
      box-sizing: border-box;
      margin: auto;
      padding: 10px 20px;
      border: #c0c0c0 solid 1px;
      display: flex;
      flex-direction: column;
    }

    .modal-panel>div>h1 {
      font-size: 1em;
      margin-block-start: 0.33em;
    }

    .modal-panel>div>input[type="input"] {
      background: #fff;
      /* flex: 1; */
      height: 3em;
      font-size: 1em;
      /* padding: 5px; */
      margin: 5px 10px;
      border: #c0c0c0 solid 1px;
      border-radius: 8px;
      outline: 0 !important;
      color: -internal-light-dark-color(black, white);
      background-color: -internal-light-dark-color(white, black);
    }

    .modal-panel>div>input[type="range" i] {
      outline: none !important;
    }

    .modal-panel .btn-groups {
      display: flex;
      margin: 0 auto;
      flex-direction: row-reverse;
    }

    .modal-panel .btn-groups>input[type="button"] {
      margin: 8px;
      padding: 2px 8px;
      flex: 1;
      border: none;
      background: transparent;
    }

    .modal-panel .close {
      --box-size: 36px;
      --size: 32px;
      --half-size: 20px;
      position: absolute;
      width: var(--box-size);
      height: var(--box-size);
      position: fixed;
      top: 10px;
      left: 10px;
      padding: 2px;
      background: #00000080;
      border-radius: var(--size);
    }

    .modal-panel .close:before,
    .modal-panel .close:after {
      position: absolute;
      left: var(--half-size);
      content: " ";
      height: var(--size);
      width: 2px;
      top: 4px;
      background: white;
    }

    .modal-panel .close:before {
      transform: rotate(45deg);
    }

    .modal-panel .close:after {
      transform: rotate(-45deg);
    }

    .modal-panel .value-items {}

    .modal-panel .value-item {
      margin: 5px 0;
      padding: 8px 10px;
      border-radius: 5px;
      min-height: 1.5em;
      display: flex;
      justify-content: center;
      align-items: center;
      border: 1px solid #0001;
    }

    .modal-panel .value-item.current-value-item {
      font-weight: bold;
      border: 1px solid #0004;
      background: transparent;
    }

    .app {
      --jin-bg: gold;
      --jin-fg: black;
      --mu-bg: green;
      --mu-fg: white;
      --shui-bg: blue;
      --shui-fg: white;
      --huo-bg: red;
      --huo-fg: white;
      --tu-bg: brown;
      --tu-fg: white;
      --wall-bg1: #f19f41;
      --wall-bg2: #f19f4155;
      --wall-bg3: #f19f4177;
      --wall-bg4: #cf7e22;
      --fg: black;
      --bg: white;
    }

    .app.dark {
      --wall-bg1: #683f10;
      --wall-bg2: #683f1055;
      --wall-bg3: #683f1077;
      --wall-bg4: #351e03;
      --fg: #f5f5f5;
      --bg: #333;
    }

    .status-indicator {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      z-index: -1;
      flex-direction: column;
    }

    .status-indicator>* {
      flex: 1;
      width: 100%;
      display: flex;
    }

    .status-indicator>*:nth-child(2) {
      flex: 8;
    }

    .status-indicator>*>* {
      height: 100%;
      transition: flex 0.1s linear;
    }

    .top-indicator {
      --bg1: var(--huo-bg);
      --bg2: #000;
    }

    .top-indicator>*:nth-child(1) {
      background: var(--bg1);
      flex: var(--current);
    }

    .top-indicator>*:nth-child(2) {
      background: var(--bg2);
      opacity: 0.3;
      flex: calc(var(--total) - var(--current));
    }

    .floor-wraper {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.9);
      border-radius: 10px;
      overflow: hidden;
    }

    .cell-editing-panel-wraper {
      position: absolute;
      top: 50%;
      transform: translate(0%, -50%) scale(0.8);
      opacity: 0.5;
      border-radius: 5px;
      overflow: hidden;
      font-size: small;
    }

    .cell-editing-panel-wraper.first {
      left: 5px;
    }

    .cell-editing-panel-wraper.second {
      right: 5px;
    }

    .cell-editing-panel-wraper.editing {
      opacity: unset;
      /* filter: drop-shadow(1px 1px 2px); */
    }

    .cell-editing-panel .cell-wraper .cell-button {
      text-align: center;
      vertical-align: middle;
      top: 50%;
      transform: translate(0, -30%);
    }

    .cell-editing-panel .cell-wraper {
      border: 1px solid #0004;
      margin: 2.5px;
      box-sizing: border-box;
      overflow: hidden;
      border-radius: 10px;
    }

    .cell-editing-panel .selected-modifier {
      border-color: var(--huo-bg);
    }

    .cell-editing-panel {
      display: flex;
      flex-direction: column;
    }

    .editing .floor-wraper {
      /* transform: translate(calc(-50% + var(--cell-width)/3), -50%) scale(0.8); */
      transform: translate(-50%, -50%) scale(0.8);
    }

    .floor-floor-wraper {
      box-shadow: 3px 3px 5px;
    }

    .light .with-bg .floor-floor .Floor,
    .light .cell-editing-panel-wraper,
    .light .floor-bg {
      background-color: var(--white);
      background-image: repeating-radial-gradient(circle at 0.5em 0.05em,
          var(--trans),
          var(--trans) 0.2em,
          var(--mushroom) 0.21em,
          var(--mushroom) 0.3em,
          var(--trans) 0.31em),
        repeating-radial-gradient(circle at 0.5em 0.95em,
          var(--trans),
          var(--trans) 0.2em,
          var(--mushroom) 0.21em,
          var(--mushroom) 0.3em,
          var(--trans) 0.31em);
      background-size: 1em 1em;
    }

    .dark .with-bg .floor-floor .Floor,
    .dark .cell-editing-panel-wraper,
    .dark .floor-bg {
      background: radial-gradient(rgba(255, 255, 255, 0.05) 20%, transparent) 0 0/20px 20px,
        radial-gradient(#ffca08 6%, transparent 8%) 0 0/20px 20px,
        radial-gradient(#ffca08 6%, transparent 8%) 10px 10px/20px 20px,
        linear-gradient(45deg,
          transparent 48%,
          #000000 49% 51%,
          transparent 52%) 0 0/20px 20px,
        linear-gradient(-45deg,
          transparent 48%,
          #000000 49% 51%,
          transparent 52%) 0 0/20px 20px;
      background-color: #262626;
    }

    .floor-bg>* {
      background: var(--bg);
    }

    .floor {
      display: grid;
      position: relative;
    }

    .wall-floor {
      filter: drop-shadow(3px 3px 3px black) drop-shadow(-1px -1px 1px #0004);
    }

    .row {
      display: flex;
    }

    .cell,
    .unit {
      width: var(--cell-width);
      height: var(--cell-width);
      /* max-width: 4em;
      max-height: 4em; */
      position: relative;
    }

    .unit {}

    .unit.died {
      opacity: 0;
      transition: ease 1s opacity;
      pointer-events: none;
    }

    .unit.aliving {
      opacity: 0.5;
      pointer-events: none;
      animation: blinker 1s linear infinite;
    }

    .unit.ghost>* {
      opacity: 0;
      pointer-events: none;
    }

    .unit.ghost>.sprite {
      opacity: unset;
      pointer-events: unset;
    }

    @keyframes blinker {
      50% {
        opacity: 0;
      }
    }

    .shadow-unit {
      opacity: 0;
      transition: ease 0.1s opacity;
    }

    .cell>* {
      width: 100%;
      height: 100%;
      top: 0;
      position: absolute;
    }

    .Wall {
      /* box-shadow: 3px 3px 3px; */
      background: linear-gradient(135deg,
          var(--wall-bg2) 25%,
          transparent 25%) -4px 0/ 8px 8px,
        linear-gradient(225deg, var(--wall-bg1) 25%, transparent 25%) -4px 0/ 8px 8px,
        linear-gradient(315deg, var(--wall-bg2) 25%, transparent 25%) 0px 0/ 8px 8px,
        linear-gradient(45deg, var(--wall-bg1) 25%, var(--wall-bg4) 25%) 0px 0/ 8px 8px;
    }

    .EmptyWall,
    .emptywall {
      opacity: 0;
    }

    .UnknownWall {
      opacity: 0;
      background: coral;
    }

    .UnknownWall>* {
      opacity: 0 !important;
    }

    .Wall.corner-cell {
      background-color: var(--wall-bg4);
      background-image: linear-gradient(30deg,
          var(--wall-bg1) 12%,
          transparent 12.5%,
          transparent 87%,
          var(--wall-bg1) 87.5%,
          var(--wall-bg1)),
        linear-gradient(150deg,
          var(--wall-bg1) 12%,
          transparent 12.5%,
          transparent 87%,
          var(--wall-bg1) 87.5%,
          var(--wall-bg1)),
        linear-gradient(30deg,
          var(--wall-bg1) 12%,
          transparent 12.5%,
          transparent 87%,
          var(--wall-bg1) 87.5%,
          var(--wall-bg1)),
        linear-gradient(150deg,
          var(--wall-bg1) 12%,
          transparent 12.5%,
          transparent 87%,
          var(--wall-bg1) 87.5%,
          var(--wall-bg1)),
        linear-gradient(60deg,
          var(--wall-bg3) 25%,
          transparent 25.5%,
          transparent 75%,
          var(--wall-bg3) 75%,
          var(--wall-bg3)),
        linear-gradient(60deg,
          var(--wall-bg3) 25%,
          transparent 25.5%,
          transparent 75%,
          var(--wall-bg3) 75%,
          var(--wall-bg3));
      background-size: 8px 14px;
      background-position: 0 0, 0 0, 4px 7px, 4px 7px, 0 0, 4px 7px;
    }

    .Floor {
      /* box-shadow: 0px 0px 1px #0004; */
    }

    .shadow-floor-wraper {
      pointer-events: none;
    }

    .shadow-floor {}

    .shadow-floor .cell>* {
      background: #000;
      opacity: 0.3;
    }

    .shadow-floor .cell>.visited-cell {}

    .shadow-floor .cell>.nearby-cell {
      opacity: 0;
      transition: ease 0.1s opacity;
    }

    .cell .selected-cell {
      color: var(--fg);
      /* background: var(--bg); */
      z-index: 999;
      border-radius: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: blinker 1s ease-in-out infinite;
    }

    .half-selected-cell.row,
    .half-selected-cell.column {
      z-index: 999;
      border: dotted var(--fg);
    }

    .half-selected-cell.column {
      border-width: 0 1px 0 1px;
    }

    .half-selected-cell.row {
      border-width: 1px 0 1px 0;
    }

    .prop {
      opacity: calc(0.25 + var(--propstrength) * 0.25 / 10);
      /* filter: blur(1px); */
    }

    .jin {
      background: var(--jin-bg);
      color: var(--jin-fg);
    }

    .mu {
      background: var(--mu-bg);
      color: var(--mu-fg);
    }

    .shui {
      background: var(--shui-bg);
      color: var(--shui-fg);
    }

    .huo {
      background: var(--huo-bg);
      color: var(--huo-fg);
    }

    .tu {
      background: var(--tu-bg);
      color: var(--tu-fg);
    }

    .unit {
      position: absolute;
      top: var(--offset-y);
      left: var(--offset-x);
    }

    .unit.player {
      z-index: 2;
    }

    .moving {
      transition: top 0.1s, left 0.1s;
    }

    .unit>* {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1;
      width: 100%;
      height: 100%;
    }

    /* .app.dark .unit>* {
      filter: grayscale(0.3);
    } */

    .unit>.avatar {
      width: 82%;
      height: 82%;
      box-shadow: 1px 1px 2px #000;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(var(--jin-bg) 0%,
          var(--jin-bg) var(--p-jin),
          var(--mu-bg) var(--p-jin),
          var(--mu-bg) var(--p-mu),
          var(--shui-bg) var(--p-mu),
          var(--shui-bg) var(--p-shui),
          var(--huo-bg) var(--p-shui),
          var(--huo-bg) var(--p-huo),
          var(--tu-bg) var(--p-huo),
          var(--tu-bg) var(--p-tu),
          var(--jin-bg) var(--p-tu));
      backdrop-filter: blur(10px);
      border-radius: 0px;
      overflow: hidden;
    }

    .floor-bg {
      width: 100%;
      height: 100%;
      position: fixed;
      top: 0;
      left: 0;
    }

    .floor-bg img {
      object-fit: cover;
      filter: blur(10px);
      opacity: 0.8;
      width: 100%;
      height: 100%;
    }

    .unit.unmovable>.avatar {
      /* width: 94%;
      height: 94%; */
      /* box-shadow: none; */
      /* box-shadow: 3px 3px 5px; */
      /* border-radius: 0; */
      box-shadow: 1px 1px 2px #000 inset;
    }

    .unit.group-1>.avatar {
      border-radius: 10px;
    }

    .unit.group-2>.avatar {
      border-radius: 5px;
    }

    .unit.group-0>.avatar {
      border-radius: 25%;
    }

    .unit>.name {
      color: #fff;
      width: 50%;
      height: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      font-weight: bolder;
    }

    .sprite {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--cell-width);
    }

    .end.sprite,
    .start.sprite {
      box-shadow: 2px 2px 4px inset;
      border-radius: 10px;
      width: 90%;
      height: 90%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .end.sprite>span,
    .start.sprite>span {
      transform: translate(5%, 0) scale(0.8);
    }

    .unit>.sprite {
      transform: translate(-45%, -50%) scale(0.8);
    }

    .unit.skilled>.name {
      /* font-style: italic; */
      font-family: American Typewriter;
    }

    .player>.avatar {
      /* background: #fff;
      color: #2d2d2d; */
      /* border-radius: 10px; */
      /* opacity: 0; */
    }

    .fighting>.pointer {
      background: #fffa;
      width: 100%;
      height: 100%;
      animation: blinker 0.5s ease-in-out infinite;
    }

    .player>.pointer {
      background: #fffa;
      width: 100%;
      height: 100%;
      border-radius: 5px;
    }

    .player>.pointer.active {
      animation: blinker 1s ease-in-out infinite;
    }

    .editing .unit>.pointer {
      display: none;
    }

    /* b-blink b-transparent */

    .b-opacity05 {
      opacity: 0.5;
    }

    .b-blink {
      animation: blinker 1s ease-in-out infinite;
    }

    .b-wushuang {}

    .b-power {}

    .entry {
      position: absolute;
    }

    .entry>.avatar {
      width: 90%;
      height: 90%;
      top: 5%;
      left: 5%;
      box-shadow: 2px 2px 4px inset;
      z-index: 1;
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      color: #0009;
      border-radius: 10px;
    }

    .entry>.avatar>span {
      color: #666;
    }

    .dark .entry>.avatar>span {
      color: #ccc;
    }

    .prop-increase {}

    .menus {
      position: absolute;
      bottom: 40px;
      width: 100%;
      opacity: 0.5;
    }

    .menus.top {
      bottom: unset;
      top: 45px;
    }

    .menus.left {
      width: 50%;
    }

    .menus.right {
      right: 0;
      width: 50%;
    }

    .menus>div {
      display: flex;
      justify-content: center;
    }

    .menus>div>* {
      width: 1.15em;
      height: 1.15em;
      font-size: 2.2rem;
      margin: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .menus.right>div>* {
      width: 35%;
      font-size: 1.15rem;
      color: var(--shui-fg);
      border-radius: 10px;
      padding: 5px 10px;
      box-shadow: 3px 3px 5px;
      opacity: 0.75;
      position: relative;
      overflow: hidden;
    }

    .menus.right>div>.uncooldown {
      pointer-events: none;
      /* color: transparent; */
    }

    .menus.right>div>.active {
      opacity: 1;
      color: var(--shui-fg);
    }

    .menus>div>.icon-wraper {
      background: var(--huo-bg);
      border-radius: 10px;
      box-shadow: 1px 1px 2px #0008;
    }

    .menus.top>div>.icon-wraper {
      background: #000c;
    }

    .icon {
      width: 1em;
      height: 1em;
      background: #fff;
      mask-size: cover;
      -webkit-mask-size: cover;
    }

    .editing--top-menus.menus.top>div>.icon-wraper {
      background: var(--huo-bg);
    }

    .Left>.icon {
      mask: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPgogIDxwYXRoIGQ9Ik02ODkgMTY1LjFMMzA4LjIgNDkzLjVjLTEwLjkgOS40LTEwLjkgMjcuNSAwIDM3TDY4OSA4NTguOWMxNC4yIDEyLjIgMzUgMS4yIDM1LTE4LjVWMTgzLjZjMC0xOS43LTIwLjgtMzAuNy0zNS0xOC41eiIvPgo8L3N2Zz4K");
    }

    .Up>.icon {
      mask: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPgogIDxwYXRoIGQ9Ik04NTguOSA2ODlMNTMwLjUgMzA4LjJjLTkuNC0xMC45LTI3LjUtMTAuOS0zNyAwTDE2NS4xIDY4OWMtMTIuMiAxNC4yLTEuMiAzNSAxOC41IDM1aDY1Ni44YzE5LjcgMCAzMC43LTIwLjggMTguNS0zNXoiLz4KPC9zdmc+Cg==");
    }

    .Right>.icon {
      mask: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPgogIDxwYXRoIGQ9Ik03MTUuOCA0OTMuNUwzMzUgMTY1LjFjLTE0LjItMTIuMi0zNS0xLjItMzUgMTguNXY2NTYuOGMwIDE5LjcgMjAuOCAzMC43IDM1IDE4LjVsMzgwLjgtMzI4LjRjMTAuOS05LjQgMTAuOS0yNy42IDAtMzd6Ii8+Cjwvc3ZnPgo=");
    }

    .Down>.icon {
      mask: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPgogIDxwYXRoIGQ9Ik04NDAuNCAzMDBIMTgzLjZjLTE5LjcgMC0zMC43IDIwLjgtMTguNSAzNWwzMjguNCAzODAuOGM5LjQgMTAuOSAyNy41IDEwLjkgMzcgMEw4NTguOSAzMzVjMTIuMi0xNC4yIDEuMi0zNS0xOC41LTM1eiIvPgo8L3N2Zz4K");
    }

    .Restart>.icon {
      mask: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgY2xhc3M9Imljb24iIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPgogIDxwYXRoIGQ9Ik0xNjggNTA0LjJjMS00My43IDEwLTg2LjEgMjYuOS0xMjYgMTcuMy00MSA0Mi4xLTc3LjcgNzMuNy0xMDkuNFMzMzcgMjEyLjMgMzc4IDE5NWM0Mi40LTE3LjkgODcuNC0yNyAxMzMuOS0yN3M5MS41IDkuMSAxMzMuOCAyN0EzNDEuNSAzNDEuNSAwIDAgMSA3NTUgMjY4LjhjOS45IDkuOSAxOS4yIDIwLjQgMjcuOCAzMS40bC02MC4yIDQ3YTggOCAwIDAgMCAzIDE0LjFsMTc1LjcgNDNjNSAxLjIgOS45LTIuNiA5LjktNy43bC44LTE4MC45YzAtNi43LTcuNy0xMC41LTEyLjktNi4zbC01Ni40IDQ0LjFDNzY1LjggMTU1LjEgNjQ2LjIgOTIgNTExLjggOTIgMjgyLjcgOTIgOTYuMyAyNzUuNiA5MiA1MDMuOGE4IDggMCAwIDAgOCA4LjJoNjBjNC40IDAgNy45LTMuNSA4LTcuOHptNzU2IDcuOGgtNjBjLTQuNCAwLTcuOSAzLjUtOCA3LjgtMSA0My43LTEwIDg2LjEtMjYuOSAxMjYtMTcuMyA0MS00Mi4xIDc3LjgtNzMuNyAxMDkuNEEzNDIuNDUgMzQyLjQ1IDAgMCAxIDUxMi4xIDg1NmEzNDIuMjQgMzQyLjI0IDAgMCAxLTI0My4yLTEwMC44Yy05LjktOS45LTE5LjItMjAuNC0yNy44LTMxLjRsNjAuMi00N2E4IDggMCAwIDAtMy0xNC4xbC0xNzUuNy00M2MtNS0xLjItOS45IDIuNi05LjkgNy43bC0uNyAxODFjMCA2LjcgNy43IDEwLjUgMTIuOSA2LjNsNTYuNC00NC4xQzI1OC4yIDg2OC45IDM3Ny44IDkzMiA1MTIuMiA5MzJjMjI5LjIgMCA0MTUuNS0xODMuNyA0MTkuOC00MTEuOGE4IDggMCAwIDAtOC04LjJ6Ii8+Cjwvc3ZnPgo=");
    }

    .InsertBefore>.icon {
      mask: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgY2xhc3M9Imljb24iIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPgogIDxwYXRoIGQ9Ik0zMjYgMTY0aC02NGMtNC40IDAtOCAzLjYtOCA4djY4OGMwIDQuNCAzLjYgOCA4IDhoNjRjNC40IDAgOC0zLjYgOC04VjE3MmMwLTQuNC0zLjYtOC04LTh6bTQ0NCA3Mi40VjE2NGMwLTYuOC03LjktMTAuNS0xMy4xLTYuMUwzMzUgNTEybDQyMS45IDM1NC4xYzUuMiA0LjQgMTMuMS43IDEzLjEtNi4xdi03Mi40YzAtOS40LTQuMi0xOC40LTExLjQtMjQuNUw0NTkuNCA1MTJsMjk5LjItMjUxLjFjNy4yLTYuMSAxMS40LTE1LjEgMTEuNC0yNC41eiIvPgo8L3N2Zz4K");
    }

    .InsertAfter>.icon {
      mask: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgY2xhc3M9Imljb24iIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPgogIDxwYXRoIGQ9Ik03NjIgMTY0aC02NGMtNC40IDAtOCAzLjYtOCA4djY4OGMwIDQuNCAzLjYgOCA4IDhoNjRjNC40IDAgOC0zLjYgOC04VjE3MmMwLTQuNC0zLjYtOC04LTh6bS01MDggMHY3Mi40YzAgOS41IDQuMiAxOC40IDExLjQgMjQuNUw1NjQuNiA1MTIgMjY1LjQgNzYzLjFjLTcuMiA2LjEtMTEuNCAxNS0xMS40IDI0LjVWODYwYzAgNi44IDcuOSAxMC41IDEzLjEgNi4xTDY4OSA1MTIgMjY3LjEgMTU3LjlBNy45NSA3Ljk1IDAgMCAwIDI1NCAxNjR6Ii8+Cjwvc3ZnPgo=");
    }

    .Delete>.icon {
      mask: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgY2xhc3M9Imljb24iIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPgogIDxwYXRoIGQ9Ik0zNjAgMTg0aC04YzQuNCAwIDgtMy42IDgtOHY4aDMwNHYtOGMwIDQuNCAzLjYgOCA4IDhoLTh2NzJoNzJ2LTgwYzAtMzUuMy0yOC43LTY0LTY0LTY0SDM1MmMtMzUuMyAwLTY0IDI4LjctNjQgNjR2ODBoNzJ2LTcyem01MDQgNzJIMTYwYy0xNy43IDAtMzIgMTQuMy0zMiAzMnYzMmMwIDQuNCAzLjYgOCA4IDhoNjAuNGwyNC43IDUyM2MxLjYgMzQuMSAyOS44IDYxIDYzLjkgNjFoNDU0YzM0LjIgMCA2Mi4zLTI2LjggNjMuOS02MWwyNC43LTUyM0g4ODhjNC40IDAgOC0zLjYgOC04di0zMmMwLTE3LjctMTQuMy0zMi0zMi0zMnpNNzMxLjMgODQwSDI5Mi43bC0yNC4yLTUxMmg0ODdsLTI0LjIgNTEyeiIvPgo8L3N2Zz4K");
    }

    .Close>.icon {
      mask: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgY2xhc3M9Imljb24iIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPgogIDxwYXRoIGQ9Ik03MDUuNiAxMjQuOWE4IDggMCAwIDAtMTEuNiA3LjJ2NjQuMmMwIDUuNSAyLjkgMTAuNiA3LjUgMTMuNmEzNTIuMiAzNTIuMiAwIDAgMSA2Mi4yIDQ5LjhjMzIuNyAzMi44IDU4LjQgNzAuOSA3Ni4zIDExMy4zYTM1NSAzNTUgMCAwIDEgMjcuOSAxMzguN2MwIDQ4LjEtOS40IDk0LjgtMjcuOSAxMzguN2EzNTUuOTIgMzU1LjkyIDAgMCAxLTc2LjMgMTEzLjMgMzUzLjA2IDM1My4wNiAwIDAgMS0xMTMuMiA3Ni40Yy00My44IDE4LjYtOTAuNSAyOC0xMzguNSAyOHMtOTQuNy05LjQtMTM4LjUtMjhhMzUzLjA2IDM1My4wNiAwIDAgMS0xMTMuMi03Ni40QTM1NS45MiAzNTUuOTIgMCAwIDEgMTg0IDY1MC40YTM1NSAzNTUgMCAwIDEtMjcuOS0xMzguN2MwLTQ4LjEgOS40LTk0LjggMjcuOS0xMzguNyAxNy45LTQyLjQgNDMuNi04MC41IDc2LjMtMTEzLjMgMTktMTkgMzkuOC0zNS42IDYyLjItNDkuOCA0LjctMi45IDcuNS04LjEgNy41LTEzLjZWMTMyYzAtNi02LjMtOS44LTExLjYtNy4yQzE3OC41IDE5NS4yIDgyIDMzOS4zIDgwIDUwNi4zIDc3LjIgNzQ1LjEgMjcyLjUgOTQzLjUgNTExLjIgOTQ0YzIzOSAuNSA0MzIuOC0xOTMuMyA0MzIuOC00MzIuNCAwLTE2OS4yLTk3LTMxNS43LTIzOC40LTM4Ni43ek00ODAgNTYwaDY0YzQuNCAwIDgtMy42IDgtOFY4OGMwLTQuNC0zLjYtOC04LThoLTY0Yy00LjQgMC04IDMuNi04IDh2NDY0YzAgNC40IDMuNiA4IDggOHoiLz4KPC9zdmc+Cg==");
    }

    .Save>.icon {
      mask: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgY2xhc3M9Imljb24iIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPgogIDxwYXRoIGQ9Ik04NjQgMjQ4SDcyOGwtMzIuNC05MC44YTMyLjA3IDMyLjA3IDAgMCAwLTMwLjItMjEuMkgzNTguNmMtMTMuNSAwLTI1LjYgOC41LTMwLjEgMjEuMkwyOTYgMjQ4SDE2MGMtNDQuMiAwLTgwIDM1LjgtODAgODB2NDU2YzAgNDQuMiAzNS44IDgwIDgwIDgwaDcwNGM0NC4yIDAgODAtMzUuOCA4MC04MFYzMjhjMC00NC4yLTM1LjgtODAtODAtODB6bTggNTM2YzAgNC40LTMuNiA4LTggOEgxNjBjLTQuNCAwLTgtMy42LTgtOFYzMjhjMC00LjQgMy42LTggOC04aDE4Ni43bDE3LjEtNDcuOCAyMi45LTY0LjJoMjUwLjVsMjIuOSA2NC4yIDE3LjEgNDcuOEg4NjRjNC40IDAgOCAzLjYgOCA4djQ1NnpNNTEyIDM4NGMtODguNCAwLTE2MCA3MS42LTE2MCAxNjBzNzEuNiAxNjAgMTYwIDE2MCAxNjAtNzEuNiAxNjAtMTYwLTcxLjYtMTYwLTE2MC0xNjB6bTAgMjU2Yy01MyAwLTk2LTQzLTk2LTk2czQzLTk2IDk2LTk2IDk2IDQzIDk2IDk2LTQzIDk2LTk2IDk2eiIvPgo8L3N2Zz4K");
    }

    .Load.disabled {
      opacity: 0.5;
    }

    .Load>.icon {
      mask: url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiPgogIDxwYXRoIGQ9Ik05MTIgMTkySDMyOGMtNC40IDAtOCAzLjYtOCA4djU2YzAgNC40IDMuNiA4IDggOGg1ODRjNC40IDAgOC0zLjYgOC04di01NmMwLTQuNC0zLjYtOC04LTh6bTAgMjg0SDMyOGMtNC40IDAtOCAzLjYtOCA4djU2YzAgNC40IDMuNiA4IDggOGg1ODRjNC40IDAgOC0zLjYgOC04di01NmMwLTQuNC0zLjYtOC04LTh6bTAgMjg0SDMyOGMtNC40IDAtOCAzLjYtOCA4djU2YzAgNC40IDMuNiA4IDggOGg1ODRjNC40IDAgOC0zLjYgOC04di01NmMwLTQuNC0zLjYtOC04LTh6TTEwNCAyMjhhNTYgNTYgMCAxIDAgMTEyIDAgNTYgNTYgMCAxIDAtMTEyIDB6bTAgMjg0YTU2IDU2IDAgMSAwIDExMiAwIDU2IDU2IDAgMSAwLTExMiAwem0wIDI4NGE1NiA1NiAwIDEgMCAxMTIgMCA1NiA1NiAwIDEgMC0xMTIgMHoiLz4KPC9zdmc+Cg==");
    }

    .menus>div>.info {
      font-size: 1rem;
      height: 2.75em;
      font-weight: bold;
      color: var(--fg);
      flex-direction: column;
      flex: 1;
    }

    .menus>div>.info>*:last-child {
      font-size: small;
    }

    .menus .props-wraper {
      flex-direction: column;
      max-height: 135px;
      overflow-y: auto;
      display: block;
    }

    .menus .props {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      margin: 0 15px;
      flex: 1;
      height: unset;
      width: unset;
    }

    .menus .props.editing-units {
      display: block;
      overflow-x: hidden;
      overflow-y: auto;
      max-height: 130px;
      opacity: 0.5;
      position: relative;
    }

    .menus .props.editing-units.editing {
      opacity: 1;
    }

    .menus .props.editing-units tbody {
      width: 100%;
    }

    .menus .props.editing-units table {
      width: 100%;
      position: unset;
    }

    .menus .props.editing-units table tr:nth-child(1) {
      position: sticky;
      top: 0;
    }

    .menus .props.editing-units table tr:nth-child(2) {
      color: var(--mu-bg);
      font-weight: bold;
    }

    .menus .props.editing-units table td {
      text-align: center;
    }

    .menus .props.editing-units tr.current {
      font-weight: bold;
      text-decoration: underline;
      /* animation: blinker 2s ease-in-out infinite; */
    }

    .menus>div.menu-buttons {
      margin: 5px 15px 0 15px;
      justify-content: space-between;
    }

    .menus .props>* {
      font-size: 1rem;
      width: unset;
      padding: 1px 3px;
      border-radius: 5px;
      margin: 3px;
      display: inline-block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      position: relative;
    }

    .menus .props>*>span {
      /* padding: 5px; */
    }

    .menus .props>.name {
      grid-column-start: 1;
      grid-column-end: 5;
    }

    .menus .props>.name {
      background: var(--mu-bg);
      color: var(--mu-fg);
      display: flex;
      align-items: center;
    }

    .menus .props>.name>.skills {
      align-self: end;
    }

    .menus .props>.life-wraper {
      color: var(--tu-fg);
    }

    .menus .top-indicator>* {
      transition: unset;
    }

    .menus .top-indicator>*:nth-child(2) {
      opacity: 0.5;
    }

    .menus .props>.life-wraper .top-indicator {
      --bg1: var(--tu-bg);
      --bg2: var(--tu-bg);
    }

    .menus .props>.jin-wraper {
      color: var(--jin-fg);
    }

    .menus .props>.jin-wraper .top-indicator {
      --bg1: var(--jin-bg);
      --bg2: var(--jin-bg);
    }

    .menus .props>.mu-wraper {
      color: var(--mu-fg);
    }

    .menus .props>.mu-wraper .top-indicator {
      --bg1: var(--mu-bg);
      --bg2: var(--mu-bg);
    }

    .menus .props>.shui-wraper {
      color: var(--shui-fg);
    }

    .menus .props>.shui-wraper .top-indicator {
      --bg1: var(--shui-bg);
      --bg2: var(--shui-bg);
    }

    .menus .props>.huo-wraper {
      color: var(--huo-fg);
    }

    .menus .props>.huo-wraper .top-indicator {
      --bg1: var(--huo-bg);
      --bg2: var(--huo-bg);
    }

    .menus .props>.tu-wraper {
      color: var(--tu-fg);
    }

    .menus .props>.tu-wraper .top-indicator {
      --bg1: var(--tu-bg);
      --bg2: var(--tu-bg);
    }

    .mems-wraper,
    .saving-wraper,
    .editing-result-wraper,
    .modal-content-wraper,
    .help,
    .action-wraper {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      /* font-size: small; */
    }

    .mems-wraper,
    .saving-wraper,
    .help {
      background: #fff8;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }

    .mems,
    .saving,
    .editing-result,
    .modal-content,
    .help-content {
      background: var(--bg);
      color: var(--fg);
      border-radius: 20px;
      box-shadow: 3px 3px 5px #0004;
      width: 90%;
      padding: 15px 0;
      max-height: 60%;
      display: flex;
    }

    .console-panel {
      display: flex;
      flex-direction: column;
      max-height: 200px;
      width: 80%;
      max-width: 600px;
      overflow: hidden;
      padding: 15px;
      margin: 8px 5px;
      font-family: monospace;
    }

    .console-panel .console-in {}

    .console-panel .console-in>input {
      display: block;
      width: 100%;
      font-size: large;
      border: none;
      background: #0001;
      padding: 10px;
      border-radius: 10px;
      font-family: monospace;
      outline: none !important;
    }

    .console-panel .console-outs {
      overflow-y: auto;
      opacity: 0.8;
    }

    .console-panel .console-outs>* {
      margin: 8px 5px;
    }

    .editing-unit {
      flex-direction: column;
      height: 80vh;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .editing-unit>* {
      margin: 5px 15px;
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .editing-unit .title {
      flex: unset;
      font-size: large;
      font-weight: bold;
    }

    .simple-props {
      display: grid;
      flex: unset;
      grid-template-columns: repeat(1, 1fr);
    }

    .simple-props>* {
      display: flex;
      justify-content: space-between;
    }

    .editing-unit textarea {
      display: block;
      width: 100%;
      flex: 1;
    }

    .editing-result {
      flex-direction: column;
      padding: 0 15px;
      height: 60vh;
    }

    .editing-result-menus {
      display: flex;
      margin: 10px 0 0 0;
      justify-content: space-between;
      align-items: center;
    }

    .editing-result-menus>* {
      margin: 5px;
    }

    .editing-result-menus>.title {
      font-weight: bold;
      font-size: large;
      margin: 0;
    }

    .editing-result-info {
      margin: 5px 0;
      padding: 5px;
      background: #0004;
      border-radius: 5px;
    }

    .editing-result-content {
      display: block;
      flex: 1;
      padding: 5px;
      margin-bottom: 10px;
    }

    .mems {
      padding: 15px;
      flex-direction: column;
    }

    .mems .title {
      font-size: large;
      font-weight: bold;
      margin: 0 0 1em 0;
    }

    .mems .mem {
      padding: 5px 0;
      padding: 10px 0;
      opacity: 0.8;
    }

    .help-content>* {
      overflow: auto;
      padding: 0 15px;
      flex: 1;
    }

    .action-wraper {
      align-items: end;
    }

    .action-content {
      background: var(--bg);
      color: var(--fg);
      width: 100%;
      border-radius: 0;
      box-shadow: 1px 1px 3px;
      padding: 20px 15px 60px 15px;
      max-height: 80%;
      overflow: auto;
      display: flex;
      flex-direction: row;
      opacity: 0.8;
    }

    .action-content .target-unit {
      background: var(--mu-bg);
      color: white;
      width: 3em;
      min-height: 3em;
      display: flex;
      justify-content: center;
      align-items: center;
      border-radius: 10px;
      margin-right: 10px;
      position: relative;
      overflow: hidden;
      flex-direction: column;
    }

    .action-content .target-unit-name {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .target-unit-icon~.target-unit-name {
      font-size: 0.5em;
      padding: 5px 0;
    }

    .action-content .target-unit-icon {}

    .action-content .target-unit-icon img {
      height: 3em;
      width: 3em;
    }

    .action-content .action-body {
      flex: 1;
    }

    .action-content .question {
      font-weight: bold;
      margin: 0 0 0.25em 0;
    }

    .action-content .answers {
      counter-reset: answer;
      display: flex;
    }

    .action-content .answers .answer {
      flex: 1;
      padding: 5px;
      margin-right: 5px;
      display: flex;
      align-items: center;
      justify-items: center;
      border-radius: 5px;
      background: #00000008;
    }

    .dark .action-content .answers .answer {
      background: #ffffff08;
    }

    .action-content .answers .answer.current-answer {
      font-weight: bold;
      text-decoration: underline;
    }

    .action-content .answers .answer.current-answer::before {
      content: "*. ";
    }

    .help-detail {
      background: #ccc;
      margin: 10px 0;
      padding: 10px 5px;
      border-radius: 5px;
    }

    .help-detail span {
      padding: 0 0 0 5px;
    }

    .help-detail span~span::before {
      content: "->";
      padding: 0 5px;
    }

    .battle-info {
      border: 1px solid;
      margin: 10px 0px;
      padding: 10px 5px;
      border-radius: 5px;
      max-height: 12em;
      overflow-y: scroll;
    }

    .battle-infos {}

    table {
      border-collapse: collapse;
      width: 100%;
      margin: 0 0 10px 0;
      color: var(--fg);
      /* font-size: small; */
    }

    table,
    th,
    td {
      /* border: 1px solid; */
    }

    table .name {
      display: flex;
      align-items: center;
    }

    table td {}

    table.args {
      border: 1px solid;
      border-radius: 5px;
      border-collapse: separate;
      padding: 0 5px;
    }

    table.args td input {
      border: none;
      width: 100%;
    }

    .battle-details {}

    .battle-detail {}

    .skills>.skill {
      font-size: xx-small;
      color: #fff;
      padding: 0 2px;
    }

    .money {
      padding: 0 2px;
      color: var(--jin-bg);
    }

    .soldable,
    .unleart {
      display: grid;
      grid-template-columns: 1fr 1fr;
    }

    .soldable .title,
    .unleart .title {
      font-size: large;
      font-weight: bold;
      margin: 0.25em 0;
    }

    .soldable .skill,
    .unleart .skill {
      margin: 0 0.5em 0.5em 0;
      display: flex;
      align-items: center;
    }

    .soldable .price,
    .unleart .price {
      flex: 1;
      margin: 0 5px;
      flex: 1;
    }

    .soldable .sell,
    .unleart .buy {
      background: var(--jin-bg);
      color: var(--jin-fg);
      border-radius: 10px;
      padding: 2px 5px;
      font-size: x-small;
    }

    .button {
      display: inline-block;
      background: var(--mu-bg);
      color: var(--mu-fg);
      border-radius: 5px;
      padding: 0px 5px;
      font-size: small;
    }

    .button.danger {
      background: var(--huo-bg);
      color: var(--huo-fg);
    }

    .spacer {
      flex: 1;
    }

    .soldable .sell {
      background: var(--huo-bg);
      color: var(--huo-fg);
    }

    .skills-control {
      flex-direction: column;
      align-items: center;
      flex-wrap: wrap;
      max-height: 200px;
      counter-reset: skill-name;
    }

    .skill-cooldown>*:nth-child(1) {
      background: var(--shui-bg);
      flex: calc(var(--all-cooldown) - var(--cooldown));
    }

    .skill-cooldown>*:nth-child(2) {
      background: var(--shui-bg);
      flex: var(--cooldown);
      opacity: 0.3;
    }

    .name-icon {
      height: 1.4em;
      width: 1.4em;
      align-self: center;
      margin-right: 2px;
      border-radius: 4px;
    }

    .landscape-info {
      display: none !important;
    }

    .floor-items,
    .entry-items {
      flex-wrap: wrap;
    }

    .menus>div>*.entry-item,
    .menus>div>*.floor-item {
      font-size: unset;
      width: unset;
      height: unset;
    }

    .menus>div>*.entry-item {
      display: flex;
      /* height: 1.3em; */
      margin: 3px 0;
      /* margin: 1px 0; */
    }

    .edit-entry-menu-item {
      font-weight: bold;
      color: var(--mu-bg);
    }

    .menus>div>*.entry-item>* {
      flex: 1;
      text-align: center;
      margin: 0 2px;
      /* font-size: small; */
    }

    .entry-item .current {
      font-weight: bold;
      text-decoration: underline;
    }

    .entry-item .current.editing {
      animation: blinker 2s ease-in-out infinite;
    }

    .editing--top-menus {
      opacity: 1;
    }

    .editing--top-menus .menu-buttons {
      opacity: 0.5;
    }

    .menus.menus-editing {
      opacity: 1;
      display: flex;
      flex-direction: column;
      max-height: calc((100vh - 100vw * 0.9 - 80px) / 2);
    }

    .menus>div.entry-items {
      /* background: var(--bg); */
      color: var(--fg);
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      opacity: 0.5;
      margin: 0 15px;
    }

    .menus>div.entry-items.entry-items-content {
      flex: 1;
      overflow-y: auto;
    }

    .menus>div.entry-items.editing {
      opacity: 1;
    }

    .menus>div .entry-item {}

    .floor-item.current {
      font-weight: bold;
      text-decoration: underline;
    }

    .editing .player {
      opacity: 0;
      pointer-events: none;
    }

    @media (orientation: portrait) {
      .editing-unit {
        width: 100%;
        border-radius: 2px;
      }
    }

    @media (orientation: landscape) {
      /* .editing .floor-wraper {
        transform: translate(-50%, -50%) scale(0.8);
      } */

      .cell-editing-panel-wraper {
        transform: translate(-50%, 0%) scale(0.8);
      }

      .cell-editing-panel-wraper.first {
        left: 50%;
        top: 45px;
        right: unset;
        bottom: unset;
      }

      .cell-editing-panel-wraper.second {
        left: 50%;
        top: unset;
        right: unset;
        bottom: 45px;
      }

      .cell-editing-panel {
        flex-direction: row;
      }

      .simple-props {
        grid-template-columns: repeat(4, 1fr);
      }

      .simple-props>* {
        margin-right: 20px;
      }

      .menus .props.editing-units {
        max-height: calc(100vh - 150px);
      }

      .menus>div.entry-items {
        grid-template-columns: repeat(1, 1fr);
      }

      .hidden-in-landscape {
        display: none !important;
      }

      .portrait-info {
        display: none !important;
      }

      .landscape-info {
        display: flex !important;
      }

      .skill-name::before {
        counter-increment: skill-name;
        content: counter(skill-name) ". ";
      }

      .action-content .answers .answer::before {
        counter-increment: answer;
        content: counter(answer) ". ";
      }

      .action-content {
        opacity: 1;
        width: 100%;
        backdrop-filter: blur(5px);
        border-radius: 10px 10px 0 0;
      }

      .menus.right,
      .menus.bottom,
      .menus-editing,
      .menus.top {
        max-width: calc((100vw - 100vh * 0.86) / 2);
      }

      .menus.menus-editing {
        max-height: calc(100vh - 200px);
        right: 0;
        left: unset;
      }

      .menus.bottom,
      .menus.right,
      .menus.left {
        bottom: unset;
        top: 60%;
        transform: translate(0, -50%);
      }

      .menus .props {
        grid-template-columns: repeat(3, 1fr);
      }

      .menus .props>.name {
        grid-column-end: 3;
      }

      .menus>div>.info {
        /* width: 5.5em; */
      }

      .skills-control {
        flex-wrap: unset;
        max-height: unset;
      }

      .unleart,
      .soldable {
        grid-template-columns: 1fr 1fr 1fr 1fr;
      }

      .battle-infos {
        display: grid;
        grid-gap: 10px;
        grid-template-columns: 1fr 1fr 1fr;
      }
    }

    .hidden {
      display: none;
    }

    #whenEditor {
      margin-top: 10px;
    }
  </style>
</template>
<style>
  body {
    --ambrosia: #fcdbba;
    --apricot: #ff8652;
    --aubergine: #6a2352;
    --auburn: #a12f2f;
    --asparagus: #a0c259;
    --beetroot: #7f0421;
    --blue-tack: #82bfe0;
    --bloom: #363a57;
    --blush: #d67b71;
    --bronze: #c27940;
    --bud: #94c15c;
    --burnt-orange: #ff5f00;
    --butter: #f2c94c;
    --strawberry-yogurt: #e4bcad;
    --carmine: #9a133e;
    --chocolate: #8f5d38;
    --chestnut: #81291f;
    --clay: #7d6050;
    --conker: #6f3131;
    --coral: #eb4444;
    --dusty-purple: #7d6391;
    --dusty-pink: #e4adad;
    --emerald: #55b95f;
    --fern: #4f8d08;
    --forest: #2e644a;
    --fudge: #c28742;
    --grassy: #a8d363;
    --green: #62b90a;
    --hazelnut: #d08e5a;
    --ink: #292c31;
    --ivory: #f2efe3;
    --lapis: #2b4d8d;
    --leafy: #318553;
    --lemon: #eafc7e;
    --lime: #73d645;
    --limestone: #c9c5b5;
    --magenta: #bc2767;
    --meadow: #7a9a3e;
    --melon: #f2994a;
    --midnight: #1b3955;
    --mink: #e8c9a1;
    --mint: #c4ea70;
    --moss: #7db21c;
    --mushroom: #ede8d5;
    --navy: #363a57;
    --orange: #fd8a04;
    --pale-lemon: #f4ffdc;
    --peach: #ffb190;
    --pond-bottom: #264a46;
    --powder-blue: #b5d0e0;
    --powder-pink: #fbd1d1;
    --primrose: #e1f7b0;
    --purple: #a95af3;
    --purple-slate: #545375;
    --rainforest: #25422e;
    --raspberry-jam: #3c0d2b;
    --robins-egg: #b8dee0;
    --rouge: #cc3737;
    --royal: #4169e1;
    --ruby: #d1314b;
    --sage: #87a376;
    --sakura: #ffe4e4;
    --sea-glass: #7fd1ae;
    --sea-foam: #5d998b;
    --sea-fog: #758c92;
    --slate: #7184a5;
    --spearmint: #94e0cf;
    --spring: #5acb65;
    --succulent: #83a944;
    --twilight: #203763;
    --vavavoom: #bf0d0d;
    --white: #ffffff;
    --yellow: #ffe03d;
    --trans: transparent;
    --trans05: rgba(255, 255, 255, 0.05);
    --trans1: rgba(255, 255, 255, 0.1);
    --trans2: rgba(255, 255, 255, 0.2);
    --trans4: rgba(255, 255, 255, 0.4);
  }
</style>
<script>
  window.appData = window.appData || {
    "@media-cellWidth": [[40, "(min-width: 600px)"], [32]],
    editor: true,
  };
</script>

<meta name="viewport" content="width=device-width, maximum-scale=1.0,user-scalable=no, initial-scale=1" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="transparent" />
<script>
  const {
    registerElement,
    registerProperties,
    evalInContext,
    delayDispatcher,
  } = (() => {
    const evalInContext = (exp, context) => {
      return function () {
        with (this) {
          try {
            return eval(`(${exp})`);
          } catch (e) {
            console.log(exp);
            console.log(e);
            return;
          }
        }
      }.call(context);
    };

    const removeItem = (item) => {
      const clearItem = (/**@type {HTMLElement}*/ item) => {
        for (let c of item.childNodes) {
          clearItem(c);
        }
        let onRemoves = item.onRemoves;
        item.onRemoves = undefined;
        if (onRemoves?.length) {
          onRemoves.forEach((onRemove) => onRemove());
        }
      };
      clearItem(item);
      item.remove();
    };

    const onprop = (parent, /**@type {String} */ exp, context, listener) => {
      const tokens = exp.split(/\.|\?\.|\[|\]/);
      if (!tokens[1]) {
        if (context.tmpCtxName === tokens[0]) {
        } else {
          context.on && context.on(tokens[0], listener, true, parent);
          parent.onRemoves = [
            ...(parent.onRemoves || []),
            () => {
              context.off(tokens[0], listener, true);
            },
          ];
        }
        return;
      }
      if (context.tmpCtxName === tokens[0]) {
        context = context[context.tmpCtxName];
        tokens.shift();
      }
      const clearBind = (current) => {
        while (current) {
          if (current.off) {
            current.off();
          }
          const next = current.next;
          current.next = undefined;
          current = next;
        }
      };
      const register = (tokens, handler, context, offChain) => {
        const prop = tokens[0];
        if (!prop || !context) {
          return;
        }
        offChain.next = {};
        const registerNext = () => {
          register(tokens.slice(1), handler, context[prop], offChain.next);
        };
        if (context.on && context.on instanceof Function) {
          const listener = (...args) => {
            clearBind(offChain.next);
            offChain.next = {};
            registerNext();
            handler(...args);
          };
          context.on(prop, listener, true, parent);
          offChain.off = () => {
            context.off(prop, listener, true);
          };
        }
        registerNext();
      };
      const offChain = {};
      register(tokens, listener, context, offChain);
      parent.onRemoves = [
        ...(parent.onRemoves || []),
        () => {
          clearBind(offChain);
        },
      ];
    };

    const bindingForInstruction = (/**@type HTMLElement */ element) => {
      let forExp = element.getAttribute("for.");
      const match = forExp.match(
        /^\s*(((let|const|of)\s+)?(\w+)\s+(of|in)\s+)?\s*(.+)\s*$/
      );
      if (!match || !match[6]) {
        throw new Error("Invalid for Expression");
      }
      const collectionName = match[6];
      const of_in = match[5] || "of";
      let varName = match[4];
      let forHead;
      if (varName) {
        forHead = `for(const ${varName} ${of_in} ${collectionName})`;
      } else {
        varName = "$$i";
        forHead = `for(const ${varName} of ${collectionName})`;
      }
      const comment = document.createComment(element.outerHTML);
      const parent = element.parentElement;
      parent.insertBefore(comment, element);
      element.remove();
      /**@type Map<any, HTMLElement> */
      let items = new Map();
      /**@type Map<any, HTMLElement> */
      let newItems = new Map();
      let idx = 0;
      let allRemoved = false;
      const update = () => {
        (function ($$forEach) {
          newItems = new Map();
          idx = 0;
          allRemoved = false;
          with (this) {
            eval(`
          let collection
          try{
            collection = this.${collectionName}
          }
          catch{
            //ignore
          }
          if (collection) {
            ${forHead}{
              $$forEach(${varName})
              }
          }`);
          }
          for (const [_, { item }] of items) {
            removeItem(item);
          }
          items = newItems;
        }.call(element.context, ($$i) => {
          /**@type HTMLElement */
          let item;
          if (items.has($$i)) {
            const pair = items.get($$i);
            item = pair.item;
            if (!allRemoved && idx !== pair.idx) {
              console.log("removed");
              for (const [_, { item }] of items) {
                removeItem(item);
              }
              allRemoved = true;
            }
            items.delete($$i);
          } else {
            item = element.cloneNode(true);
            item.removeAttribute("id");
            item.removeAttribute("for.");
            if (item.updateModel) {
              item.model = $$i;
            } else {
              item.modelBeforeInit = $$i;
            }
            const context = Object.create(element.context);
            context[varName] = $$i;
            context.tmpCtxName = varName;
            item.context = context;
          }
          parent.insertBefore(item, comment);
          newItems.set($$i, { idx, item });
          binding(item);
          idx++;
        }));
      };
      update();
      let lastContext = element.context;
      comment.updateWhenModelChange = () => {
        if (lastContext === element.context) {
          return;
        }
        lastContext = element.context;
        update();
      };
      onprop(parent, collectionName, element.context, update);
      return {};
    };

    const bindingIfInstruction = (
        /**@type HTMLElement */ element,
      keyChangeRemove
    ) => {
      let ifExp = element.getAttribute("if.");
      const comment = document.createComment(element.outerHTML);
      const parent = element.parentElement;
      parent.insertBefore(comment, element);
      element.remove();
      let item;
      let lastValue;
      const update = () => {
        const value = evalInContext(ifExp, element.context);
        if (keyChangeRemove && value !== lastValue && item) {
          removeItem(item);
          item = undefined;
        }
        if (value) {
          if (item) {
            return;
          }
          item = element.cloneNode(true);
          item.removeAttribute("if.");
          item.removeAttribute("keyif.");
          parent.insertBefore(item, comment);
          item.context = element.context;
          binding(item);
        } else if (item) {
          removeItem(item);
          item = null;
        }
      };
      update();
      let lastContext = element.context;
      comment.updateWhenModelChange = () => {
        if (lastContext === element.context) {
          return;
        }
        lastContext = element.context;
        update();
      };
      for (const exp of getPropsFromExp(ifExp)) {
        onprop(parent, exp, element.context, update);
      }
      return {};
    };

    const getPropNameFromBindingAttr = (attr) => {
      return attr.replace(/-(\w)/g, (_, c) => c.toUpperCase());
    };

    const getPropsFromExp = (exp) => {
      return exp.match(/([a-zA-Z0-9_$.\[\]]|\?\.)+/g) || [];
      // return exp.match(/[a-zA-Z0-9_$.]+/g) || []
    };

    const bindingAttrs = (/**@type HTMLElement */ element) => {
      if (element.hasAttribute("for.")) {
        return bindingForInstruction(element);
      }
      if (element.hasAttribute("if.")) {
        return bindingIfInstruction(element, element.hasAttribute("keyif."));
      }
      if (element.updateWhenModelChange) {
        element.updateWhenModelChange();
        return element;
      }
      const bindingAttrs = element
        .getAttributeNames()
        .filter((p) => p.endsWith("."));
      for (const prop of bindingAttrs) {
        const $$exp = element.getAttribute(prop);
        const effectedAttr = prop
          .slice(0, -".".length)
          .split(",")
          .map((a) => a.trim())
          .filter((a) => a);

        if (effectedAttr.some((a) => a.startsWith("on"))) {
          const value = `(function($event){with(this){${$$exp}}}).call(event.target.context, event)`;
          for (const ea of effectedAttr) {
            if (ea.endsWith("$")) {
              element.setAttribute(
                ea.slice(0, -1),
                "event.stopPropagation();" + value
              );
            } else {
              element.setAttribute(ea, value);
            }
          }
          continue;
        }
        const update = () => {
          const value = evalInContext($$exp, element.context);
          for (const ea of effectedAttr) {
            if (ea === "model") {
              if (element.updateModel) {
                element.updateModel(value);
              } else {
                element.modelBeforeInit = value;
              }
              continue;
            }
            if (ea === "focus") {
              if (value) {
                if (element.scrollIntoViewIfNeeded) {
                  element.scrollIntoViewIfNeeded();
                } else {
                  element.scrollIntoView();
                }
                element.focus();
              }
              continue;
            }
            if (ea === "scrollintoview") {
              if (value) {
                if (element.scrollIntoViewIfNeeded) {
                  element.scrollIntoViewIfNeeded();
                } else {
                  element.scrollIntoView();
                }
              }
              continue;
            }
            if (ea.startsWith("class-")) {
              const className = ea.slice("class-".length);
              if (value) {
                element.classList.add(className);
              } else {
                element.classList.remove(className);
              }
              continue;
            } else if (ea.startsWith("style-")) {
              const prop = ea.slice("style-".length, -1);
              element.style.setProperty(prop, value);
              continue;
            }
            if (ea.endsWith("$")) {
              let prop = getPropNameFromBindingAttr(ea.slice(0, -1));
              switch (prop) {
                case "innerHtml":
                  prop = "innerHTML";
                  break;
              }
              element[prop] = value;
              continue;
            }
            if (value === undefined || value === null) {
              element.removeAttribute(ea);
            } else if (element[ea] !== value) {
              element.setAttribute(ea, value);
            }
          }
        };
        update();
        for (const exp of getPropsFromExp($$exp)) {
          onprop(element.parentElement, exp, element.context, update);
        }
      }
      return element;
    };

    const binding = (/**@type HTMLElement */ element) => {
      /**@type { Object.<string,HTMLElement> } */
      const components = element.context.components;
      if (element.hasAttribute) {
        const handler = bindingAttrs(element);
        //collect ids
        if (element.hasAttribute("id")) {
          components[element.getAttribute("id")] = handler;
        }
        if (handler !== element) {
          return;
        }
      }
      for (const child of [...element.children]) {
        if (
          child.context == element.context ||
          (child.context &&
            Object.getPrototypeOf(child.context) === element.context)
        ) {
        } else {
          child.context = element.context;
        }
        binding(child);
      }
    };

    const getNameFromTagName = (tagName) => {
      return tagName.replace(/(?:^|-)(\w)/g, (_, c) => c.toUpperCase());
    };

    class DelayDispatcher {
      constructor(delay = 50) {
        this.delay = delay;
        this.currentTask;
        this.running = false;
        this.lastDispatchTime = 0;
        this.groups = new Map();
        this.count = 0;
        // this.delayListeners = new Map()
      }

      set(obj, key, method) {
        let group = this.groups.get(obj);
        if (!group) {
          group = {};
          this.groups.set(obj, group);
        }
        group[key] = method;
      }

      async start() {
        if (this.running) {
          return;
        }
        this.running = true;
        this.currentTask = new Promise(async (resolve) => {
          while (this.running) {
            let now = Date.now();
            let remain = this.delay - (now - this.lastDispatchTime);
            if (remain > 0) {
              await new Promise((r) => setTimeout(r, remain));
            }
            let groups = this.groups;
            await new Promise((resolve) =>
              window.requestAnimationFrame(async () => {
                this.groups = new Map();
                for (let [obj, group] of groups) {
                  if (!obj || !group) {
                    continue;
                  }
                  for (let p in group) {
                    try {
                      group[p]?.();
                    } catch (e) {
                      console.log(e);
                    }
                  }
                }
                resolve();
              })
            );
          }
          this.lastDispatchTime = Date.now();
          this.currentTask = undefined;
          this.running = false;
          resolve();
        });
        await this.currentTask;
      }

      async stop() {
        this.running = false;
        await this.currentTask;
      }

      setDelay(delay) {
        this.delay = delay;
      }
    }

    const delayDispatcher = new DelayDispatcher();

    const registerProperties = (obj, ...props) => {
      const backup = {};
      if (!obj.define) {
        addPropChange(obj);
      }
      props.forEach((prop) => {
        const desc = Object.getOwnPropertyDescriptor(obj, prop);
        if (desc && !desc.configurable) {
          delete backup[prop];
          return;
        }
        let propValue;
        let [propName, handler] =
          prop instanceof Array ? prop : [prop, undefined];
        if (obj[propName] !== undefined) {
          backup[propName] = obj[propName];
        }
        Object.defineProperty(obj, propName, {
          get() {
            return propValue;
          },
          set(newValue) {
            if (propValue === newValue) {
              return;
            }
            const oldValue = propValue;
            propValue = newValue;
            obj.raise(propName, newValue, oldValue);
            handler?.(newValue, oldValue);
            delayDispatcher.set(obj, propName, () => {
              obj.raise(propName, newValue, oldValue, true);
            });
          },
        });
      });
      Object.assign(obj, backup);
      return obj;
    };

    const registerAllProperties = (obj) => {
      return registerProperties(obj, ...Object.keys(obj));
    };

    Object.defineProperty(Object.prototype, "registerProperties", {
      value: function (...props) {
        return registerProperties(this, ...props);
      },
    });

    Object.defineProperty(Object.prototype, "registerAllProperties", {
      value: function () {
        return registerAllProperties(this);
      },
    });

    delayDispatcher;

    const addPropChange = (/**@type { Object } */ obj) => {
      /**@type Map<string, Set<{(newValue, oldValue):any}>> */
      const atonceListeners = new Map();
      const delayListeners = new Map();
      const thisProp = "this";
      Object.defineProperty(obj, thisProp, {
        get() {
          return obj;
        },
      });
      Object.defineProperty(obj, "define", {
        value: (...props) => registerProperties(obj, ...props),
      });
      Object.defineProperty(obj, "on", {
        value: (
            /**@type string */ prop,
          listener,
          delay = false,
          additional
        ) => {
          let l = delay ? delayListeners : atonceListeners;
          if (!l.has(prop)) {
            l.set(prop, new Map());
          }
          l.get(prop).set(listener, additional);
          if (delay && delayDispatcher?.delayListeners) {
            delayDispatcher.delayListeners.set(listener, additional);
          }
          delayDispatcher.count++;
        },
      });

      Object.defineProperty(obj, "off", {
        value: (prop, listener, delay = false) => {
          let l = delay ? delayListeners : atonceListeners;
          if (!l.has(prop)) {
            return;
          }
          l.get(prop).delete(listener);
          if (delay && delayDispatcher?.delayListeners) {
            delayDispatcher.delayListeners.delete(listener);
          }
          delayDispatcher.count--;
        },
      });

      Object.defineProperty(obj, "clearOn", {
        value: (delay) => {
          let l = delay ? delayListeners : atonceListeners;
          delayDispatcher.count -= l.size;
          if (delay && delayDispatcher?.delayListeners) {
            l.forEach((_, listener) => {
              delayDispatcher.delayListeners.delete(listener);
            });
          }
          l.clear();
          // for (let p in obj) {
          //   obj[p].clearOn?.(delay)
          // }
        },
      });
      Object.defineProperty(obj, "dispose", {
        value: () => {
          obj.clearOn(false);
          obj.clearOn(true);
        },
      });
      Object.defineProperty(obj, "hasOn", {
        value: (prop, delay = false) => {
          let l = delay ? delayListeners : atonceListeners;
          return l.has(prop);
        },
      });

      Object.defineProperty(obj, "raise", {
        value: (prop, newValue, oldValue, delay = false) => {
          if (prop !== thisProp) {
            obj.raise(thisProp, obj, obj, delay);
          }
          let l = delay ? delayListeners : atonceListeners;
          if (!l.has(prop)) {
            return;
          }
          for (const [listener, _] of l.get(prop)) {
            listener(newValue, oldValue);
          }
        },
      });
    };

    const registerElement = (tagName, /**@type { string } */ constructor) => {
      const elementClassName = `HTML${constructor || getNameFromTagName(tagName)
        }Element`;
      constructor = constructor || "Object";
      eval(`
    class ${elementClassName} extends HTMLElement{
      constructor(){
        super()
        const shadow = this.attachShadow({mode:'open'})
        const template = document.getElementById('${tagName}')
        if(!template || template.tagName !== 'TEMPLATE' ){
          throw new Error('Define Template')
        }
        this.template_ = template
        this.shadow_ = shadow
        this.model_ = new ${constructor}()
        this.model_.components = { host: this.shadow_ }
        if(this.context && this.hasAttribute('model.')){
          const modeExp = this.getAttribute('model.')
          this.model = evalInContext(modeExp, this.context)
        }else if(this.modelBeforeInit){
          this.model = this.modelBeforeInit
        }else{
          this.model =  {}
        }
      }

      rebuildView(){
        this.shadow_.innerHTML = ''
        const instance = document.importNode(this.template_.content, true)
        this.shadow_.appendChild(instance)
      }
  
      get model(){
        return this.model_
      }
  
      set model(value){
        if(value?.on){
          this.model_ = value || {}
          this.model_.components = { host: this.shadow_ , ...this.model_.components||{}}
        }else{
          //combine code behind with model
          Object.assign(this.model_, value)
        }
        this.shadow_.context = this.model_ 
        this.rebuildView()
      }
  
      updateModel(value){
        this.model = value
        this.connectedCallback()
      }
      
      connectedCallback(){
        binding(this.shadow_)
        if(this.model_.launch){
          this.model_.launch()
        } 
      }
    }
    customElements.define('${tagName}', ${elementClassName})
    `);
    };
    return {
      registerElement,
      registerProperties,
      evalInContext,
      delayDispatcher,
    };
  })();

  const sleep = (timeout) =>
    new Promise((resolve) => setTimeout(resolve, timeout));

  class AppBase {
    async launch() {
      if (this.launched) {
        return;
      }
      this.launched = true;
      this.storage = this.initStorage_();
      this.data = await this.initData(window.appData);
      window.app = this;
      await this.start();
    }

    async registerStorageProperties(...props) {
      if (!this.storage) {
        return;
      }
      let asyncTimeout = 50;
      const bgTimeout = 200;
      for (const [prop, defaultValue, onchange] of props) {
        let propValue;
        let valueModified = false;
        let successLoadFromStorage = false;
        let loadFunc;
        let bgLoad = false;
        const mergeValue = (savedValue) => {
          if (successLoadFromStorage) {
            return;
          }
          successLoadFromStorage = true;
          if (!valueModified) {
            valueModified = true;
            propValue = savedValue;
          } else {
            // merge strategy
            propValue = savedValue;
          }
          if (bgLoad && onchange) {
            onchange();
          }
        };
        loadFunc = async () => {
          const jsonStr = await this.storage.getItem(prop);
          let savedValue;
          if (!jsonStr) {
            savedValue = defaultValue;
          } else {
            try {
              savedValue = JSON.parse(jsonStr);
            } catch {
              savedValue = defaultValue;
            }
          }
          mergeValue(savedValue);
        };
        const tryLoad = async () => {
          bgLoad = true;
          const func = loadFunc;
          loadFunc = null;
          await Promise.race([
            func(),
            sleep(bgTimeout).then(() => {
              if (!successLoadFromStorage) {
                loadFunc = func;
              }
            }),
          ]);
        };
        await Promise.race([
          loadFunc(),
          sleep(asyncTimeout).then(() => {
            if (!valueModified) {
              propValue = defaultValue;
              valueModified = true;
              asyncTimeout = 0;
            }
          }),
        ]);
        Object.defineProperty(this, prop, {
          get() {
            if (loadFunc) {
              tryLoad();
            }
            return propValue;
          },
          set(newValue) {
            propValue = newValue;
            if (successLoadFromStorage) {
              this.storage.setItem(prop, JSON.stringify(propValue));
            }
          },
        });
      }
    }

    initStorage_() {
      if (window.$localStorage) {
        return window.$localStorage;
      }
      try {
        const s = window.localStorage;
        return s;
      } catch {
        return {
          getItem: () => "",
          setItem: () => true,
        };
      }
    }

    async initData(data) {
      return data;
    }

    async start() {
      console.log("start");
    }

    async pause() {
      console.log("pause");
    }

    async resume() {
      console.log("pause");
    }

    async stop() {
      console.log("stop");
    }
  }

  window.onload = async () => {
    let currentClass = App;
    while (true) {
      let baseClass = Object.getPrototypeOf(currentClass);
      if (
        !baseClass ||
        Object.getPrototypeOf(Object) === Object.getPrototypeOf(currentClass)
      ) {
        break;
      }
      currentClass = baseClass;
    }
    Object.setPrototypeOf(currentClass.prototype, AppBase.prototype);
    for (const template of document.querySelectorAll(
      "template[id][view-model]"
    )) {
      const tagName = template.getAttribute("id");
      if (!tagName) {
        continue;
      }
      const codeBehind = template.getAttribute("view-model");
      registerElement(tagName, codeBehind);
    }
    delayDispatcher.start();
  };
</script>

<style>
  html,
  body {
    height: 100%;
    margin: 0;
  }
</style>

<body>
  <app-main></app-main>

  <template id="h-stack" view-model>
    <slot></slot>
    <style>
      :host {
        display: flex;
        flex-direction: row;
      }
    </style>
  </template>
  <template id="v-stack" view-model>
    <slot></slot>
    <style>
      :host {
        display: flex;
        flex-direction: column;
      }
    </style>
  </template>
  <template id="hv-stack" view-model>
    <slot></slot>
    <style>
      :host {
        display: flex;
        flex-direction: column;
      }

      @media (orientation: landscape) {
        :host {
          flex-direction: row;
        }
      }
    </style>
  </template>

  <template id="vh-stack" view-model>
    <slot></slot>
    <style>
      :host {
        display: flex;
        flex-direction: row;
      }

      @media (orientation: landscape) {
        :host {
          flex-direction: column;
        }
      }
    </style>
  </template>

  <template id="h-square" view-model>
    <slot></slot>
    <style>
      :host {
        width: 100vw;
        height: 100vw;
      }

      @media (orientation: landscape) {
        :host {
          width: 100vh;
          height: 100vh;
        }
      }
    </style>
  </template>

  <template id="h-spacer" view-model>
    <slot></slot>
    <style>
      :host {
        flex: 1;
        display: flex;
      }
    </style>
  </template>

  <template id="h-text" view-model>
    <span inner-text$.="content"></span>
    <style>
      :host {
        flex: 1;
        display: flex;
        align-items: center;
        place-content: center;
      }
    </style>
  </template>

  <template id="play-button" view-model>
    <span id="btnPlay" class="play-button" class-pause.="isPlaying"></span>
    <style>
      :host {
        display: block;
        border-radius: 5px;
        padding: 3px 10px;
        background-color: #fff4;
      }

      .play-button {
        display: block;
        width: 100%;
        height: 100%;
        background-color: var(--color);
        clip-path: polygon(25% 10%, 25% 90%, 95% 50%, 25% 10%);
        transition: 200ms all ease-in-out;
      }

      .play-button.pause {
        clip-path: polygon(60% 50%,
            20% 20%,
            20% 80%,
            60% 50%,
            60% 80%,
            80% 80%,
            80% 20%,
            60% 20%);
      }
    </style>
  </template>

  <template id="menu-bar" view-model>
    <h-stack>
      <div class-hidden.="!item.show" class="menu-item" for.="item of menus">
        <span inner-text$.="item.name" onclick.="item.onclick()"></span>
      </div>
    </h-stack>
    <style>
      :host {
        display: block;
      }

      h-stack {
        overflow: hidden;
      }

      .menu-item {
        margin: 5px;
        background-color: var(--menu-background-color);
        border-radius: 4px;
        padding: 2px 5px;
        color: var(--menu-color);
        display: flex;
        justify-content: center;
        flex: 1;
      }

      .menu-item>span {
        display: block;
        text-overflow: ellipsis;
        white-space: pre;
        overflow: hidden;
        max-width: 6em;
      }

      .hidden {
        display: none;
      }
    </style>
  </template>

  <script>
    class MenuItem {
      constructor(name = "", onclick = null, show = true) {
        registerProperties(this, "name", "show");
        this.name = name;
        this.show = show;
        this.onclick = onclick;
      }
    }
  </script>

  <template id="modal-panel" view-model="Modal">
    <div>
      <span class="toastMessage" if.="toastMessage" inner-text$.="toastMessage"></span>
      <div if.="open" class="modal-wraper" onclick.="close()">
        <div class="modal" onclick="event.stopPropagation()">
          <div class="title">
            <span inner-text$.="title"></span>
          </div>
          <div class="body">
            <div if.="items?.length">
              <div class="item" for.="item of items" class-highlight.="item === selectedItem" onclick.="close(item)">
                <span inner-text$.="options.itemName?item[options.itemName]:item"></span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <style>
      .hidden {
        /* left: -100%; */
        /* transition: ease-in-out 0.05s left; */
        display: none;
      }

      .toastMessage {
        color: var(--toast-color, #eee);
        background-color: var(--toast-background-color, #0008);
        position: fixed;
        bottom: 0;
        margin: 20px auto;
        left: 50%;
        transform: translate(-50%, 0);
        padding: 5px 20px;
        border-radius: 4px;
        text-align: center;
        backdrop-filter: blur(5px);
      }

      .modal-wraper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .modal {
        background: #fff;
        border-radius: 10px;
        padding: 10px;
        width: 90%;
        max-height: 90%;
        box-shadow: 3px 3px 5px;
      }

      .modal .title {
        font-size: large;
        margin: 5px 0;
        font-weight: bold;
      }

      .modal .body {
        margin: 5px 0;
      }

      .modal .foot {
        margin: 5px 0;
      }

      .item {
        margin: 8px 0;
        background: #0002;
        padding: 5px;
        border-radius: 8px;
      }

      .item.highlight {
        background: #0008;
        color: white;
      }
    </style>
  </template>
  <script>
    class Modal {
      constructor() {
        /**@type { Object.<string,HTMLElement> } */
        this.components;
        /**@type { Storage | {  } } */
        this.storage;
        registerProperties(
          this,
          "toastMessage",
          "title",
          "items",
          "selectedItem",
          "open",
          "options"
        );
      }
      toast(/**@string */ msg, /**@type number */ timeout = 1000, task) {
        return new Promise(async (resolve) => {
          this.toastMessage = msg;
          await task;
          setTimeout(() => {
            this.toastMessage = null;
            resolve();
          }, timeout);
        });
      }

      close(result) {
        if (!this.resolveTask) {
          return;
        }
        if (this.options.requilred && !result) {
          return;
        }
        this.open = undefined;
        this.resolveTask.resolve(result);
      }

      select(
          /** @type string */ msg,
          /** @type [any] */ values = [],
        defaultIdx = 0,
        opt = undefined
      ) {
        if (this.resolveTask) {
          const { resolve, reject } = this.resolveTask;
          this.resolveTask = undefined;
          reject();
        }
        this.title = msg;
        this.items = values;
        this.selectedItem = values[defaultIdx];
        this.options = opt || {};
        this.open = true;
        return new Promise(
          (resolve, reject) => (this.resolveTask = { resolve, reject })
        );
      }
    }
  </script>
  <template id="pop-up" view-model="Popup">
    <div class="popup">
      <slot></slot>
    </div>
    <style>
      :host {
        display: block;
        position: relative;
        left: 0;
        top: 0;
        bottom: 0;
        right: 0;
        position: fixed;
        background: #0008;
        backdrop-filter: blur(5px);
      }

      .popup {
        max-width: 99%;
        max-height: 99%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
    </style>
  </template>
  <script>
    class Popup { }
  </script>
</body>

</html>